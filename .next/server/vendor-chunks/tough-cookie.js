"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/tough-cookie";
exports.ids = ["vendor-chunks/tough-cookie"];
exports.modules = {

/***/ "(rsc)/./node_modules/tough-cookie/dist/index.cjs":
/*!**************************************************!*\
  !*** ./node_modules/tough-cookie/dist/index.cjs ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// lib/cookie/index.ts\nvar index_exports = {};\n__export(index_exports, {\n  Cookie: () => Cookie,\n  CookieJar: () => CookieJar,\n  MemoryCookieStore: () => MemoryCookieStore,\n  ParameterError: () => ParameterError,\n  PrefixSecurityEnum: () => PrefixSecurityEnum,\n  Store: () => Store,\n  canonicalDomain: () => canonicalDomain,\n  cookieCompare: () => cookieCompare,\n  defaultPath: () => defaultPath,\n  domainMatch: () => domainMatch,\n  formatDate: () => formatDate,\n  fromJSON: () => fromJSON2,\n  getPublicSuffix: () => getPublicSuffix,\n  parse: () => parse2,\n  parseDate: () => parseDate,\n  pathMatch: () => pathMatch,\n  permuteDomain: () => permuteDomain,\n  permutePath: () => permutePath,\n  version: () => version\n});\nmodule.exports = __toCommonJS(index_exports);\n\n// lib/pathMatch.ts\nfunction pathMatch(reqPath, cookiePath) {\n  if (cookiePath === reqPath) {\n    return true;\n  }\n  const idx = reqPath.indexOf(cookiePath);\n  if (idx === 0) {\n    if (cookiePath[cookiePath.length - 1] === \"/\") {\n      return true;\n    }\n    if (reqPath.startsWith(cookiePath) && reqPath[cookiePath.length] === \"/\") {\n      return true;\n    }\n  }\n  return false;\n}\n\n// lib/getPublicSuffix.ts\nvar import_tldts = __webpack_require__(/*! tldts */ \"(rsc)/./node_modules/tldts/dist/es6/index.js\");\nvar SPECIAL_USE_DOMAINS = [\"local\", \"example\", \"invalid\", \"localhost\", \"test\"];\nvar SPECIAL_TREATMENT_DOMAINS = [\"localhost\", \"invalid\"];\nvar defaultGetPublicSuffixOptions = {\n  allowSpecialUseDomain: false,\n  ignoreError: false\n};\nfunction getPublicSuffix(domain, options = {}) {\n  options = { ...defaultGetPublicSuffixOptions, ...options };\n  const domainParts = domain.split(\".\");\n  const topLevelDomain = domainParts[domainParts.length - 1];\n  const allowSpecialUseDomain = !!options.allowSpecialUseDomain;\n  const ignoreError = !!options.ignoreError;\n  if (allowSpecialUseDomain && topLevelDomain !== void 0 && SPECIAL_USE_DOMAINS.includes(topLevelDomain)) {\n    if (domainParts.length > 1) {\n      const secondLevelDomain = domainParts[domainParts.length - 2];\n      return `${secondLevelDomain}.${topLevelDomain}`;\n    } else if (SPECIAL_TREATMENT_DOMAINS.includes(topLevelDomain)) {\n      return topLevelDomain;\n    }\n  }\n  if (!ignoreError && topLevelDomain !== void 0 && SPECIAL_USE_DOMAINS.includes(topLevelDomain)) {\n    throw new Error(\n      `Cookie has domain set to the public suffix \"${topLevelDomain}\" which is a special use domain. To allow this, configure your CookieJar with {allowSpecialUseDomain: true, rejectPublicSuffixes: false}.`\n    );\n  }\n  const publicSuffix = (0, import_tldts.getDomain)(domain, {\n    allowIcannDomains: true,\n    allowPrivateDomains: true\n  });\n  if (publicSuffix) return publicSuffix;\n}\n\n// lib/permuteDomain.ts\nfunction permuteDomain(domain, allowSpecialUseDomain) {\n  const pubSuf = getPublicSuffix(domain, {\n    allowSpecialUseDomain\n  });\n  if (!pubSuf) {\n    return void 0;\n  }\n  if (pubSuf == domain) {\n    return [domain];\n  }\n  if (domain.slice(-1) == \".\") {\n    domain = domain.slice(0, -1);\n  }\n  const prefix = domain.slice(0, -(pubSuf.length + 1));\n  const parts = prefix.split(\".\").reverse();\n  let cur = pubSuf;\n  const permutations = [cur];\n  while (parts.length) {\n    const part = parts.shift();\n    cur = `${part}.${cur}`;\n    permutations.push(cur);\n  }\n  return permutations;\n}\n\n// lib/store.ts\nvar Store = class {\n  constructor() {\n    this.synchronous = false;\n  }\n  /**\n   * @internal No doc because this is an overload that supports the implementation\n   */\n  findCookie(_domain, _path, _key, _callback) {\n    throw new Error(\"findCookie is not implemented\");\n  }\n  /**\n   * @internal No doc because this is an overload that supports the implementation\n   */\n  findCookies(_domain, _path, _allowSpecialUseDomain = false, _callback) {\n    throw new Error(\"findCookies is not implemented\");\n  }\n  /**\n   * @internal No doc because this is an overload that supports the implementation\n   */\n  putCookie(_cookie, _callback) {\n    throw new Error(\"putCookie is not implemented\");\n  }\n  /**\n   * @internal No doc because this is an overload that supports the implementation\n   */\n  updateCookie(_oldCookie, _newCookie, _callback) {\n    throw new Error(\"updateCookie is not implemented\");\n  }\n  /**\n   * @internal No doc because this is an overload that supports the implementation\n   */\n  removeCookie(_domain, _path, _key, _callback) {\n    throw new Error(\"removeCookie is not implemented\");\n  }\n  /**\n   * @internal No doc because this is an overload that supports the implementation\n   */\n  removeCookies(_domain, _path, _callback) {\n    throw new Error(\"removeCookies is not implemented\");\n  }\n  /**\n   * @internal No doc because this is an overload that supports the implementation\n   */\n  removeAllCookies(_callback) {\n    throw new Error(\"removeAllCookies is not implemented\");\n  }\n  /**\n   * @internal No doc because this is an overload that supports the implementation\n   */\n  getAllCookies(_callback) {\n    throw new Error(\n      \"getAllCookies is not implemented (therefore jar cannot be serialized)\"\n    );\n  }\n};\n\n// lib/utils.ts\nvar objectToString = (obj) => Object.prototype.toString.call(obj);\nvar safeArrayToString = (arr, seenArrays) => {\n  if (typeof arr.join !== \"function\") return objectToString(arr);\n  seenArrays.add(arr);\n  const mapped = arr.map(\n    (val) => val === null || val === void 0 || seenArrays.has(val) ? \"\" : safeToStringImpl(val, seenArrays)\n  );\n  return mapped.join();\n};\nvar safeToStringImpl = (val, seenArrays = /* @__PURE__ */ new WeakSet()) => {\n  if (typeof val !== \"object\" || val === null) {\n    return String(val);\n  } else if (typeof val.toString === \"function\") {\n    return Array.isArray(val) ? (\n      // Arrays have a weird custom toString that we need to replicate\n      safeArrayToString(val, seenArrays)\n    ) : (\n      // eslint-disable-next-line @typescript-eslint/no-base-to-string\n      String(val)\n    );\n  } else {\n    return objectToString(val);\n  }\n};\nvar safeToString = (val) => safeToStringImpl(val);\nfunction createPromiseCallback(cb) {\n  let callback;\n  let resolve;\n  let reject;\n  const promise = new Promise((_resolve, _reject) => {\n    resolve = _resolve;\n    reject = _reject;\n  });\n  if (typeof cb === \"function\") {\n    callback = (err, result) => {\n      try {\n        if (err) cb(err);\n        else cb(null, result);\n      } catch (e) {\n        reject(e instanceof Error ? e : new Error());\n      }\n    };\n  } else {\n    callback = (err, result) => {\n      try {\n        if (err) reject(err);\n        else resolve(result);\n      } catch (e) {\n        reject(e instanceof Error ? e : new Error());\n      }\n    };\n  }\n  return {\n    promise,\n    callback,\n    resolve: (value) => {\n      callback(null, value);\n      return promise;\n    },\n    reject: (error) => {\n      callback(error);\n      return promise;\n    }\n  };\n}\nfunction inOperator(k, o) {\n  return k in o;\n}\n\n// lib/memstore.ts\nvar MemoryCookieStore = class extends Store {\n  /**\n   * Create a new {@link MemoryCookieStore}.\n   */\n  constructor() {\n    super();\n    this.synchronous = true;\n    this.idx = /* @__PURE__ */ Object.create(null);\n  }\n  /**\n   * @internal No doc because this is an overload that supports the implementation\n   */\n  findCookie(domain, path, key, callback) {\n    const promiseCallback = createPromiseCallback(callback);\n    if (domain == null || path == null || key == null) {\n      return promiseCallback.resolve(void 0);\n    }\n    const result = this.idx[domain]?.[path]?.[key];\n    return promiseCallback.resolve(result);\n  }\n  /**\n   * @internal No doc because this is an overload that supports the implementation\n   */\n  findCookies(domain, path, allowSpecialUseDomain = false, callback) {\n    if (typeof allowSpecialUseDomain === \"function\") {\n      callback = allowSpecialUseDomain;\n      allowSpecialUseDomain = true;\n    }\n    const results = [];\n    const promiseCallback = createPromiseCallback(callback);\n    if (!domain) {\n      return promiseCallback.resolve([]);\n    }\n    let pathMatcher;\n    if (!path) {\n      pathMatcher = function matchAll(domainIndex) {\n        for (const curPath in domainIndex) {\n          const pathIndex = domainIndex[curPath];\n          for (const key in pathIndex) {\n            const value = pathIndex[key];\n            if (value) {\n              results.push(value);\n            }\n          }\n        }\n      };\n    } else {\n      pathMatcher = function matchRFC(domainIndex) {\n        for (const cookiePath in domainIndex) {\n          if (pathMatch(path, cookiePath)) {\n            const pathIndex = domainIndex[cookiePath];\n            for (const key in pathIndex) {\n              const value = pathIndex[key];\n              if (value) {\n                results.push(value);\n              }\n            }\n          }\n        }\n      };\n    }\n    const domains = permuteDomain(domain, allowSpecialUseDomain) || [domain];\n    const idx = this.idx;\n    domains.forEach((curDomain) => {\n      const domainIndex = idx[curDomain];\n      if (!domainIndex) {\n        return;\n      }\n      pathMatcher(domainIndex);\n    });\n    return promiseCallback.resolve(results);\n  }\n  /**\n   * @internal No doc because this is an overload that supports the implementation\n   */\n  putCookie(cookie, callback) {\n    const promiseCallback = createPromiseCallback(callback);\n    const { domain, path, key } = cookie;\n    if (domain == null || path == null || key == null) {\n      return promiseCallback.resolve(void 0);\n    }\n    const domainEntry = this.idx[domain] ?? /* @__PURE__ */ Object.create(null);\n    this.idx[domain] = domainEntry;\n    const pathEntry = domainEntry[path] ?? /* @__PURE__ */ Object.create(null);\n    domainEntry[path] = pathEntry;\n    pathEntry[key] = cookie;\n    return promiseCallback.resolve(void 0);\n  }\n  /**\n   * @internal No doc because this is an overload that supports the implementation\n   */\n  updateCookie(_oldCookie, newCookie, callback) {\n    if (callback) this.putCookie(newCookie, callback);\n    else return this.putCookie(newCookie);\n  }\n  /**\n   * @internal No doc because this is an overload that supports the implementation\n   */\n  removeCookie(domain, path, key, callback) {\n    const promiseCallback = createPromiseCallback(callback);\n    delete this.idx[domain]?.[path]?.[key];\n    return promiseCallback.resolve(void 0);\n  }\n  /**\n   * @internal No doc because this is an overload that supports the implementation\n   */\n  removeCookies(domain, path, callback) {\n    const promiseCallback = createPromiseCallback(callback);\n    const domainEntry = this.idx[domain];\n    if (domainEntry) {\n      if (path) {\n        delete domainEntry[path];\n      } else {\n        delete this.idx[domain];\n      }\n    }\n    return promiseCallback.resolve(void 0);\n  }\n  /**\n   * @internal No doc because this is an overload that supports the implementation\n   */\n  removeAllCookies(callback) {\n    const promiseCallback = createPromiseCallback(callback);\n    this.idx = /* @__PURE__ */ Object.create(null);\n    return promiseCallback.resolve(void 0);\n  }\n  /**\n   * @internal No doc because this is an overload that supports the implementation\n   */\n  getAllCookies(callback) {\n    const promiseCallback = createPromiseCallback(callback);\n    const cookies = [];\n    const idx = this.idx;\n    const domains = Object.keys(idx);\n    domains.forEach((domain) => {\n      const domainEntry = idx[domain] ?? {};\n      const paths = Object.keys(domainEntry);\n      paths.forEach((path) => {\n        const pathEntry = domainEntry[path] ?? {};\n        const keys = Object.keys(pathEntry);\n        keys.forEach((key) => {\n          const keyEntry = pathEntry[key];\n          if (keyEntry != null) {\n            cookies.push(keyEntry);\n          }\n        });\n      });\n    });\n    cookies.sort((a, b) => {\n      return (a.creationIndex || 0) - (b.creationIndex || 0);\n    });\n    return promiseCallback.resolve(cookies);\n  }\n};\n\n// lib/validators.ts\nfunction isNonEmptyString(data) {\n  return isString(data) && data !== \"\";\n}\nfunction isEmptyString(data) {\n  return data === \"\" || data instanceof String && data.toString() === \"\";\n}\nfunction isString(data) {\n  return typeof data === \"string\" || data instanceof String;\n}\nfunction isObject(data) {\n  return objectToString(data) === \"[object Object]\";\n}\nfunction validate(bool, cbOrMessage, message) {\n  if (bool) return;\n  const cb = typeof cbOrMessage === \"function\" ? cbOrMessage : void 0;\n  let options = typeof cbOrMessage === \"function\" ? message : cbOrMessage;\n  if (!isObject(options)) options = \"[object Object]\";\n  const err = new ParameterError(safeToString(options));\n  if (cb) cb(err);\n  else throw err;\n}\nvar ParameterError = class extends Error {\n};\n\n// lib/version.ts\nvar version = \"6.0.0\";\n\n// lib/cookie/constants.ts\nvar PrefixSecurityEnum = {\n  SILENT: \"silent\",\n  STRICT: \"strict\",\n  DISABLED: \"unsafe-disabled\"\n};\nObject.freeze(PrefixSecurityEnum);\nvar IP_V6_REGEX = `\n\\\\[?(?:\n(?:[a-fA-F\\\\d]{1,4}:){7}(?:[a-fA-F\\\\d]{1,4}|:)|\n(?:[a-fA-F\\\\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}|:[a-fA-F\\\\d]{1,4}|:)|\n(?:[a-fA-F\\\\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}|(?::[a-fA-F\\\\d]{1,4}){1,2}|:)|\n(?:[a-fA-F\\\\d]{1,4}:){4}(?:(?::[a-fA-F\\\\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}|(?::[a-fA-F\\\\d]{1,4}){1,3}|:)|\n(?:[a-fA-F\\\\d]{1,4}:){3}(?:(?::[a-fA-F\\\\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}|(?::[a-fA-F\\\\d]{1,4}){1,4}|:)|\n(?:[a-fA-F\\\\d]{1,4}:){2}(?:(?::[a-fA-F\\\\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}|(?::[a-fA-F\\\\d]{1,4}){1,5}|:)|\n(?:[a-fA-F\\\\d]{1,4}:){1}(?:(?::[a-fA-F\\\\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}|(?::[a-fA-F\\\\d]{1,4}){1,6}|:)|\n(?::(?:(?::[a-fA-F\\\\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}|(?::[a-fA-F\\\\d]{1,4}){1,7}|:))\n)(?:%[0-9a-zA-Z]{1,})?\\\\]?\n`.replace(/\\s*\\/\\/.*$/gm, \"\").replace(/\\n/g, \"\").trim();\nvar IP_V6_REGEX_OBJECT = new RegExp(`^${IP_V6_REGEX}$`);\nvar IP_V4_REGEX = `(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])`;\nvar IP_V4_REGEX_OBJECT = new RegExp(`^${IP_V4_REGEX}$`);\n\n// lib/cookie/canonicalDomain.ts\nfunction domainToASCII(domain) {\n  return new URL(`http://${domain}`).hostname;\n}\nfunction canonicalDomain(domainName) {\n  if (domainName == null) {\n    return void 0;\n  }\n  let str = domainName.trim().replace(/^\\./, \"\");\n  if (IP_V6_REGEX_OBJECT.test(str)) {\n    if (!str.startsWith(\"[\")) {\n      str = \"[\" + str;\n    }\n    if (!str.endsWith(\"]\")) {\n      str = str + \"]\";\n    }\n    return domainToASCII(str).slice(1, -1);\n  }\n  if (/[^\\u0001-\\u007f]/.test(str)) {\n    return domainToASCII(str);\n  }\n  return str.toLowerCase();\n}\n\n// lib/cookie/formatDate.ts\nfunction formatDate(date) {\n  return date.toUTCString();\n}\n\n// lib/cookie/parseDate.ts\nvar DATE_DELIM = /[\\x09\\x20-\\x2F\\x3B-\\x40\\x5B-\\x60\\x7B-\\x7E]/;\nvar MONTH_TO_NUM = {\n  jan: 0,\n  feb: 1,\n  mar: 2,\n  apr: 3,\n  may: 4,\n  jun: 5,\n  jul: 6,\n  aug: 7,\n  sep: 8,\n  oct: 9,\n  nov: 10,\n  dec: 11\n};\nfunction parseDigits(token, minDigits, maxDigits, trailingOK) {\n  let count = 0;\n  while (count < token.length) {\n    const c = token.charCodeAt(count);\n    if (c <= 47 || c >= 58) {\n      break;\n    }\n    count++;\n  }\n  if (count < minDigits || count > maxDigits) {\n    return;\n  }\n  if (!trailingOK && count != token.length) {\n    return;\n  }\n  return parseInt(token.slice(0, count), 10);\n}\nfunction parseTime(token) {\n  const parts = token.split(\":\");\n  const result = [0, 0, 0];\n  if (parts.length !== 3) {\n    return;\n  }\n  for (let i = 0; i < 3; i++) {\n    const trailingOK = i == 2;\n    const numPart = parts[i];\n    if (numPart === void 0) {\n      return;\n    }\n    const num = parseDigits(numPart, 1, 2, trailingOK);\n    if (num === void 0) {\n      return;\n    }\n    result[i] = num;\n  }\n  return result;\n}\nfunction parseMonth(token) {\n  token = String(token).slice(0, 3).toLowerCase();\n  switch (token) {\n    case \"jan\":\n      return MONTH_TO_NUM.jan;\n    case \"feb\":\n      return MONTH_TO_NUM.feb;\n    case \"mar\":\n      return MONTH_TO_NUM.mar;\n    case \"apr\":\n      return MONTH_TO_NUM.apr;\n    case \"may\":\n      return MONTH_TO_NUM.may;\n    case \"jun\":\n      return MONTH_TO_NUM.jun;\n    case \"jul\":\n      return MONTH_TO_NUM.jul;\n    case \"aug\":\n      return MONTH_TO_NUM.aug;\n    case \"sep\":\n      return MONTH_TO_NUM.sep;\n    case \"oct\":\n      return MONTH_TO_NUM.oct;\n    case \"nov\":\n      return MONTH_TO_NUM.nov;\n    case \"dec\":\n      return MONTH_TO_NUM.dec;\n    default:\n      return;\n  }\n}\nfunction parseDate(cookieDate) {\n  if (!cookieDate) {\n    return;\n  }\n  const tokens = cookieDate.split(DATE_DELIM);\n  let hour;\n  let minute;\n  let second;\n  let dayOfMonth;\n  let month;\n  let year;\n  for (let i = 0; i < tokens.length; i++) {\n    const token = (tokens[i] ?? \"\").trim();\n    if (!token.length) {\n      continue;\n    }\n    if (second === void 0) {\n      const result = parseTime(token);\n      if (result) {\n        hour = result[0];\n        minute = result[1];\n        second = result[2];\n        continue;\n      }\n    }\n    if (dayOfMonth === void 0) {\n      const result = parseDigits(token, 1, 2, true);\n      if (result !== void 0) {\n        dayOfMonth = result;\n        continue;\n      }\n    }\n    if (month === void 0) {\n      const result = parseMonth(token);\n      if (result !== void 0) {\n        month = result;\n        continue;\n      }\n    }\n    if (year === void 0) {\n      const result = parseDigits(token, 2, 4, true);\n      if (result !== void 0) {\n        year = result;\n        if (year >= 70 && year <= 99) {\n          year += 1900;\n        } else if (year >= 0 && year <= 69) {\n          year += 2e3;\n        }\n      }\n    }\n  }\n  if (dayOfMonth === void 0 || month === void 0 || year === void 0 || hour === void 0 || minute === void 0 || second === void 0 || dayOfMonth < 1 || dayOfMonth > 31 || year < 1601 || hour > 23 || minute > 59 || second > 59) {\n    return;\n  }\n  return new Date(Date.UTC(year, month, dayOfMonth, hour, minute, second));\n}\n\n// lib/cookie/cookie.ts\nvar COOKIE_OCTETS = /^[\\x21\\x23-\\x2B\\x2D-\\x3A\\x3C-\\x5B\\x5D-\\x7E]+$/;\nvar PATH_VALUE = /[\\x20-\\x3A\\x3C-\\x7E]+/;\nvar CONTROL_CHARS = /[\\x00-\\x1F]/;\nvar TERMINATORS = [\"\\n\", \"\\r\", \"\\0\"];\nfunction trimTerminator(str) {\n  if (isEmptyString(str)) return str;\n  for (let t = 0; t < TERMINATORS.length; t++) {\n    const terminator = TERMINATORS[t];\n    const terminatorIdx = terminator ? str.indexOf(terminator) : -1;\n    if (terminatorIdx !== -1) {\n      str = str.slice(0, terminatorIdx);\n    }\n  }\n  return str;\n}\nfunction parseCookiePair(cookiePair, looseMode) {\n  cookiePair = trimTerminator(cookiePair);\n  let firstEq = cookiePair.indexOf(\"=\");\n  if (looseMode) {\n    if (firstEq === 0) {\n      cookiePair = cookiePair.substring(1);\n      firstEq = cookiePair.indexOf(\"=\");\n    }\n  } else {\n    if (firstEq <= 0) {\n      return void 0;\n    }\n  }\n  let cookieName, cookieValue;\n  if (firstEq <= 0) {\n    cookieName = \"\";\n    cookieValue = cookiePair.trim();\n  } else {\n    cookieName = cookiePair.slice(0, firstEq).trim();\n    cookieValue = cookiePair.slice(firstEq + 1).trim();\n  }\n  if (CONTROL_CHARS.test(cookieName) || CONTROL_CHARS.test(cookieValue)) {\n    return void 0;\n  }\n  const c = new Cookie();\n  c.key = cookieName;\n  c.value = cookieValue;\n  return c;\n}\nfunction parse(str, options) {\n  if (isEmptyString(str) || !isString(str)) {\n    return void 0;\n  }\n  str = str.trim();\n  const firstSemi = str.indexOf(\";\");\n  const cookiePair = firstSemi === -1 ? str : str.slice(0, firstSemi);\n  const c = parseCookiePair(cookiePair, options?.loose ?? false);\n  if (!c) {\n    return void 0;\n  }\n  if (firstSemi === -1) {\n    return c;\n  }\n  const unparsed = str.slice(firstSemi + 1).trim();\n  if (unparsed.length === 0) {\n    return c;\n  }\n  const cookie_avs = unparsed.split(\";\");\n  while (cookie_avs.length) {\n    const av = (cookie_avs.shift() ?? \"\").trim();\n    if (av.length === 0) {\n      continue;\n    }\n    const av_sep = av.indexOf(\"=\");\n    let av_key, av_value;\n    if (av_sep === -1) {\n      av_key = av;\n      av_value = null;\n    } else {\n      av_key = av.slice(0, av_sep);\n      av_value = av.slice(av_sep + 1);\n    }\n    av_key = av_key.trim().toLowerCase();\n    if (av_value) {\n      av_value = av_value.trim();\n    }\n    switch (av_key) {\n      case \"expires\":\n        if (av_value) {\n          const exp = parseDate(av_value);\n          if (exp) {\n            c.expires = exp;\n          }\n        }\n        break;\n      case \"max-age\":\n        if (av_value) {\n          if (/^-?[0-9]+$/.test(av_value)) {\n            const delta = parseInt(av_value, 10);\n            c.setMaxAge(delta);\n          }\n        }\n        break;\n      case \"domain\":\n        if (av_value) {\n          const domain = av_value.trim().replace(/^\\./, \"\");\n          if (domain) {\n            c.domain = domain.toLowerCase();\n          }\n        }\n        break;\n      case \"path\":\n        c.path = av_value && av_value[0] === \"/\" ? av_value : null;\n        break;\n      case \"secure\":\n        c.secure = true;\n        break;\n      case \"httponly\":\n        c.httpOnly = true;\n        break;\n      case \"samesite\":\n        switch (av_value ? av_value.toLowerCase() : \"\") {\n          case \"strict\":\n            c.sameSite = \"strict\";\n            break;\n          case \"lax\":\n            c.sameSite = \"lax\";\n            break;\n          case \"none\":\n            c.sameSite = \"none\";\n            break;\n          default:\n            c.sameSite = void 0;\n            break;\n        }\n        break;\n      default:\n        c.extensions = c.extensions || [];\n        c.extensions.push(av);\n        break;\n    }\n  }\n  return c;\n}\nfunction fromJSON(str) {\n  if (!str || isEmptyString(str)) {\n    return void 0;\n  }\n  let obj;\n  if (typeof str === \"string\") {\n    try {\n      obj = JSON.parse(str);\n    } catch {\n      return void 0;\n    }\n  } else {\n    obj = str;\n  }\n  const c = new Cookie();\n  Cookie.serializableProperties.forEach((prop) => {\n    if (obj && typeof obj === \"object\" && inOperator(prop, obj)) {\n      const val = obj[prop];\n      if (val === void 0) {\n        return;\n      }\n      if (inOperator(prop, cookieDefaults) && val === cookieDefaults[prop]) {\n        return;\n      }\n      switch (prop) {\n        case \"key\":\n        case \"value\":\n        case \"sameSite\":\n          if (typeof val === \"string\") {\n            c[prop] = val;\n          }\n          break;\n        case \"expires\":\n        case \"creation\":\n        case \"lastAccessed\":\n          if (typeof val === \"number\" || typeof val === \"string\" || val instanceof Date) {\n            c[prop] = obj[prop] == \"Infinity\" ? \"Infinity\" : new Date(val);\n          } else if (val === null) {\n            c[prop] = null;\n          }\n          break;\n        case \"maxAge\":\n          if (typeof val === \"number\" || val === \"Infinity\" || val === \"-Infinity\") {\n            c[prop] = val;\n          }\n          break;\n        case \"domain\":\n        case \"path\":\n          if (typeof val === \"string\" || val === null) {\n            c[prop] = val;\n          }\n          break;\n        case \"secure\":\n        case \"httpOnly\":\n          if (typeof val === \"boolean\") {\n            c[prop] = val;\n          }\n          break;\n        case \"extensions\":\n          if (Array.isArray(val) && val.every((item) => typeof item === \"string\")) {\n            c[prop] = val;\n          }\n          break;\n        case \"hostOnly\":\n        case \"pathIsDefault\":\n          if (typeof val === \"boolean\" || val === null) {\n            c[prop] = val;\n          }\n          break;\n      }\n    }\n  });\n  return c;\n}\nvar cookieDefaults = {\n  // the order in which the RFC has them:\n  key: \"\",\n  value: \"\",\n  expires: \"Infinity\",\n  maxAge: null,\n  domain: null,\n  path: null,\n  secure: false,\n  httpOnly: false,\n  extensions: null,\n  // set by the CookieJar:\n  hostOnly: null,\n  pathIsDefault: null,\n  creation: null,\n  lastAccessed: null,\n  sameSite: void 0\n};\nvar _Cookie = class _Cookie {\n  /**\n   * Create a new Cookie instance.\n   * @public\n   * @param options - The attributes to set on the cookie\n   */\n  constructor(options = {}) {\n    this.key = options.key ?? cookieDefaults.key;\n    this.value = options.value ?? cookieDefaults.value;\n    this.expires = options.expires ?? cookieDefaults.expires;\n    this.maxAge = options.maxAge ?? cookieDefaults.maxAge;\n    this.domain = options.domain ?? cookieDefaults.domain;\n    this.path = options.path ?? cookieDefaults.path;\n    this.secure = options.secure ?? cookieDefaults.secure;\n    this.httpOnly = options.httpOnly ?? cookieDefaults.httpOnly;\n    this.extensions = options.extensions ?? cookieDefaults.extensions;\n    this.creation = options.creation ?? cookieDefaults.creation;\n    this.hostOnly = options.hostOnly ?? cookieDefaults.hostOnly;\n    this.pathIsDefault = options.pathIsDefault ?? cookieDefaults.pathIsDefault;\n    this.lastAccessed = options.lastAccessed ?? cookieDefaults.lastAccessed;\n    this.sameSite = options.sameSite ?? cookieDefaults.sameSite;\n    this.creation = options.creation ?? /* @__PURE__ */ new Date();\n    Object.defineProperty(this, \"creationIndex\", {\n      configurable: false,\n      enumerable: false,\n      // important for assert.deepEqual checks\n      writable: true,\n      value: ++_Cookie.cookiesCreated\n    });\n    this.creationIndex = _Cookie.cookiesCreated;\n  }\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    const now = Date.now();\n    const hostOnly = this.hostOnly != null ? this.hostOnly.toString() : \"?\";\n    const createAge = this.creation && this.creation !== \"Infinity\" ? `${String(now - this.creation.getTime())}ms` : \"?\";\n    const accessAge = this.lastAccessed && this.lastAccessed !== \"Infinity\" ? `${String(now - this.lastAccessed.getTime())}ms` : \"?\";\n    return `Cookie=\"${this.toString()}; hostOnly=${hostOnly}; aAge=${accessAge}; cAge=${createAge}\"`;\n  }\n  /**\n   * For convenience in using `JSON.stringify(cookie)`. Returns a plain-old Object that can be JSON-serialized.\n   *\n   * @remarks\n   * - Any `Date` properties (such as {@link Cookie.expires}, {@link Cookie.creation}, and {@link Cookie.lastAccessed}) are exported in ISO format (`Date.toISOString()`).\n   *\n   *  - Custom Cookie properties are discarded. In tough-cookie 1.x, since there was no {@link Cookie.toJSON} method explicitly defined, all enumerable properties were captured.\n   *      If you want a property to be serialized, add the property name to {@link Cookie.serializableProperties}.\n   */\n  toJSON() {\n    const obj = {};\n    for (const prop of _Cookie.serializableProperties) {\n      const val = this[prop];\n      if (val === cookieDefaults[prop]) {\n        continue;\n      }\n      switch (prop) {\n        case \"key\":\n        case \"value\":\n        case \"sameSite\":\n          if (typeof val === \"string\") {\n            obj[prop] = val;\n          }\n          break;\n        case \"expires\":\n        case \"creation\":\n        case \"lastAccessed\":\n          if (typeof val === \"number\" || typeof val === \"string\" || val instanceof Date) {\n            obj[prop] = val == \"Infinity\" ? \"Infinity\" : new Date(val).toISOString();\n          } else if (val === null) {\n            obj[prop] = null;\n          }\n          break;\n        case \"maxAge\":\n          if (typeof val === \"number\" || val === \"Infinity\" || val === \"-Infinity\") {\n            obj[prop] = val;\n          }\n          break;\n        case \"domain\":\n        case \"path\":\n          if (typeof val === \"string\" || val === null) {\n            obj[prop] = val;\n          }\n          break;\n        case \"secure\":\n        case \"httpOnly\":\n          if (typeof val === \"boolean\") {\n            obj[prop] = val;\n          }\n          break;\n        case \"extensions\":\n          if (Array.isArray(val)) {\n            obj[prop] = val;\n          }\n          break;\n        case \"hostOnly\":\n        case \"pathIsDefault\":\n          if (typeof val === \"boolean\" || val === null) {\n            obj[prop] = val;\n          }\n          break;\n      }\n    }\n    return obj;\n  }\n  /**\n   * Does a deep clone of this cookie, implemented exactly as `Cookie.fromJSON(cookie.toJSON())`.\n   * @public\n   */\n  clone() {\n    return fromJSON(this.toJSON());\n  }\n  /**\n   * Validates cookie attributes for semantic correctness. Useful for \"lint\" checking any `Set-Cookie` headers you generate.\n   * For now, it returns a boolean, but eventually could return a reason string.\n   *\n   * @remarks\n   * Works for a few things, but is by no means comprehensive.\n   *\n   * @beta\n   */\n  validate() {\n    if (!this.value || !COOKIE_OCTETS.test(this.value)) {\n      return false;\n    }\n    if (this.expires != \"Infinity\" && !(this.expires instanceof Date) && !parseDate(this.expires)) {\n      return false;\n    }\n    if (this.maxAge != null && this.maxAge !== \"Infinity\" && (this.maxAge === \"-Infinity\" || this.maxAge <= 0)) {\n      return false;\n    }\n    if (this.path != null && !PATH_VALUE.test(this.path)) {\n      return false;\n    }\n    const cdomain = this.cdomain();\n    if (cdomain) {\n      if (cdomain.match(/\\.$/)) {\n        return false;\n      }\n      const suffix = getPublicSuffix(cdomain);\n      if (suffix == null) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Sets the 'Expires' attribute on a cookie.\n   *\n   * @remarks\n   * When given a `string` value it will be parsed with {@link parseDate}. If the value can't be parsed as a cookie date\n   * then the 'Expires' attribute will be set to `\"Infinity\"`.\n   *\n   * @param exp - the new value for the 'Expires' attribute of the cookie.\n   */\n  setExpires(exp) {\n    if (exp instanceof Date) {\n      this.expires = exp;\n    } else {\n      this.expires = parseDate(exp) || \"Infinity\";\n    }\n  }\n  /**\n   * Sets the 'Max-Age' attribute (in seconds) on a cookie.\n   *\n   * @remarks\n   * Coerces `-Infinity` to `\"-Infinity\"` and `Infinity` to `\"Infinity\"` so it can be serialized to JSON.\n   *\n   * @param age - the new value for the 'Max-Age' attribute (in seconds).\n   */\n  setMaxAge(age) {\n    if (age === Infinity) {\n      this.maxAge = \"Infinity\";\n    } else if (age === -Infinity) {\n      this.maxAge = \"-Infinity\";\n    } else {\n      this.maxAge = age;\n    }\n  }\n  /**\n   * Encodes to a `Cookie` header value (specifically, the {@link Cookie.key} and {@link Cookie.value} properties joined with \"=\").\n   * @public\n   */\n  cookieString() {\n    const val = this.value || \"\";\n    if (this.key) {\n      return `${this.key}=${val}`;\n    }\n    return val;\n  }\n  /**\n   * Encodes to a `Set-Cookie header` value.\n   * @public\n   */\n  toString() {\n    let str = this.cookieString();\n    if (this.expires != \"Infinity\") {\n      if (this.expires instanceof Date) {\n        str += `; Expires=${formatDate(this.expires)}`;\n      }\n    }\n    if (this.maxAge != null && this.maxAge != Infinity) {\n      str += `; Max-Age=${String(this.maxAge)}`;\n    }\n    if (this.domain && !this.hostOnly) {\n      str += `; Domain=${this.domain}`;\n    }\n    if (this.path) {\n      str += `; Path=${this.path}`;\n    }\n    if (this.secure) {\n      str += \"; Secure\";\n    }\n    if (this.httpOnly) {\n      str += \"; HttpOnly\";\n    }\n    if (this.sameSite && this.sameSite !== \"none\") {\n      if (this.sameSite.toLowerCase() === _Cookie.sameSiteCanonical.lax.toLowerCase()) {\n        str += `; SameSite=${_Cookie.sameSiteCanonical.lax}`;\n      } else if (this.sameSite.toLowerCase() === _Cookie.sameSiteCanonical.strict.toLowerCase()) {\n        str += `; SameSite=${_Cookie.sameSiteCanonical.strict}`;\n      } else {\n        str += `; SameSite=${this.sameSite}`;\n      }\n    }\n    if (this.extensions) {\n      this.extensions.forEach((ext) => {\n        str += `; ${ext}`;\n      });\n    }\n    return str;\n  }\n  /**\n   * Computes the TTL relative to now (milliseconds).\n   *\n   * @remarks\n   * - `Infinity` is returned for cookies without an explicit expiry\n   *\n   * - `0` is returned if the cookie is expired.\n   *\n   * - Otherwise a time-to-live in milliseconds is returned.\n   *\n   * @param now - passing an explicit value is mostly used for testing purposes since this defaults to the `Date.now()`\n   * @public\n   */\n  TTL(now = Date.now()) {\n    if (this.maxAge != null && typeof this.maxAge === \"number\") {\n      return this.maxAge <= 0 ? 0 : this.maxAge * 1e3;\n    }\n    const expires = this.expires;\n    if (expires === \"Infinity\") {\n      return Infinity;\n    }\n    return (expires?.getTime() ?? now) - (now || Date.now());\n  }\n  /**\n   * Computes the absolute unix-epoch milliseconds that this cookie expires.\n   *\n   * The \"Max-Age\" attribute takes precedence over \"Expires\" (as per the RFC). The {@link Cookie.lastAccessed} attribute\n   * (or the `now` parameter if given) is used to offset the {@link Cookie.maxAge} attribute.\n   *\n   * If Expires ({@link Cookie.expires}) is set, that's returned.\n   *\n   * @param now - can be used to provide a time offset (instead of {@link Cookie.lastAccessed}) to use when calculating the \"Max-Age\" value\n   */\n  expiryTime(now) {\n    if (this.maxAge != null) {\n      const relativeTo = now || this.lastAccessed || /* @__PURE__ */ new Date();\n      const maxAge = typeof this.maxAge === \"number\" ? this.maxAge : -Infinity;\n      const age = maxAge <= 0 ? -Infinity : maxAge * 1e3;\n      if (relativeTo === \"Infinity\") {\n        return Infinity;\n      }\n      return relativeTo.getTime() + age;\n    }\n    if (this.expires == \"Infinity\") {\n      return Infinity;\n    }\n    return this.expires ? this.expires.getTime() : void 0;\n  }\n  /**\n   * Similar to {@link Cookie.expiryTime}, computes the absolute unix-epoch milliseconds that this cookie expires and returns it as a Date.\n   *\n   * The \"Max-Age\" attribute takes precedence over \"Expires\" (as per the RFC). The {@link Cookie.lastAccessed} attribute\n   * (or the `now` parameter if given) is used to offset the {@link Cookie.maxAge} attribute.\n   *\n   * If Expires ({@link Cookie.expires}) is set, that's returned.\n   *\n   * @param now - can be used to provide a time offset (instead of {@link Cookie.lastAccessed}) to use when calculating the \"Max-Age\" value\n   */\n  expiryDate(now) {\n    const millisec = this.expiryTime(now);\n    if (millisec == Infinity) {\n      return /* @__PURE__ */ new Date(2147483647e3);\n    } else if (millisec == -Infinity) {\n      return /* @__PURE__ */ new Date(0);\n    } else {\n      return millisec == void 0 ? void 0 : new Date(millisec);\n    }\n  }\n  /**\n   * Indicates if the cookie has been persisted to a store or not.\n   * @public\n   */\n  isPersistent() {\n    return this.maxAge != null || this.expires != \"Infinity\";\n  }\n  /**\n   * Calls {@link canonicalDomain} with the {@link Cookie.domain} property.\n   * @public\n   */\n  canonicalizedDomain() {\n    return canonicalDomain(this.domain);\n  }\n  /**\n   * Alias for {@link Cookie.canonicalizedDomain}\n   * @public\n   */\n  cdomain() {\n    return canonicalDomain(this.domain);\n  }\n  /**\n   * Parses a string into a Cookie object.\n   *\n   * @remarks\n   * Note: when parsing a `Cookie` header it must be split by ';' before each Cookie string can be parsed.\n   *\n   * @example\n   * ```\n   * // parse a `Set-Cookie` header\n   * const setCookieHeader = 'a=bcd; Expires=Tue, 18 Oct 2011 07:05:03 GMT'\n   * const cookie = Cookie.parse(setCookieHeader)\n   * cookie.key === 'a'\n   * cookie.value === 'bcd'\n   * cookie.expires === new Date(Date.parse('Tue, 18 Oct 2011 07:05:03 GMT'))\n   * ```\n   *\n   * @example\n   * ```\n   * // parse a `Cookie` header\n   * const cookieHeader = 'name=value; name2=value2; name3=value3'\n   * const cookies = cookieHeader.split(';').map(Cookie.parse)\n   * cookies[0].name === 'name'\n   * cookies[0].value === 'value'\n   * cookies[1].name === 'name2'\n   * cookies[1].value === 'value2'\n   * cookies[2].name === 'name3'\n   * cookies[2].value === 'value3'\n   * ```\n   *\n   * @param str - The `Set-Cookie` header or a Cookie string to parse.\n   * @param options - Configures `strict` or `loose` mode for cookie parsing\n   */\n  static parse(str, options) {\n    return parse(str, options);\n  }\n  /**\n   * Does the reverse of {@link Cookie.toJSON}.\n   *\n   * @remarks\n   * Any Date properties (such as .expires, .creation, and .lastAccessed) are parsed via Date.parse, not tough-cookie's parseDate, since ISO timestamps are being handled at this layer.\n   *\n   * @example\n   * ```\n   * const json = JSON.stringify({\n   *   key: 'alpha',\n   *   value: 'beta',\n   *   domain: 'example.com',\n   *   path: '/foo',\n   *   expires: '2038-01-19T03:14:07.000Z',\n   * })\n   * const cookie = Cookie.fromJSON(json)\n   * cookie.key === 'alpha'\n   * cookie.value === 'beta'\n   * cookie.domain === 'example.com'\n   * cookie.path === '/foo'\n   * cookie.expires === new Date(Date.parse('2038-01-19T03:14:07.000Z'))\n   * ```\n   *\n   * @param str - An unparsed JSON string or a value that has already been parsed as JSON\n   */\n  static fromJSON(str) {\n    return fromJSON(str);\n  }\n};\n_Cookie.cookiesCreated = 0;\n/**\n * @internal\n */\n_Cookie.sameSiteLevel = {\n  strict: 3,\n  lax: 2,\n  none: 1\n};\n/**\n * @internal\n */\n_Cookie.sameSiteCanonical = {\n  strict: \"Strict\",\n  lax: \"Lax\"\n};\n/**\n * Cookie properties that will be serialized when using {@link Cookie.fromJSON} and {@link Cookie.toJSON}.\n * @public\n */\n_Cookie.serializableProperties = [\n  \"key\",\n  \"value\",\n  \"expires\",\n  \"maxAge\",\n  \"domain\",\n  \"path\",\n  \"secure\",\n  \"httpOnly\",\n  \"extensions\",\n  \"hostOnly\",\n  \"pathIsDefault\",\n  \"creation\",\n  \"lastAccessed\",\n  \"sameSite\"\n];\nvar Cookie = _Cookie;\n\n// lib/cookie/cookieCompare.ts\nvar MAX_TIME = 2147483647e3;\nfunction cookieCompare(a, b) {\n  let cmp;\n  const aPathLen = a.path ? a.path.length : 0;\n  const bPathLen = b.path ? b.path.length : 0;\n  cmp = bPathLen - aPathLen;\n  if (cmp !== 0) {\n    return cmp;\n  }\n  const aTime = a.creation && a.creation instanceof Date ? a.creation.getTime() : MAX_TIME;\n  const bTime = b.creation && b.creation instanceof Date ? b.creation.getTime() : MAX_TIME;\n  cmp = aTime - bTime;\n  if (cmp !== 0) {\n    return cmp;\n  }\n  cmp = (a.creationIndex || 0) - (b.creationIndex || 0);\n  return cmp;\n}\n\n// lib/cookie/defaultPath.ts\nfunction defaultPath(path) {\n  if (!path || path.slice(0, 1) !== \"/\") {\n    return \"/\";\n  }\n  if (path === \"/\") {\n    return path;\n  }\n  const rightSlash = path.lastIndexOf(\"/\");\n  if (rightSlash === 0) {\n    return \"/\";\n  }\n  return path.slice(0, rightSlash);\n}\n\n// lib/cookie/domainMatch.ts\nvar IP_REGEX_LOWERCASE = /(?:^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$)|(?:^(?:(?:[a-f\\d]{1,4}:){7}(?:[a-f\\d]{1,4}|:)|(?:[a-f\\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|:[a-f\\d]{1,4}|:)|(?:[a-f\\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-f\\d]{1,4}){1,2}|:)|(?:[a-f\\d]{1,4}:){4}(?:(?::[a-f\\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-f\\d]{1,4}){1,3}|:)|(?:[a-f\\d]{1,4}:){3}(?:(?::[a-f\\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-f\\d]{1,4}){1,4}|:)|(?:[a-f\\d]{1,4}:){2}(?:(?::[a-f\\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-f\\d]{1,4}){1,5}|:)|(?:[a-f\\d]{1,4}:){1}(?:(?::[a-f\\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-f\\d]{1,4}){1,6}|:)|(?::(?:(?::[a-f\\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-f\\d]{1,4}){1,7}|:)))$)/;\nfunction domainMatch(domain, cookieDomain, canonicalize) {\n  if (domain == null || cookieDomain == null) {\n    return void 0;\n  }\n  let _str;\n  let _domStr;\n  if (canonicalize !== false) {\n    _str = canonicalDomain(domain);\n    _domStr = canonicalDomain(cookieDomain);\n  } else {\n    _str = domain;\n    _domStr = cookieDomain;\n  }\n  if (_str == null || _domStr == null) {\n    return void 0;\n  }\n  if (_str == _domStr) {\n    return true;\n  }\n  const idx = _str.lastIndexOf(_domStr);\n  if (idx <= 0) {\n    return false;\n  }\n  if (_str.length !== _domStr.length + idx) {\n    return false;\n  }\n  if (_str.substring(idx - 1, idx) !== \".\") {\n    return false;\n  }\n  return !IP_REGEX_LOWERCASE.test(_str);\n}\n\n// lib/cookie/secureContext.ts\nfunction isLoopbackV4(address) {\n  const octets = address.split(\".\");\n  return octets.length === 4 && octets[0] !== void 0 && parseInt(octets[0], 10) === 127;\n}\nfunction isLoopbackV6(address) {\n  return address === \"::1\";\n}\nfunction isNormalizedLocalhostTLD(lowerHost) {\n  return lowerHost.endsWith(\".localhost\");\n}\nfunction isLocalHostname(host) {\n  const lowerHost = host.toLowerCase();\n  return lowerHost === \"localhost\" || isNormalizedLocalhostTLD(lowerHost);\n}\nfunction hostNoBrackets(host) {\n  if (host.length >= 2 && host.startsWith(\"[\") && host.endsWith(\"]\")) {\n    return host.substring(1, host.length - 1);\n  }\n  return host;\n}\nfunction isPotentiallyTrustworthy(inputUrl, allowSecureOnLocal = true) {\n  let url;\n  if (typeof inputUrl === \"string\") {\n    try {\n      url = new URL(inputUrl);\n    } catch {\n      return false;\n    }\n  } else {\n    url = inputUrl;\n  }\n  const scheme = url.protocol.replace(\":\", \"\").toLowerCase();\n  const hostname = hostNoBrackets(url.hostname).replace(/\\.+$/, \"\");\n  if (scheme === \"https\" || scheme === \"wss\") {\n    return true;\n  }\n  if (!allowSecureOnLocal) {\n    return false;\n  }\n  if (IP_V4_REGEX_OBJECT.test(hostname)) {\n    return isLoopbackV4(hostname);\n  }\n  if (IP_V6_REGEX_OBJECT.test(hostname)) {\n    return isLoopbackV6(hostname);\n  }\n  return isLocalHostname(hostname);\n}\n\n// lib/cookie/cookieJar.ts\nvar defaultSetCookieOptions = {\n  loose: false,\n  sameSiteContext: void 0,\n  ignoreError: false,\n  http: true\n};\nvar defaultGetCookieOptions = {\n  http: true,\n  expire: true,\n  allPaths: false,\n  sameSiteContext: void 0,\n  sort: void 0\n};\nvar SAME_SITE_CONTEXT_VAL_ERR = 'Invalid sameSiteContext option for getCookies(); expected one of \"strict\", \"lax\", or \"none\"';\nfunction getCookieContext(url) {\n  if (url && typeof url === \"object\" && \"hostname\" in url && typeof url.hostname === \"string\" && \"pathname\" in url && typeof url.pathname === \"string\" && \"protocol\" in url && typeof url.protocol === \"string\") {\n    return {\n      hostname: url.hostname,\n      pathname: url.pathname,\n      protocol: url.protocol\n    };\n  } else if (typeof url === \"string\") {\n    try {\n      return new URL(decodeURI(url));\n    } catch {\n      return new URL(url);\n    }\n  } else {\n    throw new ParameterError(\"`url` argument is not a string or URL.\");\n  }\n}\nfunction checkSameSiteContext(value) {\n  const context = String(value).toLowerCase();\n  if (context === \"none\" || context === \"lax\" || context === \"strict\") {\n    return context;\n  } else {\n    return void 0;\n  }\n}\nfunction isSecurePrefixConditionMet(cookie) {\n  const startsWithSecurePrefix = typeof cookie.key === \"string\" && cookie.key.startsWith(\"__Secure-\");\n  return !startsWithSecurePrefix || cookie.secure;\n}\nfunction isHostPrefixConditionMet(cookie) {\n  const startsWithHostPrefix = typeof cookie.key === \"string\" && cookie.key.startsWith(\"__Host-\");\n  return !startsWithHostPrefix || Boolean(\n    cookie.secure && cookie.hostOnly && cookie.path != null && cookie.path === \"/\"\n  );\n}\nfunction getNormalizedPrefixSecurity(prefixSecurity) {\n  const normalizedPrefixSecurity = prefixSecurity.toLowerCase();\n  switch (normalizedPrefixSecurity) {\n    case PrefixSecurityEnum.STRICT:\n    case PrefixSecurityEnum.SILENT:\n    case PrefixSecurityEnum.DISABLED:\n      return normalizedPrefixSecurity;\n    default:\n      return PrefixSecurityEnum.SILENT;\n  }\n}\nvar CookieJar = class _CookieJar {\n  /**\n   * Creates a new `CookieJar` instance.\n   *\n   * @remarks\n   * - If a custom store is not passed to the constructor, an in-memory store ({@link MemoryCookieStore} will be created and used.\n   * - If a boolean value is passed as the `options` parameter, this is equivalent to passing `{ rejectPublicSuffixes: <value> }`\n   *\n   * @param store - a custom {@link Store} implementation (defaults to {@link MemoryCookieStore})\n   * @param options - configures how cookies are processed by the cookie jar\n   */\n  constructor(store, options) {\n    if (typeof options === \"boolean\") {\n      options = { rejectPublicSuffixes: options };\n    }\n    this.rejectPublicSuffixes = options?.rejectPublicSuffixes ?? true;\n    this.enableLooseMode = options?.looseMode ?? false;\n    this.allowSpecialUseDomain = options?.allowSpecialUseDomain ?? true;\n    this.allowSecureOnLocal = options?.allowSecureOnLocal ?? true;\n    this.prefixSecurity = getNormalizedPrefixSecurity(\n      options?.prefixSecurity ?? \"silent\"\n    );\n    this.store = store ?? new MemoryCookieStore();\n  }\n  callSync(fn) {\n    if (!this.store.synchronous) {\n      throw new Error(\n        \"CookieJar store is not synchronous; use async API instead.\"\n      );\n    }\n    let syncErr = null;\n    let syncResult = void 0;\n    try {\n      fn.call(this, (error, result) => {\n        syncErr = error;\n        syncResult = result;\n      });\n    } catch (err) {\n      syncErr = err;\n    }\n    if (syncErr) throw syncErr;\n    return syncResult;\n  }\n  /**\n   * @internal No doc because this is the overload implementation\n   */\n  setCookie(cookie, url, options, callback) {\n    if (typeof options === \"function\") {\n      callback = options;\n      options = void 0;\n    }\n    const promiseCallback = createPromiseCallback(callback);\n    const cb = promiseCallback.callback;\n    let context;\n    try {\n      if (typeof url === \"string\") {\n        validate(\n          isNonEmptyString(url),\n          callback,\n          safeToString(options)\n        );\n      }\n      context = getCookieContext(url);\n      if (typeof url === \"function\") {\n        return promiseCallback.reject(new Error(\"No URL was specified\"));\n      }\n      if (typeof options === \"function\") {\n        options = defaultSetCookieOptions;\n      }\n      validate(typeof cb === \"function\", cb);\n      if (!isNonEmptyString(cookie) && !isObject(cookie) && cookie instanceof String && cookie.length == 0) {\n        return promiseCallback.resolve(void 0);\n      }\n    } catch (err) {\n      return promiseCallback.reject(err);\n    }\n    const host = canonicalDomain(context.hostname) ?? null;\n    const loose = options?.loose || this.enableLooseMode;\n    let sameSiteContext = null;\n    if (options?.sameSiteContext) {\n      sameSiteContext = checkSameSiteContext(options.sameSiteContext);\n      if (!sameSiteContext) {\n        return promiseCallback.reject(new Error(SAME_SITE_CONTEXT_VAL_ERR));\n      }\n    }\n    if (typeof cookie === \"string\" || cookie instanceof String) {\n      const parsedCookie = Cookie.parse(cookie.toString(), { loose });\n      if (!parsedCookie) {\n        const err = new Error(\"Cookie failed to parse\");\n        return options?.ignoreError ? promiseCallback.resolve(void 0) : promiseCallback.reject(err);\n      }\n      cookie = parsedCookie;\n    } else if (!(cookie instanceof Cookie)) {\n      const err = new Error(\n        \"First argument to setCookie must be a Cookie object or string\"\n      );\n      return options?.ignoreError ? promiseCallback.resolve(void 0) : promiseCallback.reject(err);\n    }\n    const now = options?.now || /* @__PURE__ */ new Date();\n    if (this.rejectPublicSuffixes && cookie.domain) {\n      try {\n        const cdomain = cookie.cdomain();\n        const suffix = typeof cdomain === \"string\" ? getPublicSuffix(cdomain, {\n          allowSpecialUseDomain: this.allowSpecialUseDomain,\n          ignoreError: options?.ignoreError\n        }) : null;\n        if (suffix == null && !IP_V6_REGEX_OBJECT.test(cookie.domain)) {\n          const err = new Error(\"Cookie has domain set to a public suffix\");\n          return options?.ignoreError ? promiseCallback.resolve(void 0) : promiseCallback.reject(err);\n        }\n      } catch (err) {\n        return options?.ignoreError ? promiseCallback.resolve(void 0) : (\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n          promiseCallback.reject(err)\n        );\n      }\n    }\n    if (cookie.domain) {\n      if (!domainMatch(host ?? void 0, cookie.cdomain() ?? void 0, false)) {\n        const err = new Error(\n          `Cookie not in this host's domain. Cookie:${cookie.cdomain() ?? \"null\"} Request:${host ?? \"null\"}`\n        );\n        return options?.ignoreError ? promiseCallback.resolve(void 0) : promiseCallback.reject(err);\n      }\n      if (cookie.hostOnly == null) {\n        cookie.hostOnly = false;\n      }\n    } else {\n      cookie.hostOnly = true;\n      cookie.domain = host;\n    }\n    if (!cookie.path || cookie.path[0] !== \"/\") {\n      cookie.path = defaultPath(context.pathname);\n      cookie.pathIsDefault = true;\n    }\n    if (options?.http === false && cookie.httpOnly) {\n      const err = new Error(\"Cookie is HttpOnly and this isn't an HTTP API\");\n      return options.ignoreError ? promiseCallback.resolve(void 0) : promiseCallback.reject(err);\n    }\n    if (cookie.sameSite !== \"none\" && cookie.sameSite !== void 0 && sameSiteContext) {\n      if (sameSiteContext === \"none\") {\n        const err = new Error(\n          \"Cookie is SameSite but this is a cross-origin request\"\n        );\n        return options?.ignoreError ? promiseCallback.resolve(void 0) : promiseCallback.reject(err);\n      }\n    }\n    const ignoreErrorForPrefixSecurity = this.prefixSecurity === PrefixSecurityEnum.SILENT;\n    const prefixSecurityDisabled = this.prefixSecurity === PrefixSecurityEnum.DISABLED;\n    if (!prefixSecurityDisabled) {\n      let errorFound = false;\n      let errorMsg;\n      if (!isSecurePrefixConditionMet(cookie)) {\n        errorFound = true;\n        errorMsg = \"Cookie has __Secure prefix but Secure attribute is not set\";\n      } else if (!isHostPrefixConditionMet(cookie)) {\n        errorFound = true;\n        errorMsg = \"Cookie has __Host prefix but either Secure or HostOnly attribute is not set or Path is not '/'\";\n      }\n      if (errorFound) {\n        return options?.ignoreError || ignoreErrorForPrefixSecurity ? promiseCallback.resolve(void 0) : promiseCallback.reject(new Error(errorMsg));\n      }\n    }\n    const store = this.store;\n    if (!store.updateCookie) {\n      store.updateCookie = async function(_oldCookie, newCookie, cb2) {\n        return this.putCookie(newCookie).then(\n          () => cb2?.(null),\n          (error) => cb2?.(error)\n        );\n      };\n    }\n    const withCookie = function withCookie2(err, oldCookie) {\n      if (err) {\n        cb(err);\n        return;\n      }\n      const next = function(err2) {\n        if (err2) {\n          cb(err2);\n        } else if (typeof cookie === \"string\") {\n          cb(null, void 0);\n        } else {\n          cb(null, cookie);\n        }\n      };\n      if (oldCookie) {\n        if (options && \"http\" in options && options.http === false && oldCookie.httpOnly) {\n          err = new Error(\"old Cookie is HttpOnly and this isn't an HTTP API\");\n          if (options.ignoreError) cb(null, void 0);\n          else cb(err);\n          return;\n        }\n        if (cookie instanceof Cookie) {\n          cookie.creation = oldCookie.creation;\n          cookie.creationIndex = oldCookie.creationIndex;\n          cookie.lastAccessed = now;\n          store.updateCookie(oldCookie, cookie, next);\n        }\n      } else {\n        if (cookie instanceof Cookie) {\n          cookie.creation = cookie.lastAccessed = now;\n          store.putCookie(cookie, next);\n        }\n      }\n    };\n    store.findCookie(cookie.domain, cookie.path, cookie.key, withCookie);\n    return promiseCallback.promise;\n  }\n  /**\n   * Synchronously attempt to set the {@link Cookie} in the {@link CookieJar}.\n   *\n   * <strong>Note:</strong> Only works if the configured {@link Store} is also synchronous.\n   *\n   * @remarks\n   * - If successfully persisted, the {@link Cookie} will have updated\n   *     {@link Cookie.creation}, {@link Cookie.lastAccessed} and {@link Cookie.hostOnly}\n   *     properties.\n   *\n   * - As per the RFC, the {@link Cookie.hostOnly} flag is set if there was no `Domain={value}`\n   *     attribute on the cookie string. The {@link Cookie.domain} property is set to the\n   *     fully-qualified hostname of `currentUrl` in this case. Matching this cookie requires an\n   *     exact hostname match (not a {@link domainMatch} as per usual)\n   *\n   * @param cookie - The cookie object or cookie string to store. A string value will be parsed into a cookie using {@link Cookie.parse}.\n   * @param url - The domain to store the cookie with.\n   * @param options - Configuration settings to use when storing the cookie.\n   * @public\n   */\n  setCookieSync(cookie, url, options) {\n    const setCookieFn = options ? this.setCookie.bind(this, cookie, url, options) : this.setCookie.bind(this, cookie, url);\n    return this.callSync(setCookieFn);\n  }\n  /**\n   * @internal No doc because this is the overload implementation\n   */\n  getCookies(url, options, callback) {\n    if (typeof options === \"function\") {\n      callback = options;\n      options = defaultGetCookieOptions;\n    } else if (options === void 0) {\n      options = defaultGetCookieOptions;\n    }\n    const promiseCallback = createPromiseCallback(callback);\n    const cb = promiseCallback.callback;\n    let context;\n    try {\n      if (typeof url === \"string\") {\n        validate(isNonEmptyString(url), cb, url);\n      }\n      context = getCookieContext(url);\n      validate(\n        isObject(options),\n        cb,\n        safeToString(options)\n      );\n      validate(typeof cb === \"function\", cb);\n    } catch (parameterError) {\n      return promiseCallback.reject(parameterError);\n    }\n    const host = canonicalDomain(context.hostname);\n    const path = context.pathname || \"/\";\n    const potentiallyTrustworthy = isPotentiallyTrustworthy(\n      url,\n      this.allowSecureOnLocal\n    );\n    let sameSiteLevel = 0;\n    if (options.sameSiteContext) {\n      const sameSiteContext = checkSameSiteContext(options.sameSiteContext);\n      if (sameSiteContext == null) {\n        return promiseCallback.reject(new Error(SAME_SITE_CONTEXT_VAL_ERR));\n      }\n      sameSiteLevel = Cookie.sameSiteLevel[sameSiteContext];\n      if (!sameSiteLevel) {\n        return promiseCallback.reject(new Error(SAME_SITE_CONTEXT_VAL_ERR));\n      }\n    }\n    const http = options.http ?? true;\n    const now = Date.now();\n    const expireCheck = options.expire ?? true;\n    const allPaths = options.allPaths ?? false;\n    const store = this.store;\n    function matchingCookie(c) {\n      if (c.hostOnly) {\n        if (c.domain != host) {\n          return false;\n        }\n      } else {\n        if (!domainMatch(host ?? void 0, c.domain ?? void 0, false)) {\n          return false;\n        }\n      }\n      if (!allPaths && typeof c.path === \"string\" && !pathMatch(path, c.path)) {\n        return false;\n      }\n      if (c.secure && !potentiallyTrustworthy) {\n        return false;\n      }\n      if (c.httpOnly && !http) {\n        return false;\n      }\n      if (sameSiteLevel) {\n        let cookieLevel;\n        if (c.sameSite === \"lax\") {\n          cookieLevel = Cookie.sameSiteLevel.lax;\n        } else if (c.sameSite === \"strict\") {\n          cookieLevel = Cookie.sameSiteLevel.strict;\n        } else {\n          cookieLevel = Cookie.sameSiteLevel.none;\n        }\n        if (cookieLevel > sameSiteLevel) {\n          return false;\n        }\n      }\n      const expiryTime = c.expiryTime();\n      if (expireCheck && expiryTime != void 0 && expiryTime <= now) {\n        store.removeCookie(c.domain, c.path, c.key, () => {\n        });\n        return false;\n      }\n      return true;\n    }\n    store.findCookies(\n      host,\n      allPaths ? null : path,\n      this.allowSpecialUseDomain,\n      (err, cookies) => {\n        if (err) {\n          cb(err);\n          return;\n        }\n        if (cookies == null) {\n          cb(null, []);\n          return;\n        }\n        cookies = cookies.filter(matchingCookie);\n        if (\"sort\" in options && options.sort !== false) {\n          cookies = cookies.sort(cookieCompare);\n        }\n        const now2 = /* @__PURE__ */ new Date();\n        for (const cookie of cookies) {\n          cookie.lastAccessed = now2;\n        }\n        cb(null, cookies);\n      }\n    );\n    return promiseCallback.promise;\n  }\n  /**\n   * Synchronously retrieve the list of cookies that can be sent in a Cookie header for the\n   * current URL.\n   *\n   * <strong>Note</strong>: Only works if the configured Store is also synchronous.\n   *\n   * @remarks\n   * - The array of cookies returned will be sorted according to {@link cookieCompare}.\n   *\n   * - The {@link Cookie.lastAccessed} property will be updated on all returned cookies.\n   *\n   * @param url - The domain to store the cookie with.\n   * @param options - Configuration settings to use when retrieving the cookies.\n   */\n  getCookiesSync(url, options) {\n    return this.callSync(this.getCookies.bind(this, url, options)) ?? [];\n  }\n  /**\n   * @internal No doc because this is the overload implementation\n   */\n  getCookieString(url, options, callback) {\n    if (typeof options === \"function\") {\n      callback = options;\n      options = void 0;\n    }\n    const promiseCallback = createPromiseCallback(callback);\n    const next = function(err, cookies) {\n      if (err) {\n        promiseCallback.callback(err);\n      } else {\n        promiseCallback.callback(\n          null,\n          cookies?.sort(cookieCompare).map((c) => c.cookieString()).join(\"; \")\n        );\n      }\n    };\n    this.getCookies(url, options, next);\n    return promiseCallback.promise;\n  }\n  /**\n   * Synchronous version of `.getCookieString()`. Accepts the same options as `.getCookies()` but returns a string suitable for a\n   * `Cookie` header rather than an Array.\n   *\n   * <strong>Note</strong>: Only works if the configured Store is also synchronous.\n   *\n   * @param url - The domain to store the cookie with.\n   * @param options - Configuration settings to use when retrieving the cookies.\n   */\n  getCookieStringSync(url, options) {\n    return this.callSync(\n      options ? this.getCookieString.bind(this, url, options) : this.getCookieString.bind(this, url)\n    ) ?? \"\";\n  }\n  /**\n   * @internal No doc because this is the overload implementation\n   */\n  getSetCookieStrings(url, options, callback) {\n    if (typeof options === \"function\") {\n      callback = options;\n      options = void 0;\n    }\n    const promiseCallback = createPromiseCallback(\n      callback\n    );\n    const next = function(err, cookies) {\n      if (err) {\n        promiseCallback.callback(err);\n      } else {\n        promiseCallback.callback(\n          null,\n          cookies?.map((c) => {\n            return c.toString();\n          })\n        );\n      }\n    };\n    this.getCookies(url, options, next);\n    return promiseCallback.promise;\n  }\n  /**\n   * Synchronous version of `.getSetCookieStrings()`. Returns an array of strings suitable for `Set-Cookie` headers.\n   * Accepts the same options as `.getCookies()`.\n   *\n   * <strong>Note</strong>: Only works if the configured Store is also synchronous.\n   *\n   * @param url - The domain to store the cookie with.\n   * @param options - Configuration settings to use when retrieving the cookies.\n   */\n  getSetCookieStringsSync(url, options = {}) {\n    return this.callSync(this.getSetCookieStrings.bind(this, url, options)) ?? [];\n  }\n  /**\n   * @internal No doc because this is the overload implementation\n   */\n  serialize(callback) {\n    const promiseCallback = createPromiseCallback(callback);\n    let type = this.store.constructor.name;\n    if (isObject(type)) {\n      type = null;\n    }\n    const serialized = {\n      // The version of tough-cookie that serialized this jar. Generally a good\n      // practice since future versions can make data import decisions based on\n      // known past behavior. When/if this matters, use `semver`.\n      version: `tough-cookie@${version}`,\n      // add the store type, to make humans happy:\n      storeType: type,\n      // CookieJar configuration:\n      rejectPublicSuffixes: this.rejectPublicSuffixes,\n      enableLooseMode: this.enableLooseMode,\n      allowSpecialUseDomain: this.allowSpecialUseDomain,\n      prefixSecurity: getNormalizedPrefixSecurity(this.prefixSecurity),\n      // this gets filled from getAllCookies:\n      cookies: []\n    };\n    if (typeof this.store.getAllCookies !== \"function\") {\n      return promiseCallback.reject(\n        new Error(\n          \"store does not support getAllCookies and cannot be serialized\"\n        )\n      );\n    }\n    this.store.getAllCookies((err, cookies) => {\n      if (err) {\n        promiseCallback.callback(err);\n        return;\n      }\n      if (cookies == null) {\n        promiseCallback.callback(null, serialized);\n        return;\n      }\n      serialized.cookies = cookies.map((cookie) => {\n        const serializedCookie = cookie.toJSON();\n        delete serializedCookie.creationIndex;\n        return serializedCookie;\n      });\n      promiseCallback.callback(null, serialized);\n    });\n    return promiseCallback.promise;\n  }\n  /**\n   * Serialize the CookieJar if the underlying store supports `.getAllCookies`.\n   *\n   * <strong>Note</strong>: Only works if the configured Store is also synchronous.\n   */\n  serializeSync() {\n    return this.callSync((callback) => {\n      this.serialize(callback);\n    });\n  }\n  /**\n   * Alias of {@link CookieJar.serializeSync}. Allows the cookie to be serialized\n   * with `JSON.stringify(cookieJar)`.\n   */\n  toJSON() {\n    return this.serializeSync();\n  }\n  /**\n   * Use the class method CookieJar.deserialize instead of calling this directly\n   * @internal\n   */\n  _importCookies(serialized, callback) {\n    let cookies = void 0;\n    if (serialized && typeof serialized === \"object\" && inOperator(\"cookies\", serialized) && Array.isArray(serialized.cookies)) {\n      cookies = serialized.cookies;\n    }\n    if (!cookies) {\n      callback(new Error(\"serialized jar has no cookies array\"), void 0);\n      return;\n    }\n    cookies = cookies.slice();\n    const putNext = (err) => {\n      if (err) {\n        callback(err, void 0);\n        return;\n      }\n      if (Array.isArray(cookies)) {\n        if (!cookies.length) {\n          callback(err, this);\n          return;\n        }\n        let cookie;\n        try {\n          cookie = Cookie.fromJSON(cookies.shift());\n        } catch (e) {\n          callback(e instanceof Error ? e : new Error(), void 0);\n          return;\n        }\n        if (cookie === void 0) {\n          putNext(null);\n          return;\n        }\n        this.store.putCookie(cookie, putNext);\n      }\n    };\n    putNext(null);\n  }\n  /**\n   * @internal\n   */\n  _importCookiesSync(serialized) {\n    this.callSync(this._importCookies.bind(this, serialized));\n  }\n  /**\n   * @internal No doc because this is the overload implementation\n   */\n  clone(newStore, callback) {\n    if (typeof newStore === \"function\") {\n      callback = newStore;\n      newStore = void 0;\n    }\n    const promiseCallback = createPromiseCallback(callback);\n    const cb = promiseCallback.callback;\n    this.serialize((err, serialized) => {\n      if (err) {\n        return promiseCallback.reject(err);\n      }\n      return _CookieJar.deserialize(serialized ?? \"\", newStore, cb);\n    });\n    return promiseCallback.promise;\n  }\n  /**\n   * @internal\n   */\n  _cloneSync(newStore) {\n    const cloneFn = newStore && typeof newStore !== \"function\" ? this.clone.bind(this, newStore) : this.clone.bind(this);\n    return this.callSync((callback) => {\n      cloneFn(callback);\n    });\n  }\n  /**\n   * Produces a deep clone of this CookieJar. Modifications to the original do\n   * not affect the clone, and vice versa.\n   *\n   * <strong>Note</strong>: Only works if both the configured Store and destination\n   * Store are synchronous.\n   *\n   * @remarks\n   * - When no {@link Store} is provided, a new {@link MemoryCookieStore} will be used.\n   *\n   * - Transferring between store types is supported so long as the source\n   *     implements `.getAllCookies()` and the destination implements `.putCookie()`.\n   *\n   * @param newStore - The target {@link Store} to clone cookies into.\n   */\n  cloneSync(newStore) {\n    if (!newStore) {\n      return this._cloneSync();\n    }\n    if (!newStore.synchronous) {\n      throw new Error(\n        \"CookieJar clone destination store is not synchronous; use async API instead.\"\n      );\n    }\n    return this._cloneSync(newStore);\n  }\n  /**\n   * @internal No doc because this is the overload implementation\n   */\n  removeAllCookies(callback) {\n    const promiseCallback = createPromiseCallback(callback);\n    const cb = promiseCallback.callback;\n    const store = this.store;\n    if (typeof store.removeAllCookies === \"function\" && store.removeAllCookies !== Store.prototype.removeAllCookies) {\n      store.removeAllCookies(cb);\n      return promiseCallback.promise;\n    }\n    store.getAllCookies((err, cookies) => {\n      if (err) {\n        cb(err);\n        return;\n      }\n      if (!cookies) {\n        cookies = [];\n      }\n      if (cookies.length === 0) {\n        cb(null, void 0);\n        return;\n      }\n      let completedCount = 0;\n      const removeErrors = [];\n      const removeCookieCb = function removeCookieCb2(removeErr) {\n        if (removeErr) {\n          removeErrors.push(removeErr);\n        }\n        completedCount++;\n        if (completedCount === cookies.length) {\n          if (removeErrors[0]) cb(removeErrors[0]);\n          else cb(null, void 0);\n          return;\n        }\n      };\n      cookies.forEach((cookie) => {\n        store.removeCookie(\n          cookie.domain,\n          cookie.path,\n          cookie.key,\n          removeCookieCb\n        );\n      });\n    });\n    return promiseCallback.promise;\n  }\n  /**\n   * Removes all cookies from the CookieJar.\n   *\n   * <strong>Note</strong>: Only works if the configured Store is also synchronous.\n   *\n   * @remarks\n   * - This is a new backwards-compatible feature of tough-cookie version 2.5,\n   *     so not all Stores will implement it efficiently. For Stores that do not\n   *     implement `removeAllCookies`, the fallback is to call `removeCookie` after\n   *     `getAllCookies`.\n   *\n   * - If `getAllCookies` fails or isn't implemented in the Store, an error is returned.\n   *\n   * - If one or more of the `removeCookie` calls fail, only the first error is returned.\n   */\n  removeAllCookiesSync() {\n    this.callSync((callback) => {\n      this.removeAllCookies(callback);\n    });\n  }\n  /**\n   * @internal No doc because this is the overload implementation\n   */\n  static deserialize(strOrObj, store, callback) {\n    if (typeof store === \"function\") {\n      callback = store;\n      store = void 0;\n    }\n    const promiseCallback = createPromiseCallback(callback);\n    let serialized;\n    if (typeof strOrObj === \"string\") {\n      try {\n        serialized = JSON.parse(strOrObj);\n      } catch (e) {\n        return promiseCallback.reject(e instanceof Error ? e : new Error());\n      }\n    } else {\n      serialized = strOrObj;\n    }\n    const readSerializedProperty = (property) => {\n      return serialized && typeof serialized === \"object\" && inOperator(property, serialized) ? serialized[property] : void 0;\n    };\n    const readSerializedBoolean = (property) => {\n      const value = readSerializedProperty(property);\n      return typeof value === \"boolean\" ? value : void 0;\n    };\n    const readSerializedString = (property) => {\n      const value = readSerializedProperty(property);\n      return typeof value === \"string\" ? value : void 0;\n    };\n    const jar = new _CookieJar(store, {\n      rejectPublicSuffixes: readSerializedBoolean(\"rejectPublicSuffixes\"),\n      looseMode: readSerializedBoolean(\"enableLooseMode\"),\n      allowSpecialUseDomain: readSerializedBoolean(\"allowSpecialUseDomain\"),\n      prefixSecurity: getNormalizedPrefixSecurity(\n        readSerializedString(\"prefixSecurity\") ?? \"silent\"\n      )\n    });\n    jar._importCookies(serialized, (err) => {\n      if (err) {\n        promiseCallback.callback(err);\n        return;\n      }\n      promiseCallback.callback(null, jar);\n    });\n    return promiseCallback.promise;\n  }\n  /**\n   * A new CookieJar is created and the serialized {@link Cookie} values are added to\n   * the underlying store. Each {@link Cookie} is added via `store.putCookie(...)` in\n   * the order in which they appear in the serialization.\n   *\n   * <strong>Note</strong>: Only works if the configured Store is also synchronous.\n   *\n   * @remarks\n   * - When no {@link Store} is provided, a new {@link MemoryCookieStore} will be used.\n   *\n   * - As a convenience, if `strOrObj` is a string, it is passed through `JSON.parse` first.\n   *\n   * @param strOrObj - A JSON string or object representing the deserialized cookies.\n   * @param store - The underlying store to persist the deserialized cookies into.\n   */\n  static deserializeSync(strOrObj, store) {\n    const serialized = typeof strOrObj === \"string\" ? JSON.parse(strOrObj) : strOrObj;\n    const readSerializedProperty = (property) => {\n      return serialized && typeof serialized === \"object\" && inOperator(property, serialized) ? serialized[property] : void 0;\n    };\n    const readSerializedBoolean = (property) => {\n      const value = readSerializedProperty(property);\n      return typeof value === \"boolean\" ? value : void 0;\n    };\n    const readSerializedString = (property) => {\n      const value = readSerializedProperty(property);\n      return typeof value === \"string\" ? value : void 0;\n    };\n    const jar = new _CookieJar(store, {\n      rejectPublicSuffixes: readSerializedBoolean(\"rejectPublicSuffixes\"),\n      looseMode: readSerializedBoolean(\"enableLooseMode\"),\n      allowSpecialUseDomain: readSerializedBoolean(\"allowSpecialUseDomain\"),\n      prefixSecurity: getNormalizedPrefixSecurity(\n        readSerializedString(\"prefixSecurity\") ?? \"silent\"\n      )\n    });\n    if (!jar.store.synchronous) {\n      throw new Error(\n        \"CookieJar store is not synchronous; use async API instead.\"\n      );\n    }\n    jar._importCookiesSync(serialized);\n    return jar;\n  }\n  /**\n   * Alias of {@link CookieJar.deserializeSync}.\n   *\n   * @remarks\n   * - When no {@link Store} is provided, a new {@link MemoryCookieStore} will be used.\n   *\n   * - As a convenience, if `strOrObj` is a string, it is passed through `JSON.parse` first.\n   *\n   * @param jsonString - A JSON string or object representing the deserialized cookies.\n   * @param store - The underlying store to persist the deserialized cookies into.\n   */\n  static fromJSON(jsonString, store) {\n    return _CookieJar.deserializeSync(jsonString, store);\n  }\n};\n\n// lib/cookie/permutePath.ts\nfunction permutePath(path) {\n  if (path === \"/\") {\n    return [\"/\"];\n  }\n  const permutations = [path];\n  while (path.length > 1) {\n    const lindex = path.lastIndexOf(\"/\");\n    if (lindex === 0) {\n      break;\n    }\n    path = path.slice(0, lindex);\n    permutations.push(path);\n  }\n  permutations.push(\"/\");\n  return permutations;\n}\n\n// lib/cookie/index.ts\nfunction parse2(str, options) {\n  return Cookie.parse(str, options);\n}\nfunction fromJSON2(str) {\n  return Cookie.fromJSON(str);\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n/*!\n * Copyright (c) 2015-2020, Salesforce.com, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. Neither the name of Salesforce.com nor the names of its contributors may\n * be used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n//# sourceMappingURL=index.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdG91Z2gtY29va2llL2Rpc3QvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7O0FBRW5GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsMkRBQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0IsR0FBRyxlQUFlO0FBQ3BELE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGVBQWUsK0VBQStFLHlEQUF5RDtBQUM1TTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLLEdBQUcsSUFBSTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix3QkFBd0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix3QkFBd0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0dBQStHLEVBQUUscUJBQXFCLElBQUksR0FBRyxFQUFFLFdBQVcsSUFBSSxlQUFlLElBQUksR0FBRyxFQUFFLG9GQUFvRixFQUFFLFVBQVUsSUFBSSxlQUFlLElBQUksR0FBRyxFQUFFLHFGQUFxRixFQUFFLGFBQWEsSUFBSSxFQUFFLElBQUksZUFBZSxJQUFJLEdBQUcsRUFBRSxlQUFlLElBQUksRUFBRSxJQUFJLGtGQUFrRixFQUFFLGFBQWEsSUFBSSxFQUFFLElBQUksZUFBZSxJQUFJLEdBQUcsRUFBRSxlQUFlLElBQUksRUFBRSxJQUFJLGtGQUFrRixFQUFFLGFBQWEsSUFBSSxFQUFFLElBQUksZUFBZSxJQUFJLEdBQUcsRUFBRSxlQUFlLElBQUksRUFBRSxJQUFJLGtGQUFrRixFQUFFLGFBQWEsSUFBSSxFQUFFLElBQUksZUFBZSxJQUFJLEdBQUcsRUFBRSxlQUFlLElBQUksRUFBRSxJQUFJLGtGQUFrRixFQUFFLGFBQWEsSUFBSSxFQUFFLElBQUksdUJBQXVCLElBQUksRUFBRSxJQUFJLGtGQUFrRixFQUFFLGFBQWEsSUFBSSxFQUFFLElBQUk7QUFDNXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFD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Q0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFFBQVE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxlQUFlLDhCQUE4QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWEsb0JBQW9CLHlCQUF5QjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxhQUFhO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxjQUFjO0FBQ2xFLGlDQUFpQyxjQUFjO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYSxvQkFBb0IseUJBQXlCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdDQUFnQztBQUMvQztBQUNBO0FBQ0EsZ0JBQWdCLGFBQWEsb0JBQW9CLHlCQUF5QjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLENBb0JMO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLCtCQUErQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9uZXpvYmVuYXJkaS9BSV9zdHVmZi9PbmJvYXJkaW5nUG9ydGFsL25vZGVfbW9kdWxlcy90b3VnaC1jb29raWUvZGlzdC9pbmRleC5janMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xuXG4vLyBsaWIvY29va2llL2luZGV4LnRzXG52YXIgaW5kZXhfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoaW5kZXhfZXhwb3J0cywge1xuICBDb29raWU6ICgpID0+IENvb2tpZSxcbiAgQ29va2llSmFyOiAoKSA9PiBDb29raWVKYXIsXG4gIE1lbW9yeUNvb2tpZVN0b3JlOiAoKSA9PiBNZW1vcnlDb29raWVTdG9yZSxcbiAgUGFyYW1ldGVyRXJyb3I6ICgpID0+IFBhcmFtZXRlckVycm9yLFxuICBQcmVmaXhTZWN1cml0eUVudW06ICgpID0+IFByZWZpeFNlY3VyaXR5RW51bSxcbiAgU3RvcmU6ICgpID0+IFN0b3JlLFxuICBjYW5vbmljYWxEb21haW46ICgpID0+IGNhbm9uaWNhbERvbWFpbixcbiAgY29va2llQ29tcGFyZTogKCkgPT4gY29va2llQ29tcGFyZSxcbiAgZGVmYXVsdFBhdGg6ICgpID0+IGRlZmF1bHRQYXRoLFxuICBkb21haW5NYXRjaDogKCkgPT4gZG9tYWluTWF0Y2gsXG4gIGZvcm1hdERhdGU6ICgpID0+IGZvcm1hdERhdGUsXG4gIGZyb21KU09OOiAoKSA9PiBmcm9tSlNPTjIsXG4gIGdldFB1YmxpY1N1ZmZpeDogKCkgPT4gZ2V0UHVibGljU3VmZml4LFxuICBwYXJzZTogKCkgPT4gcGFyc2UyLFxuICBwYXJzZURhdGU6ICgpID0+IHBhcnNlRGF0ZSxcbiAgcGF0aE1hdGNoOiAoKSA9PiBwYXRoTWF0Y2gsXG4gIHBlcm11dGVEb21haW46ICgpID0+IHBlcm11dGVEb21haW4sXG4gIHBlcm11dGVQYXRoOiAoKSA9PiBwZXJtdXRlUGF0aCxcbiAgdmVyc2lvbjogKCkgPT4gdmVyc2lvblxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhpbmRleF9leHBvcnRzKTtcblxuLy8gbGliL3BhdGhNYXRjaC50c1xuZnVuY3Rpb24gcGF0aE1hdGNoKHJlcVBhdGgsIGNvb2tpZVBhdGgpIHtcbiAgaWYgKGNvb2tpZVBhdGggPT09IHJlcVBhdGgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBpZHggPSByZXFQYXRoLmluZGV4T2YoY29va2llUGF0aCk7XG4gIGlmIChpZHggPT09IDApIHtcbiAgICBpZiAoY29va2llUGF0aFtjb29raWVQYXRoLmxlbmd0aCAtIDFdID09PSBcIi9cIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChyZXFQYXRoLnN0YXJ0c1dpdGgoY29va2llUGF0aCkgJiYgcmVxUGF0aFtjb29raWVQYXRoLmxlbmd0aF0gPT09IFwiL1wiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBsaWIvZ2V0UHVibGljU3VmZml4LnRzXG52YXIgaW1wb3J0X3RsZHRzID0gcmVxdWlyZShcInRsZHRzXCIpO1xudmFyIFNQRUNJQUxfVVNFX0RPTUFJTlMgPSBbXCJsb2NhbFwiLCBcImV4YW1wbGVcIiwgXCJpbnZhbGlkXCIsIFwibG9jYWxob3N0XCIsIFwidGVzdFwiXTtcbnZhciBTUEVDSUFMX1RSRUFUTUVOVF9ET01BSU5TID0gW1wibG9jYWxob3N0XCIsIFwiaW52YWxpZFwiXTtcbnZhciBkZWZhdWx0R2V0UHVibGljU3VmZml4T3B0aW9ucyA9IHtcbiAgYWxsb3dTcGVjaWFsVXNlRG9tYWluOiBmYWxzZSxcbiAgaWdub3JlRXJyb3I6IGZhbHNlXG59O1xuZnVuY3Rpb24gZ2V0UHVibGljU3VmZml4KGRvbWFpbiwgb3B0aW9ucyA9IHt9KSB7XG4gIG9wdGlvbnMgPSB7IC4uLmRlZmF1bHRHZXRQdWJsaWNTdWZmaXhPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gIGNvbnN0IGRvbWFpblBhcnRzID0gZG9tYWluLnNwbGl0KFwiLlwiKTtcbiAgY29uc3QgdG9wTGV2ZWxEb21haW4gPSBkb21haW5QYXJ0c1tkb21haW5QYXJ0cy5sZW5ndGggLSAxXTtcbiAgY29uc3QgYWxsb3dTcGVjaWFsVXNlRG9tYWluID0gISFvcHRpb25zLmFsbG93U3BlY2lhbFVzZURvbWFpbjtcbiAgY29uc3QgaWdub3JlRXJyb3IgPSAhIW9wdGlvbnMuaWdub3JlRXJyb3I7XG4gIGlmIChhbGxvd1NwZWNpYWxVc2VEb21haW4gJiYgdG9wTGV2ZWxEb21haW4gIT09IHZvaWQgMCAmJiBTUEVDSUFMX1VTRV9ET01BSU5TLmluY2x1ZGVzKHRvcExldmVsRG9tYWluKSkge1xuICAgIGlmIChkb21haW5QYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICBjb25zdCBzZWNvbmRMZXZlbERvbWFpbiA9IGRvbWFpblBhcnRzW2RvbWFpblBhcnRzLmxlbmd0aCAtIDJdO1xuICAgICAgcmV0dXJuIGAke3NlY29uZExldmVsRG9tYWlufS4ke3RvcExldmVsRG9tYWlufWA7XG4gICAgfSBlbHNlIGlmIChTUEVDSUFMX1RSRUFUTUVOVF9ET01BSU5TLmluY2x1ZGVzKHRvcExldmVsRG9tYWluKSkge1xuICAgICAgcmV0dXJuIHRvcExldmVsRG9tYWluO1xuICAgIH1cbiAgfVxuICBpZiAoIWlnbm9yZUVycm9yICYmIHRvcExldmVsRG9tYWluICE9PSB2b2lkIDAgJiYgU1BFQ0lBTF9VU0VfRE9NQUlOUy5pbmNsdWRlcyh0b3BMZXZlbERvbWFpbikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQ29va2llIGhhcyBkb21haW4gc2V0IHRvIHRoZSBwdWJsaWMgc3VmZml4IFwiJHt0b3BMZXZlbERvbWFpbn1cIiB3aGljaCBpcyBhIHNwZWNpYWwgdXNlIGRvbWFpbi4gVG8gYWxsb3cgdGhpcywgY29uZmlndXJlIHlvdXIgQ29va2llSmFyIHdpdGgge2FsbG93U3BlY2lhbFVzZURvbWFpbjogdHJ1ZSwgcmVqZWN0UHVibGljU3VmZml4ZXM6IGZhbHNlfS5gXG4gICAgKTtcbiAgfVxuICBjb25zdCBwdWJsaWNTdWZmaXggPSAoMCwgaW1wb3J0X3RsZHRzLmdldERvbWFpbikoZG9tYWluLCB7XG4gICAgYWxsb3dJY2FubkRvbWFpbnM6IHRydWUsXG4gICAgYWxsb3dQcml2YXRlRG9tYWluczogdHJ1ZVxuICB9KTtcbiAgaWYgKHB1YmxpY1N1ZmZpeCkgcmV0dXJuIHB1YmxpY1N1ZmZpeDtcbn1cblxuLy8gbGliL3Blcm11dGVEb21haW4udHNcbmZ1bmN0aW9uIHBlcm11dGVEb21haW4oZG9tYWluLCBhbGxvd1NwZWNpYWxVc2VEb21haW4pIHtcbiAgY29uc3QgcHViU3VmID0gZ2V0UHVibGljU3VmZml4KGRvbWFpbiwge1xuICAgIGFsbG93U3BlY2lhbFVzZURvbWFpblxuICB9KTtcbiAgaWYgKCFwdWJTdWYpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGlmIChwdWJTdWYgPT0gZG9tYWluKSB7XG4gICAgcmV0dXJuIFtkb21haW5dO1xuICB9XG4gIGlmIChkb21haW4uc2xpY2UoLTEpID09IFwiLlwiKSB7XG4gICAgZG9tYWluID0gZG9tYWluLnNsaWNlKDAsIC0xKTtcbiAgfVxuICBjb25zdCBwcmVmaXggPSBkb21haW4uc2xpY2UoMCwgLShwdWJTdWYubGVuZ3RoICsgMSkpO1xuICBjb25zdCBwYXJ0cyA9IHByZWZpeC5zcGxpdChcIi5cIikucmV2ZXJzZSgpO1xuICBsZXQgY3VyID0gcHViU3VmO1xuICBjb25zdCBwZXJtdXRhdGlvbnMgPSBbY3VyXTtcbiAgd2hpbGUgKHBhcnRzLmxlbmd0aCkge1xuICAgIGNvbnN0IHBhcnQgPSBwYXJ0cy5zaGlmdCgpO1xuICAgIGN1ciA9IGAke3BhcnR9LiR7Y3VyfWA7XG4gICAgcGVybXV0YXRpb25zLnB1c2goY3VyKTtcbiAgfVxuICByZXR1cm4gcGVybXV0YXRpb25zO1xufVxuXG4vLyBsaWIvc3RvcmUudHNcbnZhciBTdG9yZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zeW5jaHJvbm91cyA9IGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWwgTm8gZG9jIGJlY2F1c2UgdGhpcyBpcyBhbiBvdmVybG9hZCB0aGF0IHN1cHBvcnRzIHRoZSBpbXBsZW1lbnRhdGlvblxuICAgKi9cbiAgZmluZENvb2tpZShfZG9tYWluLCBfcGF0aCwgX2tleSwgX2NhbGxiYWNrKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZmluZENvb2tpZSBpcyBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbCBObyBkb2MgYmVjYXVzZSB0aGlzIGlzIGFuIG92ZXJsb2FkIHRoYXQgc3VwcG9ydHMgdGhlIGltcGxlbWVudGF0aW9uXG4gICAqL1xuICBmaW5kQ29va2llcyhfZG9tYWluLCBfcGF0aCwgX2FsbG93U3BlY2lhbFVzZURvbWFpbiA9IGZhbHNlLCBfY2FsbGJhY2spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJmaW5kQ29va2llcyBpcyBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbCBObyBkb2MgYmVjYXVzZSB0aGlzIGlzIGFuIG92ZXJsb2FkIHRoYXQgc3VwcG9ydHMgdGhlIGltcGxlbWVudGF0aW9uXG4gICAqL1xuICBwdXRDb29raWUoX2Nvb2tpZSwgX2NhbGxiYWNrKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwicHV0Q29va2llIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsIE5vIGRvYyBiZWNhdXNlIHRoaXMgaXMgYW4gb3ZlcmxvYWQgdGhhdCBzdXBwb3J0cyB0aGUgaW1wbGVtZW50YXRpb25cbiAgICovXG4gIHVwZGF0ZUNvb2tpZShfb2xkQ29va2llLCBfbmV3Q29va2llLCBfY2FsbGJhY2spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1cGRhdGVDb29raWUgaXMgbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWwgTm8gZG9jIGJlY2F1c2UgdGhpcyBpcyBhbiBvdmVybG9hZCB0aGF0IHN1cHBvcnRzIHRoZSBpbXBsZW1lbnRhdGlvblxuICAgKi9cbiAgcmVtb3ZlQ29va2llKF9kb21haW4sIF9wYXRoLCBfa2V5LCBfY2FsbGJhY2spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZW1vdmVDb29raWUgaXMgbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWwgTm8gZG9jIGJlY2F1c2UgdGhpcyBpcyBhbiBvdmVybG9hZCB0aGF0IHN1cHBvcnRzIHRoZSBpbXBsZW1lbnRhdGlvblxuICAgKi9cbiAgcmVtb3ZlQ29va2llcyhfZG9tYWluLCBfcGF0aCwgX2NhbGxiYWNrKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwicmVtb3ZlQ29va2llcyBpcyBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbCBObyBkb2MgYmVjYXVzZSB0aGlzIGlzIGFuIG92ZXJsb2FkIHRoYXQgc3VwcG9ydHMgdGhlIGltcGxlbWVudGF0aW9uXG4gICAqL1xuICByZW1vdmVBbGxDb29raWVzKF9jYWxsYmFjaykge1xuICAgIHRocm93IG5ldyBFcnJvcihcInJlbW92ZUFsbENvb2tpZXMgaXMgbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWwgTm8gZG9jIGJlY2F1c2UgdGhpcyBpcyBhbiBvdmVybG9hZCB0aGF0IHN1cHBvcnRzIHRoZSBpbXBsZW1lbnRhdGlvblxuICAgKi9cbiAgZ2V0QWxsQ29va2llcyhfY2FsbGJhY2spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcImdldEFsbENvb2tpZXMgaXMgbm90IGltcGxlbWVudGVkICh0aGVyZWZvcmUgamFyIGNhbm5vdCBiZSBzZXJpYWxpemVkKVwiXG4gICAgKTtcbiAgfVxufTtcblxuLy8gbGliL3V0aWxzLnRzXG52YXIgb2JqZWN0VG9TdHJpbmcgPSAob2JqKSA9PiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTtcbnZhciBzYWZlQXJyYXlUb1N0cmluZyA9IChhcnIsIHNlZW5BcnJheXMpID0+IHtcbiAgaWYgKHR5cGVvZiBhcnIuam9pbiAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gb2JqZWN0VG9TdHJpbmcoYXJyKTtcbiAgc2VlbkFycmF5cy5hZGQoYXJyKTtcbiAgY29uc3QgbWFwcGVkID0gYXJyLm1hcChcbiAgICAodmFsKSA9PiB2YWwgPT09IG51bGwgfHwgdmFsID09PSB2b2lkIDAgfHwgc2VlbkFycmF5cy5oYXModmFsKSA/IFwiXCIgOiBzYWZlVG9TdHJpbmdJbXBsKHZhbCwgc2VlbkFycmF5cylcbiAgKTtcbiAgcmV0dXJuIG1hcHBlZC5qb2luKCk7XG59O1xudmFyIHNhZmVUb1N0cmluZ0ltcGwgPSAodmFsLCBzZWVuQXJyYXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCkpID0+IHtcbiAgaWYgKHR5cGVvZiB2YWwgIT09IFwib2JqZWN0XCIgfHwgdmFsID09PSBudWxsKSB7XG4gICAgcmV0dXJuIFN0cmluZyh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwudG9TdHJpbmcgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbCkgPyAoXG4gICAgICAvLyBBcnJheXMgaGF2ZSBhIHdlaXJkIGN1c3RvbSB0b1N0cmluZyB0aGF0IHdlIG5lZWQgdG8gcmVwbGljYXRlXG4gICAgICBzYWZlQXJyYXlUb1N0cmluZyh2YWwsIHNlZW5BcnJheXMpXG4gICAgKSA6IChcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tYmFzZS10by1zdHJpbmdcbiAgICAgIFN0cmluZyh2YWwpXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqZWN0VG9TdHJpbmcodmFsKTtcbiAgfVxufTtcbnZhciBzYWZlVG9TdHJpbmcgPSAodmFsKSA9PiBzYWZlVG9TdHJpbmdJbXBsKHZhbCk7XG5mdW5jdGlvbiBjcmVhdGVQcm9taXNlQ2FsbGJhY2soY2IpIHtcbiAgbGV0IGNhbGxiYWNrO1xuICBsZXQgcmVzb2x2ZTtcbiAgbGV0IHJlamVjdDtcbiAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChfcmVzb2x2ZSwgX3JlamVjdCkgPT4ge1xuICAgIHJlc29sdmUgPSBfcmVzb2x2ZTtcbiAgICByZWplY3QgPSBfcmVqZWN0O1xuICB9KTtcbiAgaWYgKHR5cGVvZiBjYiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY2FsbGJhY2sgPSAoZXJyLCByZXN1bHQpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChlcnIpIGNiKGVycik7XG4gICAgICAgIGVsc2UgY2IobnVsbCwgcmVzdWx0KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUgaW5zdGFuY2VvZiBFcnJvciA/IGUgOiBuZXcgRXJyb3IoKSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBjYWxsYmFjayA9IChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGVycikgcmVqZWN0KGVycik7XG4gICAgICAgIGVsc2UgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSBpbnN0YW5jZW9mIEVycm9yID8gZSA6IG5ldyBFcnJvcigpKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgcHJvbWlzZSxcbiAgICBjYWxsYmFjayxcbiAgICByZXNvbHZlOiAodmFsdWUpID0+IHtcbiAgICAgIGNhbGxiYWNrKG51bGwsIHZhbHVlKTtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH0sXG4gICAgcmVqZWN0OiAoZXJyb3IpID0+IHtcbiAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGluT3BlcmF0b3Ioaywgbykge1xuICByZXR1cm4gayBpbiBvO1xufVxuXG4vLyBsaWIvbWVtc3RvcmUudHNcbnZhciBNZW1vcnlDb29raWVTdG9yZSA9IGNsYXNzIGV4dGVuZHMgU3RvcmUge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHtAbGluayBNZW1vcnlDb29raWVTdG9yZX0uXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc3luY2hyb25vdXMgPSB0cnVlO1xuICAgIHRoaXMuaWR4ID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbCBObyBkb2MgYmVjYXVzZSB0aGlzIGlzIGFuIG92ZXJsb2FkIHRoYXQgc3VwcG9ydHMgdGhlIGltcGxlbWVudGF0aW9uXG4gICAqL1xuICBmaW5kQ29va2llKGRvbWFpbiwgcGF0aCwga2V5LCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHByb21pc2VDYWxsYmFjayA9IGNyZWF0ZVByb21pc2VDYWxsYmFjayhjYWxsYmFjayk7XG4gICAgaWYgKGRvbWFpbiA9PSBudWxsIHx8IHBhdGggPT0gbnVsbCB8fCBrZXkgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHByb21pc2VDYWxsYmFjay5yZXNvbHZlKHZvaWQgMCk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuaWR4W2RvbWFpbl0/LltwYXRoXT8uW2tleV07XG4gICAgcmV0dXJuIHByb21pc2VDYWxsYmFjay5yZXNvbHZlKHJlc3VsdCk7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbCBObyBkb2MgYmVjYXVzZSB0aGlzIGlzIGFuIG92ZXJsb2FkIHRoYXQgc3VwcG9ydHMgdGhlIGltcGxlbWVudGF0aW9uXG4gICAqL1xuICBmaW5kQ29va2llcyhkb21haW4sIHBhdGgsIGFsbG93U3BlY2lhbFVzZURvbWFpbiA9IGZhbHNlLCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgYWxsb3dTcGVjaWFsVXNlRG9tYWluID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNhbGxiYWNrID0gYWxsb3dTcGVjaWFsVXNlRG9tYWluO1xuICAgICAgYWxsb3dTcGVjaWFsVXNlRG9tYWluID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgIGNvbnN0IHByb21pc2VDYWxsYmFjayA9IGNyZWF0ZVByb21pc2VDYWxsYmFjayhjYWxsYmFjayk7XG4gICAgaWYgKCFkb21haW4pIHtcbiAgICAgIHJldHVybiBwcm9taXNlQ2FsbGJhY2sucmVzb2x2ZShbXSk7XG4gICAgfVxuICAgIGxldCBwYXRoTWF0Y2hlcjtcbiAgICBpZiAoIXBhdGgpIHtcbiAgICAgIHBhdGhNYXRjaGVyID0gZnVuY3Rpb24gbWF0Y2hBbGwoZG9tYWluSW5kZXgpIHtcbiAgICAgICAgZm9yIChjb25zdCBjdXJQYXRoIGluIGRvbWFpbkluZGV4KSB7XG4gICAgICAgICAgY29uc3QgcGF0aEluZGV4ID0gZG9tYWluSW5kZXhbY3VyUGF0aF07XG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGF0aEluZGV4KSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHBhdGhJbmRleFtrZXldO1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRoTWF0Y2hlciA9IGZ1bmN0aW9uIG1hdGNoUkZDKGRvbWFpbkluZGV4KSB7XG4gICAgICAgIGZvciAoY29uc3QgY29va2llUGF0aCBpbiBkb21haW5JbmRleCkge1xuICAgICAgICAgIGlmIChwYXRoTWF0Y2gocGF0aCwgY29va2llUGF0aCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhJbmRleCA9IGRvbWFpbkluZGV4W2Nvb2tpZVBhdGhdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGF0aEluZGV4KSB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcGF0aEluZGV4W2tleV07XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGRvbWFpbnMgPSBwZXJtdXRlRG9tYWluKGRvbWFpbiwgYWxsb3dTcGVjaWFsVXNlRG9tYWluKSB8fCBbZG9tYWluXTtcbiAgICBjb25zdCBpZHggPSB0aGlzLmlkeDtcbiAgICBkb21haW5zLmZvckVhY2goKGN1ckRvbWFpbikgPT4ge1xuICAgICAgY29uc3QgZG9tYWluSW5kZXggPSBpZHhbY3VyRG9tYWluXTtcbiAgICAgIGlmICghZG9tYWluSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcGF0aE1hdGNoZXIoZG9tYWluSW5kZXgpO1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlQ2FsbGJhY2sucmVzb2x2ZShyZXN1bHRzKTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsIE5vIGRvYyBiZWNhdXNlIHRoaXMgaXMgYW4gb3ZlcmxvYWQgdGhhdCBzdXBwb3J0cyB0aGUgaW1wbGVtZW50YXRpb25cbiAgICovXG4gIHB1dENvb2tpZShjb29raWUsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgcHJvbWlzZUNhbGxiYWNrID0gY3JlYXRlUHJvbWlzZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgICBjb25zdCB7IGRvbWFpbiwgcGF0aCwga2V5IH0gPSBjb29raWU7XG4gICAgaWYgKGRvbWFpbiA9PSBudWxsIHx8IHBhdGggPT0gbnVsbCB8fCBrZXkgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHByb21pc2VDYWxsYmFjay5yZXNvbHZlKHZvaWQgMCk7XG4gICAgfVxuICAgIGNvbnN0IGRvbWFpbkVudHJ5ID0gdGhpcy5pZHhbZG9tYWluXSA/PyAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmlkeFtkb21haW5dID0gZG9tYWluRW50cnk7XG4gICAgY29uc3QgcGF0aEVudHJ5ID0gZG9tYWluRW50cnlbcGF0aF0gPz8gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZG9tYWluRW50cnlbcGF0aF0gPSBwYXRoRW50cnk7XG4gICAgcGF0aEVudHJ5W2tleV0gPSBjb29raWU7XG4gICAgcmV0dXJuIHByb21pc2VDYWxsYmFjay5yZXNvbHZlKHZvaWQgMCk7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbCBObyBkb2MgYmVjYXVzZSB0aGlzIGlzIGFuIG92ZXJsb2FkIHRoYXQgc3VwcG9ydHMgdGhlIGltcGxlbWVudGF0aW9uXG4gICAqL1xuICB1cGRhdGVDb29raWUoX29sZENvb2tpZSwgbmV3Q29va2llLCBjYWxsYmFjaykge1xuICAgIGlmIChjYWxsYmFjaykgdGhpcy5wdXRDb29raWUobmV3Q29va2llLCBjYWxsYmFjayk7XG4gICAgZWxzZSByZXR1cm4gdGhpcy5wdXRDb29raWUobmV3Q29va2llKTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsIE5vIGRvYyBiZWNhdXNlIHRoaXMgaXMgYW4gb3ZlcmxvYWQgdGhhdCBzdXBwb3J0cyB0aGUgaW1wbGVtZW50YXRpb25cbiAgICovXG4gIHJlbW92ZUNvb2tpZShkb21haW4sIHBhdGgsIGtleSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBwcm9taXNlQ2FsbGJhY2sgPSBjcmVhdGVQcm9taXNlQ2FsbGJhY2soY2FsbGJhY2spO1xuICAgIGRlbGV0ZSB0aGlzLmlkeFtkb21haW5dPy5bcGF0aF0/LltrZXldO1xuICAgIHJldHVybiBwcm9taXNlQ2FsbGJhY2sucmVzb2x2ZSh2b2lkIDApO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWwgTm8gZG9jIGJlY2F1c2UgdGhpcyBpcyBhbiBvdmVybG9hZCB0aGF0IHN1cHBvcnRzIHRoZSBpbXBsZW1lbnRhdGlvblxuICAgKi9cbiAgcmVtb3ZlQ29va2llcyhkb21haW4sIHBhdGgsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgcHJvbWlzZUNhbGxiYWNrID0gY3JlYXRlUHJvbWlzZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgICBjb25zdCBkb21haW5FbnRyeSA9IHRoaXMuaWR4W2RvbWFpbl07XG4gICAgaWYgKGRvbWFpbkVudHJ5KSB7XG4gICAgICBpZiAocGF0aCkge1xuICAgICAgICBkZWxldGUgZG9tYWluRW50cnlbcGF0aF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgdGhpcy5pZHhbZG9tYWluXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb21pc2VDYWxsYmFjay5yZXNvbHZlKHZvaWQgMCk7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbCBObyBkb2MgYmVjYXVzZSB0aGlzIGlzIGFuIG92ZXJsb2FkIHRoYXQgc3VwcG9ydHMgdGhlIGltcGxlbWVudGF0aW9uXG4gICAqL1xuICByZW1vdmVBbGxDb29raWVzKGNhbGxiYWNrKSB7XG4gICAgY29uc3QgcHJvbWlzZUNhbGxiYWNrID0gY3JlYXRlUHJvbWlzZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgICB0aGlzLmlkeCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHJldHVybiBwcm9taXNlQ2FsbGJhY2sucmVzb2x2ZSh2b2lkIDApO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWwgTm8gZG9jIGJlY2F1c2UgdGhpcyBpcyBhbiBvdmVybG9hZCB0aGF0IHN1cHBvcnRzIHRoZSBpbXBsZW1lbnRhdGlvblxuICAgKi9cbiAgZ2V0QWxsQ29va2llcyhjYWxsYmFjaykge1xuICAgIGNvbnN0IHByb21pc2VDYWxsYmFjayA9IGNyZWF0ZVByb21pc2VDYWxsYmFjayhjYWxsYmFjayk7XG4gICAgY29uc3QgY29va2llcyA9IFtdO1xuICAgIGNvbnN0IGlkeCA9IHRoaXMuaWR4O1xuICAgIGNvbnN0IGRvbWFpbnMgPSBPYmplY3Qua2V5cyhpZHgpO1xuICAgIGRvbWFpbnMuZm9yRWFjaCgoZG9tYWluKSA9PiB7XG4gICAgICBjb25zdCBkb21haW5FbnRyeSA9IGlkeFtkb21haW5dID8/IHt9O1xuICAgICAgY29uc3QgcGF0aHMgPSBPYmplY3Qua2V5cyhkb21haW5FbnRyeSk7XG4gICAgICBwYXRocy5mb3JFYWNoKChwYXRoKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhdGhFbnRyeSA9IGRvbWFpbkVudHJ5W3BhdGhdID8/IHt9O1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocGF0aEVudHJ5KTtcbiAgICAgICAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICBjb25zdCBrZXlFbnRyeSA9IHBhdGhFbnRyeVtrZXldO1xuICAgICAgICAgIGlmIChrZXlFbnRyeSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb29raWVzLnB1c2goa2V5RW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBjb29raWVzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIHJldHVybiAoYS5jcmVhdGlvbkluZGV4IHx8IDApIC0gKGIuY3JlYXRpb25JbmRleCB8fCAwKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZUNhbGxiYWNrLnJlc29sdmUoY29va2llcyk7XG4gIH1cbn07XG5cbi8vIGxpYi92YWxpZGF0b3JzLnRzXG5mdW5jdGlvbiBpc05vbkVtcHR5U3RyaW5nKGRhdGEpIHtcbiAgcmV0dXJuIGlzU3RyaW5nKGRhdGEpICYmIGRhdGEgIT09IFwiXCI7XG59XG5mdW5jdGlvbiBpc0VtcHR5U3RyaW5nKGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEgPT09IFwiXCIgfHwgZGF0YSBpbnN0YW5jZW9mIFN0cmluZyAmJiBkYXRhLnRvU3RyaW5nKCkgPT09IFwiXCI7XG59XG5mdW5jdGlvbiBpc1N0cmluZyhkYXRhKSB7XG4gIHJldHVybiB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiB8fCBkYXRhIGluc3RhbmNlb2YgU3RyaW5nO1xufVxuZnVuY3Rpb24gaXNPYmplY3QoZGF0YSkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoZGF0YSkgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZShib29sLCBjYk9yTWVzc2FnZSwgbWVzc2FnZSkge1xuICBpZiAoYm9vbCkgcmV0dXJuO1xuICBjb25zdCBjYiA9IHR5cGVvZiBjYk9yTWVzc2FnZSA9PT0gXCJmdW5jdGlvblwiID8gY2JPck1lc3NhZ2UgOiB2b2lkIDA7XG4gIGxldCBvcHRpb25zID0gdHlwZW9mIGNiT3JNZXNzYWdlID09PSBcImZ1bmN0aW9uXCIgPyBtZXNzYWdlIDogY2JPck1lc3NhZ2U7XG4gIGlmICghaXNPYmplY3Qob3B0aW9ucykpIG9wdGlvbnMgPSBcIltvYmplY3QgT2JqZWN0XVwiO1xuICBjb25zdCBlcnIgPSBuZXcgUGFyYW1ldGVyRXJyb3Ioc2FmZVRvU3RyaW5nKG9wdGlvbnMpKTtcbiAgaWYgKGNiKSBjYihlcnIpO1xuICBlbHNlIHRocm93IGVycjtcbn1cbnZhciBQYXJhbWV0ZXJFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xufTtcblxuLy8gbGliL3ZlcnNpb24udHNcbnZhciB2ZXJzaW9uID0gXCI2LjAuMFwiO1xuXG4vLyBsaWIvY29va2llL2NvbnN0YW50cy50c1xudmFyIFByZWZpeFNlY3VyaXR5RW51bSA9IHtcbiAgU0lMRU5UOiBcInNpbGVudFwiLFxuICBTVFJJQ1Q6IFwic3RyaWN0XCIsXG4gIERJU0FCTEVEOiBcInVuc2FmZS1kaXNhYmxlZFwiXG59O1xuT2JqZWN0LmZyZWV6ZShQcmVmaXhTZWN1cml0eUVudW0pO1xudmFyIElQX1Y2X1JFR0VYID0gYFxuXFxcXFs/KD86XG4oPzpbYS1mQS1GXFxcXGRdezEsNH06KXs3fSg/OlthLWZBLUZcXFxcZF17MSw0fXw6KXxcbig/OlthLWZBLUZcXFxcZF17MSw0fTopezZ9KD86KD86MjVbMC01XXwyWzAtNF1cXFxcZHwxXFxcXGRcXFxcZHxbMS05XVxcXFxkfFxcXFxkKSg/OlxcXFwuKD86MjVbMC01XXwyWzAtNF1cXFxcZHwxXFxcXGRcXFxcZHxbMS05XVxcXFxkfFxcXFxkKSl7M318OlthLWZBLUZcXFxcZF17MSw0fXw6KXxcbig/OlthLWZBLUZcXFxcZF17MSw0fTopezV9KD86Oig/OjI1WzAtNV18MlswLTRdXFxcXGR8MVxcXFxkXFxcXGR8WzEtOV1cXFxcZHxcXFxcZCkoPzpcXFxcLig/OjI1WzAtNV18MlswLTRdXFxcXGR8MVxcXFxkXFxcXGR8WzEtOV1cXFxcZHxcXFxcZCkpezN9fCg/OjpbYS1mQS1GXFxcXGRdezEsNH0pezEsMn18Oil8XG4oPzpbYS1mQS1GXFxcXGRdezEsNH06KXs0fSg/Oig/OjpbYS1mQS1GXFxcXGRdezEsNH0pezAsMX06KD86MjVbMC01XXwyWzAtNF1cXFxcZHwxXFxcXGRcXFxcZHxbMS05XVxcXFxkfFxcXFxkKSg/OlxcXFwuKD86MjVbMC01XXwyWzAtNF1cXFxcZHwxXFxcXGRcXFxcZHxbMS05XVxcXFxkfFxcXFxkKSl7M318KD86OlthLWZBLUZcXFxcZF17MSw0fSl7MSwzfXw6KXxcbig/OlthLWZBLUZcXFxcZF17MSw0fTopezN9KD86KD86OlthLWZBLUZcXFxcZF17MSw0fSl7MCwyfTooPzoyNVswLTVdfDJbMC00XVxcXFxkfDFcXFxcZFxcXFxkfFsxLTldXFxcXGR8XFxcXGQpKD86XFxcXC4oPzoyNVswLTVdfDJbMC00XVxcXFxkfDFcXFxcZFxcXFxkfFsxLTldXFxcXGR8XFxcXGQpKXszfXwoPzo6W2EtZkEtRlxcXFxkXXsxLDR9KXsxLDR9fDopfFxuKD86W2EtZkEtRlxcXFxkXXsxLDR9Oil7Mn0oPzooPzo6W2EtZkEtRlxcXFxkXXsxLDR9KXswLDN9Oig/OjI1WzAtNV18MlswLTRdXFxcXGR8MVxcXFxkXFxcXGR8WzEtOV1cXFxcZHxcXFxcZCkoPzpcXFxcLig/OjI1WzAtNV18MlswLTRdXFxcXGR8MVxcXFxkXFxcXGR8WzEtOV1cXFxcZHxcXFxcZCkpezN9fCg/OjpbYS1mQS1GXFxcXGRdezEsNH0pezEsNX18Oil8XG4oPzpbYS1mQS1GXFxcXGRdezEsNH06KXsxfSg/Oig/OjpbYS1mQS1GXFxcXGRdezEsNH0pezAsNH06KD86MjVbMC01XXwyWzAtNF1cXFxcZHwxXFxcXGRcXFxcZHxbMS05XVxcXFxkfFxcXFxkKSg/OlxcXFwuKD86MjVbMC01XXwyWzAtNF1cXFxcZHwxXFxcXGRcXFxcZHxbMS05XVxcXFxkfFxcXFxkKSl7M318KD86OlthLWZBLUZcXFxcZF17MSw0fSl7MSw2fXw6KXxcbig/OjooPzooPzo6W2EtZkEtRlxcXFxkXXsxLDR9KXswLDV9Oig/OjI1WzAtNV18MlswLTRdXFxcXGR8MVxcXFxkXFxcXGR8WzEtOV1cXFxcZHxcXFxcZCkoPzpcXFxcLig/OjI1WzAtNV18MlswLTRdXFxcXGR8MVxcXFxkXFxcXGR8WzEtOV1cXFxcZHxcXFxcZCkpezN9fCg/OjpbYS1mQS1GXFxcXGRdezEsNH0pezEsN318OikpXG4pKD86JVswLTlhLXpBLVpdezEsfSk/XFxcXF0/XG5gLnJlcGxhY2UoL1xccypcXC9cXC8uKiQvZ20sIFwiXCIpLnJlcGxhY2UoL1xcbi9nLCBcIlwiKS50cmltKCk7XG52YXIgSVBfVjZfUkVHRVhfT0JKRUNUID0gbmV3IFJlZ0V4cChgXiR7SVBfVjZfUkVHRVh9JGApO1xudmFyIElQX1Y0X1JFR0VYID0gYCg/Oig/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSlcXFxcLil7M30oPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pYDtcbnZhciBJUF9WNF9SRUdFWF9PQkpFQ1QgPSBuZXcgUmVnRXhwKGBeJHtJUF9WNF9SRUdFWH0kYCk7XG5cbi8vIGxpYi9jb29raWUvY2Fub25pY2FsRG9tYWluLnRzXG5mdW5jdGlvbiBkb21haW5Ub0FTQ0lJKGRvbWFpbikge1xuICByZXR1cm4gbmV3IFVSTChgaHR0cDovLyR7ZG9tYWlufWApLmhvc3RuYW1lO1xufVxuZnVuY3Rpb24gY2Fub25pY2FsRG9tYWluKGRvbWFpbk5hbWUpIHtcbiAgaWYgKGRvbWFpbk5hbWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgbGV0IHN0ciA9IGRvbWFpbk5hbWUudHJpbSgpLnJlcGxhY2UoL15cXC4vLCBcIlwiKTtcbiAgaWYgKElQX1Y2X1JFR0VYX09CSkVDVC50ZXN0KHN0cikpIHtcbiAgICBpZiAoIXN0ci5zdGFydHNXaXRoKFwiW1wiKSkge1xuICAgICAgc3RyID0gXCJbXCIgKyBzdHI7XG4gICAgfVxuICAgIGlmICghc3RyLmVuZHNXaXRoKFwiXVwiKSkge1xuICAgICAgc3RyID0gc3RyICsgXCJdXCI7XG4gICAgfVxuICAgIHJldHVybiBkb21haW5Ub0FTQ0lJKHN0cikuc2xpY2UoMSwgLTEpO1xuICB9XG4gIGlmICgvW15cXHUwMDAxLVxcdTAwN2ZdLy50ZXN0KHN0cikpIHtcbiAgICByZXR1cm4gZG9tYWluVG9BU0NJSShzdHIpO1xuICB9XG4gIHJldHVybiBzdHIudG9Mb3dlckNhc2UoKTtcbn1cblxuLy8gbGliL2Nvb2tpZS9mb3JtYXREYXRlLnRzXG5mdW5jdGlvbiBmb3JtYXREYXRlKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUudG9VVENTdHJpbmcoKTtcbn1cblxuLy8gbGliL2Nvb2tpZS9wYXJzZURhdGUudHNcbnZhciBEQVRFX0RFTElNID0gL1tcXHgwOVxceDIwLVxceDJGXFx4M0ItXFx4NDBcXHg1Qi1cXHg2MFxceDdCLVxceDdFXS87XG52YXIgTU9OVEhfVE9fTlVNID0ge1xuICBqYW46IDAsXG4gIGZlYjogMSxcbiAgbWFyOiAyLFxuICBhcHI6IDMsXG4gIG1heTogNCxcbiAganVuOiA1LFxuICBqdWw6IDYsXG4gIGF1ZzogNyxcbiAgc2VwOiA4LFxuICBvY3Q6IDksXG4gIG5vdjogMTAsXG4gIGRlYzogMTFcbn07XG5mdW5jdGlvbiBwYXJzZURpZ2l0cyh0b2tlbiwgbWluRGlnaXRzLCBtYXhEaWdpdHMsIHRyYWlsaW5nT0spIHtcbiAgbGV0IGNvdW50ID0gMDtcbiAgd2hpbGUgKGNvdW50IDwgdG9rZW4ubGVuZ3RoKSB7XG4gICAgY29uc3QgYyA9IHRva2VuLmNoYXJDb2RlQXQoY291bnQpO1xuICAgIGlmIChjIDw9IDQ3IHx8IGMgPj0gNTgpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb3VudCsrO1xuICB9XG4gIGlmIChjb3VudCA8IG1pbkRpZ2l0cyB8fCBjb3VudCA+IG1heERpZ2l0cykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIXRyYWlsaW5nT0sgJiYgY291bnQgIT0gdG9rZW4ubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJldHVybiBwYXJzZUludCh0b2tlbi5zbGljZSgwLCBjb3VudCksIDEwKTtcbn1cbmZ1bmN0aW9uIHBhcnNlVGltZSh0b2tlbikge1xuICBjb25zdCBwYXJ0cyA9IHRva2VuLnNwbGl0KFwiOlwiKTtcbiAgY29uc3QgcmVzdWx0ID0gWzAsIDAsIDBdO1xuICBpZiAocGFydHMubGVuZ3RoICE9PSAzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgY29uc3QgdHJhaWxpbmdPSyA9IGkgPT0gMjtcbiAgICBjb25zdCBudW1QYXJ0ID0gcGFydHNbaV07XG4gICAgaWYgKG51bVBhcnQgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBudW0gPSBwYXJzZURpZ2l0cyhudW1QYXJ0LCAxLCAyLCB0cmFpbGluZ09LKTtcbiAgICBpZiAobnVtID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVzdWx0W2ldID0gbnVtO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwYXJzZU1vbnRoKHRva2VuKSB7XG4gIHRva2VuID0gU3RyaW5nKHRva2VuKS5zbGljZSgwLCAzKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgY2FzZSBcImphblwiOlxuICAgICAgcmV0dXJuIE1PTlRIX1RPX05VTS5qYW47XG4gICAgY2FzZSBcImZlYlwiOlxuICAgICAgcmV0dXJuIE1PTlRIX1RPX05VTS5mZWI7XG4gICAgY2FzZSBcIm1hclwiOlxuICAgICAgcmV0dXJuIE1PTlRIX1RPX05VTS5tYXI7XG4gICAgY2FzZSBcImFwclwiOlxuICAgICAgcmV0dXJuIE1PTlRIX1RPX05VTS5hcHI7XG4gICAgY2FzZSBcIm1heVwiOlxuICAgICAgcmV0dXJuIE1PTlRIX1RPX05VTS5tYXk7XG4gICAgY2FzZSBcImp1blwiOlxuICAgICAgcmV0dXJuIE1PTlRIX1RPX05VTS5qdW47XG4gICAgY2FzZSBcImp1bFwiOlxuICAgICAgcmV0dXJuIE1PTlRIX1RPX05VTS5qdWw7XG4gICAgY2FzZSBcImF1Z1wiOlxuICAgICAgcmV0dXJuIE1PTlRIX1RPX05VTS5hdWc7XG4gICAgY2FzZSBcInNlcFwiOlxuICAgICAgcmV0dXJuIE1PTlRIX1RPX05VTS5zZXA7XG4gICAgY2FzZSBcIm9jdFwiOlxuICAgICAgcmV0dXJuIE1PTlRIX1RPX05VTS5vY3Q7XG4gICAgY2FzZSBcIm5vdlwiOlxuICAgICAgcmV0dXJuIE1PTlRIX1RPX05VTS5ub3Y7XG4gICAgY2FzZSBcImRlY1wiOlxuICAgICAgcmV0dXJuIE1PTlRIX1RPX05VTS5kZWM7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybjtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VEYXRlKGNvb2tpZURhdGUpIHtcbiAgaWYgKCFjb29raWVEYXRlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHRva2VucyA9IGNvb2tpZURhdGUuc3BsaXQoREFURV9ERUxJTSk7XG4gIGxldCBob3VyO1xuICBsZXQgbWludXRlO1xuICBsZXQgc2Vjb25kO1xuICBsZXQgZGF5T2ZNb250aDtcbiAgbGV0IG1vbnRoO1xuICBsZXQgeWVhcjtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB0b2tlbiA9ICh0b2tlbnNbaV0gPz8gXCJcIikudHJpbSgpO1xuICAgIGlmICghdG9rZW4ubGVuZ3RoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHNlY29uZCA9PT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBwYXJzZVRpbWUodG9rZW4pO1xuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICBob3VyID0gcmVzdWx0WzBdO1xuICAgICAgICBtaW51dGUgPSByZXN1bHRbMV07XG4gICAgICAgIHNlY29uZCA9IHJlc3VsdFsyXTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkYXlPZk1vbnRoID09PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlRGlnaXRzKHRva2VuLCAxLCAyLCB0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQgIT09IHZvaWQgMCkge1xuICAgICAgICBkYXlPZk1vbnRoID0gcmVzdWx0O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1vbnRoID09PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlTW9udGgodG9rZW4pO1xuICAgICAgaWYgKHJlc3VsdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIG1vbnRoID0gcmVzdWx0O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHllYXIgPT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gcGFyc2VEaWdpdHModG9rZW4sIDIsIDQsIHRydWUpO1xuICAgICAgaWYgKHJlc3VsdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHllYXIgPSByZXN1bHQ7XG4gICAgICAgIGlmICh5ZWFyID49IDcwICYmIHllYXIgPD0gOTkpIHtcbiAgICAgICAgICB5ZWFyICs9IDE5MDA7XG4gICAgICAgIH0gZWxzZSBpZiAoeWVhciA+PSAwICYmIHllYXIgPD0gNjkpIHtcbiAgICAgICAgICB5ZWFyICs9IDJlMztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoZGF5T2ZNb250aCA9PT0gdm9pZCAwIHx8IG1vbnRoID09PSB2b2lkIDAgfHwgeWVhciA9PT0gdm9pZCAwIHx8IGhvdXIgPT09IHZvaWQgMCB8fCBtaW51dGUgPT09IHZvaWQgMCB8fCBzZWNvbmQgPT09IHZvaWQgMCB8fCBkYXlPZk1vbnRoIDwgMSB8fCBkYXlPZk1vbnRoID4gMzEgfHwgeWVhciA8IDE2MDEgfHwgaG91ciA+IDIzIHx8IG1pbnV0ZSA+IDU5IHx8IHNlY29uZCA+IDU5KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCwgZGF5T2ZNb250aCwgaG91ciwgbWludXRlLCBzZWNvbmQpKTtcbn1cblxuLy8gbGliL2Nvb2tpZS9jb29raWUudHNcbnZhciBDT09LSUVfT0NURVRTID0gL15bXFx4MjFcXHgyMy1cXHgyQlxceDJELVxceDNBXFx4M0MtXFx4NUJcXHg1RC1cXHg3RV0rJC87XG52YXIgUEFUSF9WQUxVRSA9IC9bXFx4MjAtXFx4M0FcXHgzQy1cXHg3RV0rLztcbnZhciBDT05UUk9MX0NIQVJTID0gL1tcXHgwMC1cXHgxRl0vO1xudmFyIFRFUk1JTkFUT1JTID0gW1wiXFxuXCIsIFwiXFxyXCIsIFwiXFwwXCJdO1xuZnVuY3Rpb24gdHJpbVRlcm1pbmF0b3Ioc3RyKSB7XG4gIGlmIChpc0VtcHR5U3RyaW5nKHN0cikpIHJldHVybiBzdHI7XG4gIGZvciAobGV0IHQgPSAwOyB0IDwgVEVSTUlOQVRPUlMubGVuZ3RoOyB0KyspIHtcbiAgICBjb25zdCB0ZXJtaW5hdG9yID0gVEVSTUlOQVRPUlNbdF07XG4gICAgY29uc3QgdGVybWluYXRvcklkeCA9IHRlcm1pbmF0b3IgPyBzdHIuaW5kZXhPZih0ZXJtaW5hdG9yKSA6IC0xO1xuICAgIGlmICh0ZXJtaW5hdG9ySWR4ICE9PSAtMSkge1xuICAgICAgc3RyID0gc3RyLnNsaWNlKDAsIHRlcm1pbmF0b3JJZHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufVxuZnVuY3Rpb24gcGFyc2VDb29raWVQYWlyKGNvb2tpZVBhaXIsIGxvb3NlTW9kZSkge1xuICBjb29raWVQYWlyID0gdHJpbVRlcm1pbmF0b3IoY29va2llUGFpcik7XG4gIGxldCBmaXJzdEVxID0gY29va2llUGFpci5pbmRleE9mKFwiPVwiKTtcbiAgaWYgKGxvb3NlTW9kZSkge1xuICAgIGlmIChmaXJzdEVxID09PSAwKSB7XG4gICAgICBjb29raWVQYWlyID0gY29va2llUGFpci5zdWJzdHJpbmcoMSk7XG4gICAgICBmaXJzdEVxID0gY29va2llUGFpci5pbmRleE9mKFwiPVwiKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGZpcnN0RXEgPD0gMCkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgbGV0IGNvb2tpZU5hbWUsIGNvb2tpZVZhbHVlO1xuICBpZiAoZmlyc3RFcSA8PSAwKSB7XG4gICAgY29va2llTmFtZSA9IFwiXCI7XG4gICAgY29va2llVmFsdWUgPSBjb29raWVQYWlyLnRyaW0oKTtcbiAgfSBlbHNlIHtcbiAgICBjb29raWVOYW1lID0gY29va2llUGFpci5zbGljZSgwLCBmaXJzdEVxKS50cmltKCk7XG4gICAgY29va2llVmFsdWUgPSBjb29raWVQYWlyLnNsaWNlKGZpcnN0RXEgKyAxKS50cmltKCk7XG4gIH1cbiAgaWYgKENPTlRST0xfQ0hBUlMudGVzdChjb29raWVOYW1lKSB8fCBDT05UUk9MX0NIQVJTLnRlc3QoY29va2llVmFsdWUpKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBjb25zdCBjID0gbmV3IENvb2tpZSgpO1xuICBjLmtleSA9IGNvb2tpZU5hbWU7XG4gIGMudmFsdWUgPSBjb29raWVWYWx1ZTtcbiAgcmV0dXJuIGM7XG59XG5mdW5jdGlvbiBwYXJzZShzdHIsIG9wdGlvbnMpIHtcbiAgaWYgKGlzRW1wdHlTdHJpbmcoc3RyKSB8fCAhaXNTdHJpbmcoc3RyKSkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgc3RyID0gc3RyLnRyaW0oKTtcbiAgY29uc3QgZmlyc3RTZW1pID0gc3RyLmluZGV4T2YoXCI7XCIpO1xuICBjb25zdCBjb29raWVQYWlyID0gZmlyc3RTZW1pID09PSAtMSA/IHN0ciA6IHN0ci5zbGljZSgwLCBmaXJzdFNlbWkpO1xuICBjb25zdCBjID0gcGFyc2VDb29raWVQYWlyKGNvb2tpZVBhaXIsIG9wdGlvbnM/Lmxvb3NlID8/IGZhbHNlKTtcbiAgaWYgKCFjKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBpZiAoZmlyc3RTZW1pID09PSAtMSkge1xuICAgIHJldHVybiBjO1xuICB9XG4gIGNvbnN0IHVucGFyc2VkID0gc3RyLnNsaWNlKGZpcnN0U2VtaSArIDEpLnRyaW0oKTtcbiAgaWYgKHVucGFyc2VkLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBjO1xuICB9XG4gIGNvbnN0IGNvb2tpZV9hdnMgPSB1bnBhcnNlZC5zcGxpdChcIjtcIik7XG4gIHdoaWxlIChjb29raWVfYXZzLmxlbmd0aCkge1xuICAgIGNvbnN0IGF2ID0gKGNvb2tpZV9hdnMuc2hpZnQoKSA/PyBcIlwiKS50cmltKCk7XG4gICAgaWYgKGF2Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGF2X3NlcCA9IGF2LmluZGV4T2YoXCI9XCIpO1xuICAgIGxldCBhdl9rZXksIGF2X3ZhbHVlO1xuICAgIGlmIChhdl9zZXAgPT09IC0xKSB7XG4gICAgICBhdl9rZXkgPSBhdjtcbiAgICAgIGF2X3ZhbHVlID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgYXZfa2V5ID0gYXYuc2xpY2UoMCwgYXZfc2VwKTtcbiAgICAgIGF2X3ZhbHVlID0gYXYuc2xpY2UoYXZfc2VwICsgMSk7XG4gICAgfVxuICAgIGF2X2tleSA9IGF2X2tleS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoYXZfdmFsdWUpIHtcbiAgICAgIGF2X3ZhbHVlID0gYXZfdmFsdWUudHJpbSgpO1xuICAgIH1cbiAgICBzd2l0Y2ggKGF2X2tleSkge1xuICAgICAgY2FzZSBcImV4cGlyZXNcIjpcbiAgICAgICAgaWYgKGF2X3ZhbHVlKSB7XG4gICAgICAgICAgY29uc3QgZXhwID0gcGFyc2VEYXRlKGF2X3ZhbHVlKTtcbiAgICAgICAgICBpZiAoZXhwKSB7XG4gICAgICAgICAgICBjLmV4cGlyZXMgPSBleHA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1heC1hZ2VcIjpcbiAgICAgICAgaWYgKGF2X3ZhbHVlKSB7XG4gICAgICAgICAgaWYgKC9eLT9bMC05XSskLy50ZXN0KGF2X3ZhbHVlKSkge1xuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBwYXJzZUludChhdl92YWx1ZSwgMTApO1xuICAgICAgICAgICAgYy5zZXRNYXhBZ2UoZGVsdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkb21haW5cIjpcbiAgICAgICAgaWYgKGF2X3ZhbHVlKSB7XG4gICAgICAgICAgY29uc3QgZG9tYWluID0gYXZfdmFsdWUudHJpbSgpLnJlcGxhY2UoL15cXC4vLCBcIlwiKTtcbiAgICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgICBjLmRvbWFpbiA9IGRvbWFpbi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJwYXRoXCI6XG4gICAgICAgIGMucGF0aCA9IGF2X3ZhbHVlICYmIGF2X3ZhbHVlWzBdID09PSBcIi9cIiA/IGF2X3ZhbHVlIDogbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic2VjdXJlXCI6XG4gICAgICAgIGMuc2VjdXJlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiaHR0cG9ubHlcIjpcbiAgICAgICAgYy5odHRwT25seSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInNhbWVzaXRlXCI6XG4gICAgICAgIHN3aXRjaCAoYXZfdmFsdWUgPyBhdl92YWx1ZS50b0xvd2VyQ2FzZSgpIDogXCJcIikge1xuICAgICAgICAgIGNhc2UgXCJzdHJpY3RcIjpcbiAgICAgICAgICAgIGMuc2FtZVNpdGUgPSBcInN0cmljdFwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImxheFwiOlxuICAgICAgICAgICAgYy5zYW1lU2l0ZSA9IFwibGF4XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwibm9uZVwiOlxuICAgICAgICAgICAgYy5zYW1lU2l0ZSA9IFwibm9uZVwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGMuc2FtZVNpdGUgPSB2b2lkIDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGMuZXh0ZW5zaW9ucyA9IGMuZXh0ZW5zaW9ucyB8fCBbXTtcbiAgICAgICAgYy5leHRlbnNpb25zLnB1c2goYXYpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGM7XG59XG5mdW5jdGlvbiBmcm9tSlNPTihzdHIpIHtcbiAgaWYgKCFzdHIgfHwgaXNFbXB0eVN0cmluZyhzdHIpKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBsZXQgb2JqO1xuICBpZiAodHlwZW9mIHN0ciA9PT0gXCJzdHJpbmdcIikge1xuICAgIHRyeSB7XG4gICAgICBvYmogPSBKU09OLnBhcnNlKHN0cik7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBvYmogPSBzdHI7XG4gIH1cbiAgY29uc3QgYyA9IG5ldyBDb29raWUoKTtcbiAgQ29va2llLnNlcmlhbGl6YWJsZVByb3BlcnRpZXMuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgIGlmIChvYmogJiYgdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJiBpbk9wZXJhdG9yKHByb3AsIG9iaikpIHtcbiAgICAgIGNvbnN0IHZhbCA9IG9ialtwcm9wXTtcbiAgICAgIGlmICh2YWwgPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaW5PcGVyYXRvcihwcm9wLCBjb29raWVEZWZhdWx0cykgJiYgdmFsID09PSBjb29raWVEZWZhdWx0c1twcm9wXSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHByb3ApIHtcbiAgICAgICAgY2FzZSBcImtleVwiOlxuICAgICAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgICAgY2FzZSBcInNhbWVTaXRlXCI6XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNbcHJvcF0gPSB2YWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZXhwaXJlc1wiOlxuICAgICAgICBjYXNlIFwiY3JlYXRpb25cIjpcbiAgICAgICAgY2FzZSBcImxhc3RBY2Nlc3NlZFwiOlxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIgfHwgdmFsIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgY1twcm9wXSA9IG9ialtwcm9wXSA9PSBcIkluZmluaXR5XCIgPyBcIkluZmluaXR5XCIgOiBuZXcgRGF0ZSh2YWwpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodmFsID09PSBudWxsKSB7XG4gICAgICAgICAgICBjW3Byb3BdID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJtYXhBZ2VcIjpcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiB8fCB2YWwgPT09IFwiSW5maW5pdHlcIiB8fCB2YWwgPT09IFwiLUluZmluaXR5XCIpIHtcbiAgICAgICAgICAgIGNbcHJvcF0gPSB2YWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZG9tYWluXCI6XG4gICAgICAgIGNhc2UgXCJwYXRoXCI6XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIgfHwgdmFsID09PSBudWxsKSB7XG4gICAgICAgICAgICBjW3Byb3BdID0gdmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNlY3VyZVwiOlxuICAgICAgICBjYXNlIFwiaHR0cE9ubHlcIjpcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIGNbcHJvcF0gPSB2YWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZXh0ZW5zaW9uc1wiOlxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkgJiYgdmFsLmV2ZXJ5KChpdGVtKSA9PiB0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgICAgIGNbcHJvcF0gPSB2YWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaG9zdE9ubHlcIjpcbiAgICAgICAgY2FzZSBcInBhdGhJc0RlZmF1bHRcIjpcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gXCJib29sZWFuXCIgfHwgdmFsID09PSBudWxsKSB7XG4gICAgICAgICAgICBjW3Byb3BdID0gdmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYztcbn1cbnZhciBjb29raWVEZWZhdWx0cyA9IHtcbiAgLy8gdGhlIG9yZGVyIGluIHdoaWNoIHRoZSBSRkMgaGFzIHRoZW06XG4gIGtleTogXCJcIixcbiAgdmFsdWU6IFwiXCIsXG4gIGV4cGlyZXM6IFwiSW5maW5pdHlcIixcbiAgbWF4QWdlOiBudWxsLFxuICBkb21haW46IG51bGwsXG4gIHBhdGg6IG51bGwsXG4gIHNlY3VyZTogZmFsc2UsXG4gIGh0dHBPbmx5OiBmYWxzZSxcbiAgZXh0ZW5zaW9uczogbnVsbCxcbiAgLy8gc2V0IGJ5IHRoZSBDb29raWVKYXI6XG4gIGhvc3RPbmx5OiBudWxsLFxuICBwYXRoSXNEZWZhdWx0OiBudWxsLFxuICBjcmVhdGlvbjogbnVsbCxcbiAgbGFzdEFjY2Vzc2VkOiBudWxsLFxuICBzYW1lU2l0ZTogdm9pZCAwXG59O1xudmFyIF9Db29raWUgPSBjbGFzcyBfQ29va2llIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBDb29raWUgaW5zdGFuY2UuXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgYXR0cmlidXRlcyB0byBzZXQgb24gdGhlIGNvb2tpZVxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5rZXkgPSBvcHRpb25zLmtleSA/PyBjb29raWVEZWZhdWx0cy5rZXk7XG4gICAgdGhpcy52YWx1ZSA9IG9wdGlvbnMudmFsdWUgPz8gY29va2llRGVmYXVsdHMudmFsdWU7XG4gICAgdGhpcy5leHBpcmVzID0gb3B0aW9ucy5leHBpcmVzID8/IGNvb2tpZURlZmF1bHRzLmV4cGlyZXM7XG4gICAgdGhpcy5tYXhBZ2UgPSBvcHRpb25zLm1heEFnZSA/PyBjb29raWVEZWZhdWx0cy5tYXhBZ2U7XG4gICAgdGhpcy5kb21haW4gPSBvcHRpb25zLmRvbWFpbiA/PyBjb29raWVEZWZhdWx0cy5kb21haW47XG4gICAgdGhpcy5wYXRoID0gb3B0aW9ucy5wYXRoID8/IGNvb2tpZURlZmF1bHRzLnBhdGg7XG4gICAgdGhpcy5zZWN1cmUgPSBvcHRpb25zLnNlY3VyZSA/PyBjb29raWVEZWZhdWx0cy5zZWN1cmU7XG4gICAgdGhpcy5odHRwT25seSA9IG9wdGlvbnMuaHR0cE9ubHkgPz8gY29va2llRGVmYXVsdHMuaHR0cE9ubHk7XG4gICAgdGhpcy5leHRlbnNpb25zID0gb3B0aW9ucy5leHRlbnNpb25zID8/IGNvb2tpZURlZmF1bHRzLmV4dGVuc2lvbnM7XG4gICAgdGhpcy5jcmVhdGlvbiA9IG9wdGlvbnMuY3JlYXRpb24gPz8gY29va2llRGVmYXVsdHMuY3JlYXRpb247XG4gICAgdGhpcy5ob3N0T25seSA9IG9wdGlvbnMuaG9zdE9ubHkgPz8gY29va2llRGVmYXVsdHMuaG9zdE9ubHk7XG4gICAgdGhpcy5wYXRoSXNEZWZhdWx0ID0gb3B0aW9ucy5wYXRoSXNEZWZhdWx0ID8/IGNvb2tpZURlZmF1bHRzLnBhdGhJc0RlZmF1bHQ7XG4gICAgdGhpcy5sYXN0QWNjZXNzZWQgPSBvcHRpb25zLmxhc3RBY2Nlc3NlZCA/PyBjb29raWVEZWZhdWx0cy5sYXN0QWNjZXNzZWQ7XG4gICAgdGhpcy5zYW1lU2l0ZSA9IG9wdGlvbnMuc2FtZVNpdGUgPz8gY29va2llRGVmYXVsdHMuc2FtZVNpdGU7XG4gICAgdGhpcy5jcmVhdGlvbiA9IG9wdGlvbnMuY3JlYXRpb24gPz8gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY3JlYXRpb25JbmRleFwiLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAvLyBpbXBvcnRhbnQgZm9yIGFzc2VydC5kZWVwRXF1YWwgY2hlY2tzXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiArK19Db29raWUuY29va2llc0NyZWF0ZWRcbiAgICB9KTtcbiAgICB0aGlzLmNyZWF0aW9uSW5kZXggPSBfQ29va2llLmNvb2tpZXNDcmVhdGVkO1xuICB9XG4gIFtTeW1ib2wuZm9yKFwibm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b21cIildKCkge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgaG9zdE9ubHkgPSB0aGlzLmhvc3RPbmx5ICE9IG51bGwgPyB0aGlzLmhvc3RPbmx5LnRvU3RyaW5nKCkgOiBcIj9cIjtcbiAgICBjb25zdCBjcmVhdGVBZ2UgPSB0aGlzLmNyZWF0aW9uICYmIHRoaXMuY3JlYXRpb24gIT09IFwiSW5maW5pdHlcIiA/IGAke1N0cmluZyhub3cgLSB0aGlzLmNyZWF0aW9uLmdldFRpbWUoKSl9bXNgIDogXCI/XCI7XG4gICAgY29uc3QgYWNjZXNzQWdlID0gdGhpcy5sYXN0QWNjZXNzZWQgJiYgdGhpcy5sYXN0QWNjZXNzZWQgIT09IFwiSW5maW5pdHlcIiA/IGAke1N0cmluZyhub3cgLSB0aGlzLmxhc3RBY2Nlc3NlZC5nZXRUaW1lKCkpfW1zYCA6IFwiP1wiO1xuICAgIHJldHVybiBgQ29va2llPVwiJHt0aGlzLnRvU3RyaW5nKCl9OyBob3N0T25seT0ke2hvc3RPbmx5fTsgYUFnZT0ke2FjY2Vzc0FnZX07IGNBZ2U9JHtjcmVhdGVBZ2V9XCJgO1xuICB9XG4gIC8qKlxuICAgKiBGb3IgY29udmVuaWVuY2UgaW4gdXNpbmcgYEpTT04uc3RyaW5naWZ5KGNvb2tpZSlgLiBSZXR1cm5zIGEgcGxhaW4tb2xkIE9iamVjdCB0aGF0IGNhbiBiZSBKU09OLXNlcmlhbGl6ZWQuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIC0gQW55IGBEYXRlYCBwcm9wZXJ0aWVzIChzdWNoIGFzIHtAbGluayBDb29raWUuZXhwaXJlc30sIHtAbGluayBDb29raWUuY3JlYXRpb259LCBhbmQge0BsaW5rIENvb2tpZS5sYXN0QWNjZXNzZWR9KSBhcmUgZXhwb3J0ZWQgaW4gSVNPIGZvcm1hdCAoYERhdGUudG9JU09TdHJpbmcoKWApLlxuICAgKlxuICAgKiAgLSBDdXN0b20gQ29va2llIHByb3BlcnRpZXMgYXJlIGRpc2NhcmRlZC4gSW4gdG91Z2gtY29va2llIDEueCwgc2luY2UgdGhlcmUgd2FzIG5vIHtAbGluayBDb29raWUudG9KU09OfSBtZXRob2QgZXhwbGljaXRseSBkZWZpbmVkLCBhbGwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIHdlcmUgY2FwdHVyZWQuXG4gICAqICAgICAgSWYgeW91IHdhbnQgYSBwcm9wZXJ0eSB0byBiZSBzZXJpYWxpemVkLCBhZGQgdGhlIHByb3BlcnR5IG5hbWUgdG8ge0BsaW5rIENvb2tpZS5zZXJpYWxpemFibGVQcm9wZXJ0aWVzfS5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICBjb25zdCBvYmogPSB7fTtcbiAgICBmb3IgKGNvbnN0IHByb3Agb2YgX0Nvb2tpZS5zZXJpYWxpemFibGVQcm9wZXJ0aWVzKSB7XG4gICAgICBjb25zdCB2YWwgPSB0aGlzW3Byb3BdO1xuICAgICAgaWYgKHZhbCA9PT0gY29va2llRGVmYXVsdHNbcHJvcF0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHByb3ApIHtcbiAgICAgICAgY2FzZSBcImtleVwiOlxuICAgICAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgICAgY2FzZSBcInNhbWVTaXRlXCI6XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIG9ialtwcm9wXSA9IHZhbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJleHBpcmVzXCI6XG4gICAgICAgIGNhc2UgXCJjcmVhdGlvblwiOlxuICAgICAgICBjYXNlIFwibGFzdEFjY2Vzc2VkXCI6XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIiB8fCB2YWwgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICBvYmpbcHJvcF0gPSB2YWwgPT0gXCJJbmZpbml0eVwiID8gXCJJbmZpbml0eVwiIDogbmV3IERhdGUodmFsKS50b0lTT1N0cmluZygpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodmFsID09PSBudWxsKSB7XG4gICAgICAgICAgICBvYmpbcHJvcF0gPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm1heEFnZVwiOlxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSBcIm51bWJlclwiIHx8IHZhbCA9PT0gXCJJbmZpbml0eVwiIHx8IHZhbCA9PT0gXCItSW5maW5pdHlcIikge1xuICAgICAgICAgICAgb2JqW3Byb3BdID0gdmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRvbWFpblwiOlxuICAgICAgICBjYXNlIFwicGF0aFwiOlxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiIHx8IHZhbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgb2JqW3Byb3BdID0gdmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNlY3VyZVwiOlxuICAgICAgICBjYXNlIFwiaHR0cE9ubHlcIjpcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIG9ialtwcm9wXSA9IHZhbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJleHRlbnNpb25zXCI6XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICAgICAgb2JqW3Byb3BdID0gdmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImhvc3RPbmx5XCI6XG4gICAgICAgIGNhc2UgXCJwYXRoSXNEZWZhdWx0XCI6XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09IFwiYm9vbGVhblwiIHx8IHZhbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgb2JqW3Byb3BdID0gdmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICAvKipcbiAgICogRG9lcyBhIGRlZXAgY2xvbmUgb2YgdGhpcyBjb29raWUsIGltcGxlbWVudGVkIGV4YWN0bHkgYXMgYENvb2tpZS5mcm9tSlNPTihjb29raWUudG9KU09OKCkpYC5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIGZyb21KU09OKHRoaXMudG9KU09OKCkpO1xuICB9XG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgY29va2llIGF0dHJpYnV0ZXMgZm9yIHNlbWFudGljIGNvcnJlY3RuZXNzLiBVc2VmdWwgZm9yIFwibGludFwiIGNoZWNraW5nIGFueSBgU2V0LUNvb2tpZWAgaGVhZGVycyB5b3UgZ2VuZXJhdGUuXG4gICAqIEZvciBub3csIGl0IHJldHVybnMgYSBib29sZWFuLCBidXQgZXZlbnR1YWxseSBjb3VsZCByZXR1cm4gYSByZWFzb24gc3RyaW5nLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBXb3JrcyBmb3IgYSBmZXcgdGhpbmdzLCBidXQgaXMgYnkgbm8gbWVhbnMgY29tcHJlaGVuc2l2ZS5cbiAgICpcbiAgICogQGJldGFcbiAgICovXG4gIHZhbGlkYXRlKCkge1xuICAgIGlmICghdGhpcy52YWx1ZSB8fCAhQ09PS0lFX09DVEVUUy50ZXN0KHRoaXMudmFsdWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLmV4cGlyZXMgIT0gXCJJbmZpbml0eVwiICYmICEodGhpcy5leHBpcmVzIGluc3RhbmNlb2YgRGF0ZSkgJiYgIXBhcnNlRGF0ZSh0aGlzLmV4cGlyZXMpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLm1heEFnZSAhPSBudWxsICYmIHRoaXMubWF4QWdlICE9PSBcIkluZmluaXR5XCIgJiYgKHRoaXMubWF4QWdlID09PSBcIi1JbmZpbml0eVwiIHx8IHRoaXMubWF4QWdlIDw9IDApKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLnBhdGggIT0gbnVsbCAmJiAhUEFUSF9WQUxVRS50ZXN0KHRoaXMucGF0aCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgY2RvbWFpbiA9IHRoaXMuY2RvbWFpbigpO1xuICAgIGlmIChjZG9tYWluKSB7XG4gICAgICBpZiAoY2RvbWFpbi5tYXRjaCgvXFwuJC8pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN1ZmZpeCA9IGdldFB1YmxpY1N1ZmZpeChjZG9tYWluKTtcbiAgICAgIGlmIChzdWZmaXggPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSAnRXhwaXJlcycgYXR0cmlidXRlIG9uIGEgY29va2llLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBXaGVuIGdpdmVuIGEgYHN0cmluZ2AgdmFsdWUgaXQgd2lsbCBiZSBwYXJzZWQgd2l0aCB7QGxpbmsgcGFyc2VEYXRlfS4gSWYgdGhlIHZhbHVlIGNhbid0IGJlIHBhcnNlZCBhcyBhIGNvb2tpZSBkYXRlXG4gICAqIHRoZW4gdGhlICdFeHBpcmVzJyBhdHRyaWJ1dGUgd2lsbCBiZSBzZXQgdG8gYFwiSW5maW5pdHlcImAuXG4gICAqXG4gICAqIEBwYXJhbSBleHAgLSB0aGUgbmV3IHZhbHVlIGZvciB0aGUgJ0V4cGlyZXMnIGF0dHJpYnV0ZSBvZiB0aGUgY29va2llLlxuICAgKi9cbiAgc2V0RXhwaXJlcyhleHApIHtcbiAgICBpZiAoZXhwIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgdGhpcy5leHBpcmVzID0gZXhwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmV4cGlyZXMgPSBwYXJzZURhdGUoZXhwKSB8fCBcIkluZmluaXR5XCI7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSAnTWF4LUFnZScgYXR0cmlidXRlIChpbiBzZWNvbmRzKSBvbiBhIGNvb2tpZS5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogQ29lcmNlcyBgLUluZmluaXR5YCB0byBgXCItSW5maW5pdHlcImAgYW5kIGBJbmZpbml0eWAgdG8gYFwiSW5maW5pdHlcImAgc28gaXQgY2FuIGJlIHNlcmlhbGl6ZWQgdG8gSlNPTi5cbiAgICpcbiAgICogQHBhcmFtIGFnZSAtIHRoZSBuZXcgdmFsdWUgZm9yIHRoZSAnTWF4LUFnZScgYXR0cmlidXRlIChpbiBzZWNvbmRzKS5cbiAgICovXG4gIHNldE1heEFnZShhZ2UpIHtcbiAgICBpZiAoYWdlID09PSBJbmZpbml0eSkge1xuICAgICAgdGhpcy5tYXhBZ2UgPSBcIkluZmluaXR5XCI7XG4gICAgfSBlbHNlIGlmIChhZ2UgPT09IC1JbmZpbml0eSkge1xuICAgICAgdGhpcy5tYXhBZ2UgPSBcIi1JbmZpbml0eVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1heEFnZSA9IGFnZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEVuY29kZXMgdG8gYSBgQ29va2llYCBoZWFkZXIgdmFsdWUgKHNwZWNpZmljYWxseSwgdGhlIHtAbGluayBDb29raWUua2V5fSBhbmQge0BsaW5rIENvb2tpZS52YWx1ZX0gcHJvcGVydGllcyBqb2luZWQgd2l0aCBcIj1cIikuXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNvb2tpZVN0cmluZygpIHtcbiAgICBjb25zdCB2YWwgPSB0aGlzLnZhbHVlIHx8IFwiXCI7XG4gICAgaWYgKHRoaXMua2V5KSB7XG4gICAgICByZXR1cm4gYCR7dGhpcy5rZXl9PSR7dmFsfWA7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgLyoqXG4gICAqIEVuY29kZXMgdG8gYSBgU2V0LUNvb2tpZSBoZWFkZXJgIHZhbHVlLlxuICAgKiBAcHVibGljXG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICBsZXQgc3RyID0gdGhpcy5jb29raWVTdHJpbmcoKTtcbiAgICBpZiAodGhpcy5leHBpcmVzICE9IFwiSW5maW5pdHlcIikge1xuICAgICAgaWYgKHRoaXMuZXhwaXJlcyBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgc3RyICs9IGA7IEV4cGlyZXM9JHtmb3JtYXREYXRlKHRoaXMuZXhwaXJlcyl9YDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMubWF4QWdlICE9IG51bGwgJiYgdGhpcy5tYXhBZ2UgIT0gSW5maW5pdHkpIHtcbiAgICAgIHN0ciArPSBgOyBNYXgtQWdlPSR7U3RyaW5nKHRoaXMubWF4QWdlKX1gO1xuICAgIH1cbiAgICBpZiAodGhpcy5kb21haW4gJiYgIXRoaXMuaG9zdE9ubHkpIHtcbiAgICAgIHN0ciArPSBgOyBEb21haW49JHt0aGlzLmRvbWFpbn1gO1xuICAgIH1cbiAgICBpZiAodGhpcy5wYXRoKSB7XG4gICAgICBzdHIgKz0gYDsgUGF0aD0ke3RoaXMucGF0aH1gO1xuICAgIH1cbiAgICBpZiAodGhpcy5zZWN1cmUpIHtcbiAgICAgIHN0ciArPSBcIjsgU2VjdXJlXCI7XG4gICAgfVxuICAgIGlmICh0aGlzLmh0dHBPbmx5KSB7XG4gICAgICBzdHIgKz0gXCI7IEh0dHBPbmx5XCI7XG4gICAgfVxuICAgIGlmICh0aGlzLnNhbWVTaXRlICYmIHRoaXMuc2FtZVNpdGUgIT09IFwibm9uZVwiKSB7XG4gICAgICBpZiAodGhpcy5zYW1lU2l0ZS50b0xvd2VyQ2FzZSgpID09PSBfQ29va2llLnNhbWVTaXRlQ2Fub25pY2FsLmxheC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIHN0ciArPSBgOyBTYW1lU2l0ZT0ke19Db29raWUuc2FtZVNpdGVDYW5vbmljYWwubGF4fWA7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc2FtZVNpdGUudG9Mb3dlckNhc2UoKSA9PT0gX0Nvb2tpZS5zYW1lU2l0ZUNhbm9uaWNhbC5zdHJpY3QudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICBzdHIgKz0gYDsgU2FtZVNpdGU9JHtfQ29va2llLnNhbWVTaXRlQ2Fub25pY2FsLnN0cmljdH1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyICs9IGA7IFNhbWVTaXRlPSR7dGhpcy5zYW1lU2l0ZX1gO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5leHRlbnNpb25zKSB7XG4gICAgICB0aGlzLmV4dGVuc2lvbnMuZm9yRWFjaCgoZXh0KSA9PiB7XG4gICAgICAgIHN0ciArPSBgOyAke2V4dH1gO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBUVEwgcmVsYXRpdmUgdG8gbm93IChtaWxsaXNlY29uZHMpLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiAtIGBJbmZpbml0eWAgaXMgcmV0dXJuZWQgZm9yIGNvb2tpZXMgd2l0aG91dCBhbiBleHBsaWNpdCBleHBpcnlcbiAgICpcbiAgICogLSBgMGAgaXMgcmV0dXJuZWQgaWYgdGhlIGNvb2tpZSBpcyBleHBpcmVkLlxuICAgKlxuICAgKiAtIE90aGVyd2lzZSBhIHRpbWUtdG8tbGl2ZSBpbiBtaWxsaXNlY29uZHMgaXMgcmV0dXJuZWQuXG4gICAqXG4gICAqIEBwYXJhbSBub3cgLSBwYXNzaW5nIGFuIGV4cGxpY2l0IHZhbHVlIGlzIG1vc3RseSB1c2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIHNpbmNlIHRoaXMgZGVmYXVsdHMgdG8gdGhlIGBEYXRlLm5vdygpYFxuICAgKiBAcHVibGljXG4gICAqL1xuICBUVEwobm93ID0gRGF0ZS5ub3coKSkge1xuICAgIGlmICh0aGlzLm1heEFnZSAhPSBudWxsICYmIHR5cGVvZiB0aGlzLm1heEFnZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIHRoaXMubWF4QWdlIDw9IDAgPyAwIDogdGhpcy5tYXhBZ2UgKiAxZTM7XG4gICAgfVxuICAgIGNvbnN0IGV4cGlyZXMgPSB0aGlzLmV4cGlyZXM7XG4gICAgaWYgKGV4cGlyZXMgPT09IFwiSW5maW5pdHlcIikge1xuICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cbiAgICByZXR1cm4gKGV4cGlyZXM/LmdldFRpbWUoKSA/PyBub3cpIC0gKG5vdyB8fCBEYXRlLm5vdygpKTtcbiAgfVxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIGFic29sdXRlIHVuaXgtZXBvY2ggbWlsbGlzZWNvbmRzIHRoYXQgdGhpcyBjb29raWUgZXhwaXJlcy5cbiAgICpcbiAgICogVGhlIFwiTWF4LUFnZVwiIGF0dHJpYnV0ZSB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgXCJFeHBpcmVzXCIgKGFzIHBlciB0aGUgUkZDKS4gVGhlIHtAbGluayBDb29raWUubGFzdEFjY2Vzc2VkfSBhdHRyaWJ1dGVcbiAgICogKG9yIHRoZSBgbm93YCBwYXJhbWV0ZXIgaWYgZ2l2ZW4pIGlzIHVzZWQgdG8gb2Zmc2V0IHRoZSB7QGxpbmsgQ29va2llLm1heEFnZX0gYXR0cmlidXRlLlxuICAgKlxuICAgKiBJZiBFeHBpcmVzICh7QGxpbmsgQ29va2llLmV4cGlyZXN9KSBpcyBzZXQsIHRoYXQncyByZXR1cm5lZC5cbiAgICpcbiAgICogQHBhcmFtIG5vdyAtIGNhbiBiZSB1c2VkIHRvIHByb3ZpZGUgYSB0aW1lIG9mZnNldCAoaW5zdGVhZCBvZiB7QGxpbmsgQ29va2llLmxhc3RBY2Nlc3NlZH0pIHRvIHVzZSB3aGVuIGNhbGN1bGF0aW5nIHRoZSBcIk1heC1BZ2VcIiB2YWx1ZVxuICAgKi9cbiAgZXhwaXJ5VGltZShub3cpIHtcbiAgICBpZiAodGhpcy5tYXhBZ2UgIT0gbnVsbCkge1xuICAgICAgY29uc3QgcmVsYXRpdmVUbyA9IG5vdyB8fCB0aGlzLmxhc3RBY2Nlc3NlZCB8fCAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgIGNvbnN0IG1heEFnZSA9IHR5cGVvZiB0aGlzLm1heEFnZSA9PT0gXCJudW1iZXJcIiA/IHRoaXMubWF4QWdlIDogLUluZmluaXR5O1xuICAgICAgY29uc3QgYWdlID0gbWF4QWdlIDw9IDAgPyAtSW5maW5pdHkgOiBtYXhBZ2UgKiAxZTM7XG4gICAgICBpZiAocmVsYXRpdmVUbyA9PT0gXCJJbmZpbml0eVwiKSB7XG4gICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZWxhdGl2ZVRvLmdldFRpbWUoKSArIGFnZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZXhwaXJlcyA9PSBcIkluZmluaXR5XCIpIHtcbiAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZXhwaXJlcyA/IHRoaXMuZXhwaXJlcy5nZXRUaW1lKCkgOiB2b2lkIDA7XG4gIH1cbiAgLyoqXG4gICAqIFNpbWlsYXIgdG8ge0BsaW5rIENvb2tpZS5leHBpcnlUaW1lfSwgY29tcHV0ZXMgdGhlIGFic29sdXRlIHVuaXgtZXBvY2ggbWlsbGlzZWNvbmRzIHRoYXQgdGhpcyBjb29raWUgZXhwaXJlcyBhbmQgcmV0dXJucyBpdCBhcyBhIERhdGUuXG4gICAqXG4gICAqIFRoZSBcIk1heC1BZ2VcIiBhdHRyaWJ1dGUgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIFwiRXhwaXJlc1wiIChhcyBwZXIgdGhlIFJGQykuIFRoZSB7QGxpbmsgQ29va2llLmxhc3RBY2Nlc3NlZH0gYXR0cmlidXRlXG4gICAqIChvciB0aGUgYG5vd2AgcGFyYW1ldGVyIGlmIGdpdmVuKSBpcyB1c2VkIHRvIG9mZnNldCB0aGUge0BsaW5rIENvb2tpZS5tYXhBZ2V9IGF0dHJpYnV0ZS5cbiAgICpcbiAgICogSWYgRXhwaXJlcyAoe0BsaW5rIENvb2tpZS5leHBpcmVzfSkgaXMgc2V0LCB0aGF0J3MgcmV0dXJuZWQuXG4gICAqXG4gICAqIEBwYXJhbSBub3cgLSBjYW4gYmUgdXNlZCB0byBwcm92aWRlIGEgdGltZSBvZmZzZXQgKGluc3RlYWQgb2Yge0BsaW5rIENvb2tpZS5sYXN0QWNjZXNzZWR9KSB0byB1c2Ugd2hlbiBjYWxjdWxhdGluZyB0aGUgXCJNYXgtQWdlXCIgdmFsdWVcbiAgICovXG4gIGV4cGlyeURhdGUobm93KSB7XG4gICAgY29uc3QgbWlsbGlzZWMgPSB0aGlzLmV4cGlyeVRpbWUobm93KTtcbiAgICBpZiAobWlsbGlzZWMgPT0gSW5maW5pdHkpIHtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoMjE0NzQ4MzY0N2UzKTtcbiAgICB9IGVsc2UgaWYgKG1pbGxpc2VjID09IC1JbmZpbml0eSkge1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1pbGxpc2VjID09IHZvaWQgMCA/IHZvaWQgMCA6IG5ldyBEYXRlKG1pbGxpc2VjKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEluZGljYXRlcyBpZiB0aGUgY29va2llIGhhcyBiZWVuIHBlcnNpc3RlZCB0byBhIHN0b3JlIG9yIG5vdC5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgaXNQZXJzaXN0ZW50KCkge1xuICAgIHJldHVybiB0aGlzLm1heEFnZSAhPSBudWxsIHx8IHRoaXMuZXhwaXJlcyAhPSBcIkluZmluaXR5XCI7XG4gIH1cbiAgLyoqXG4gICAqIENhbGxzIHtAbGluayBjYW5vbmljYWxEb21haW59IHdpdGggdGhlIHtAbGluayBDb29raWUuZG9tYWlufSBwcm9wZXJ0eS5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2Fub25pY2FsaXplZERvbWFpbigpIHtcbiAgICByZXR1cm4gY2Fub25pY2FsRG9tYWluKHRoaXMuZG9tYWluKTtcbiAgfVxuICAvKipcbiAgICogQWxpYXMgZm9yIHtAbGluayBDb29raWUuY2Fub25pY2FsaXplZERvbWFpbn1cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2RvbWFpbigpIHtcbiAgICByZXR1cm4gY2Fub25pY2FsRG9tYWluKHRoaXMuZG9tYWluKTtcbiAgfVxuICAvKipcbiAgICogUGFyc2VzIGEgc3RyaW5nIGludG8gYSBDb29raWUgb2JqZWN0LlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBOb3RlOiB3aGVuIHBhcnNpbmcgYSBgQ29va2llYCBoZWFkZXIgaXQgbXVzdCBiZSBzcGxpdCBieSAnOycgYmVmb3JlIGVhY2ggQ29va2llIHN0cmluZyBjYW4gYmUgcGFyc2VkLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBcbiAgICogLy8gcGFyc2UgYSBgU2V0LUNvb2tpZWAgaGVhZGVyXG4gICAqIGNvbnN0IHNldENvb2tpZUhlYWRlciA9ICdhPWJjZDsgRXhwaXJlcz1UdWUsIDE4IE9jdCAyMDExIDA3OjA1OjAzIEdNVCdcbiAgICogY29uc3QgY29va2llID0gQ29va2llLnBhcnNlKHNldENvb2tpZUhlYWRlcilcbiAgICogY29va2llLmtleSA9PT0gJ2EnXG4gICAqIGNvb2tpZS52YWx1ZSA9PT0gJ2JjZCdcbiAgICogY29va2llLmV4cGlyZXMgPT09IG5ldyBEYXRlKERhdGUucGFyc2UoJ1R1ZSwgMTggT2N0IDIwMTEgMDc6MDU6MDMgR01UJykpXG4gICAqIGBgYFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBcbiAgICogLy8gcGFyc2UgYSBgQ29va2llYCBoZWFkZXJcbiAgICogY29uc3QgY29va2llSGVhZGVyID0gJ25hbWU9dmFsdWU7IG5hbWUyPXZhbHVlMjsgbmFtZTM9dmFsdWUzJ1xuICAgKiBjb25zdCBjb29raWVzID0gY29va2llSGVhZGVyLnNwbGl0KCc7JykubWFwKENvb2tpZS5wYXJzZSlcbiAgICogY29va2llc1swXS5uYW1lID09PSAnbmFtZSdcbiAgICogY29va2llc1swXS52YWx1ZSA9PT0gJ3ZhbHVlJ1xuICAgKiBjb29raWVzWzFdLm5hbWUgPT09ICduYW1lMidcbiAgICogY29va2llc1sxXS52YWx1ZSA9PT0gJ3ZhbHVlMidcbiAgICogY29va2llc1syXS5uYW1lID09PSAnbmFtZTMnXG4gICAqIGNvb2tpZXNbMl0udmFsdWUgPT09ICd2YWx1ZTMnXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gc3RyIC0gVGhlIGBTZXQtQ29va2llYCBoZWFkZXIgb3IgYSBDb29raWUgc3RyaW5nIHRvIHBhcnNlLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIENvbmZpZ3VyZXMgYHN0cmljdGAgb3IgYGxvb3NlYCBtb2RlIGZvciBjb29raWUgcGFyc2luZ1xuICAgKi9cbiAgc3RhdGljIHBhcnNlKHN0ciwgb3B0aW9ucykge1xuICAgIHJldHVybiBwYXJzZShzdHIsIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBEb2VzIHRoZSByZXZlcnNlIG9mIHtAbGluayBDb29raWUudG9KU09OfS5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogQW55IERhdGUgcHJvcGVydGllcyAoc3VjaCBhcyAuZXhwaXJlcywgLmNyZWF0aW9uLCBhbmQgLmxhc3RBY2Nlc3NlZCkgYXJlIHBhcnNlZCB2aWEgRGF0ZS5wYXJzZSwgbm90IHRvdWdoLWNvb2tpZSdzIHBhcnNlRGF0ZSwgc2luY2UgSVNPIHRpbWVzdGFtcHMgYXJlIGJlaW5nIGhhbmRsZWQgYXQgdGhpcyBsYXllci5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgXG4gICAqIGNvbnN0IGpzb24gPSBKU09OLnN0cmluZ2lmeSh7XG4gICAqICAga2V5OiAnYWxwaGEnLFxuICAgKiAgIHZhbHVlOiAnYmV0YScsXG4gICAqICAgZG9tYWluOiAnZXhhbXBsZS5jb20nLFxuICAgKiAgIHBhdGg6ICcvZm9vJyxcbiAgICogICBleHBpcmVzOiAnMjAzOC0wMS0xOVQwMzoxNDowNy4wMDBaJyxcbiAgICogfSlcbiAgICogY29uc3QgY29va2llID0gQ29va2llLmZyb21KU09OKGpzb24pXG4gICAqIGNvb2tpZS5rZXkgPT09ICdhbHBoYSdcbiAgICogY29va2llLnZhbHVlID09PSAnYmV0YSdcbiAgICogY29va2llLmRvbWFpbiA9PT0gJ2V4YW1wbGUuY29tJ1xuICAgKiBjb29raWUucGF0aCA9PT0gJy9mb28nXG4gICAqIGNvb2tpZS5leHBpcmVzID09PSBuZXcgRGF0ZShEYXRlLnBhcnNlKCcyMDM4LTAxLTE5VDAzOjE0OjA3LjAwMFonKSlcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBzdHIgLSBBbiB1bnBhcnNlZCBKU09OIHN0cmluZyBvciBhIHZhbHVlIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBwYXJzZWQgYXMgSlNPTlxuICAgKi9cbiAgc3RhdGljIGZyb21KU09OKHN0cikge1xuICAgIHJldHVybiBmcm9tSlNPTihzdHIpO1xuICB9XG59O1xuX0Nvb2tpZS5jb29raWVzQ3JlYXRlZCA9IDA7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5fQ29va2llLnNhbWVTaXRlTGV2ZWwgPSB7XG4gIHN0cmljdDogMyxcbiAgbGF4OiAyLFxuICBub25lOiAxXG59O1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuX0Nvb2tpZS5zYW1lU2l0ZUNhbm9uaWNhbCA9IHtcbiAgc3RyaWN0OiBcIlN0cmljdFwiLFxuICBsYXg6IFwiTGF4XCJcbn07XG4vKipcbiAqIENvb2tpZSBwcm9wZXJ0aWVzIHRoYXQgd2lsbCBiZSBzZXJpYWxpemVkIHdoZW4gdXNpbmcge0BsaW5rIENvb2tpZS5mcm9tSlNPTn0gYW5kIHtAbGluayBDb29raWUudG9KU09OfS5cbiAqIEBwdWJsaWNcbiAqL1xuX0Nvb2tpZS5zZXJpYWxpemFibGVQcm9wZXJ0aWVzID0gW1xuICBcImtleVwiLFxuICBcInZhbHVlXCIsXG4gIFwiZXhwaXJlc1wiLFxuICBcIm1heEFnZVwiLFxuICBcImRvbWFpblwiLFxuICBcInBhdGhcIixcbiAgXCJzZWN1cmVcIixcbiAgXCJodHRwT25seVwiLFxuICBcImV4dGVuc2lvbnNcIixcbiAgXCJob3N0T25seVwiLFxuICBcInBhdGhJc0RlZmF1bHRcIixcbiAgXCJjcmVhdGlvblwiLFxuICBcImxhc3RBY2Nlc3NlZFwiLFxuICBcInNhbWVTaXRlXCJcbl07XG52YXIgQ29va2llID0gX0Nvb2tpZTtcblxuLy8gbGliL2Nvb2tpZS9jb29raWVDb21wYXJlLnRzXG52YXIgTUFYX1RJTUUgPSAyMTQ3NDgzNjQ3ZTM7XG5mdW5jdGlvbiBjb29raWVDb21wYXJlKGEsIGIpIHtcbiAgbGV0IGNtcDtcbiAgY29uc3QgYVBhdGhMZW4gPSBhLnBhdGggPyBhLnBhdGgubGVuZ3RoIDogMDtcbiAgY29uc3QgYlBhdGhMZW4gPSBiLnBhdGggPyBiLnBhdGgubGVuZ3RoIDogMDtcbiAgY21wID0gYlBhdGhMZW4gLSBhUGF0aExlbjtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cbiAgY29uc3QgYVRpbWUgPSBhLmNyZWF0aW9uICYmIGEuY3JlYXRpb24gaW5zdGFuY2VvZiBEYXRlID8gYS5jcmVhdGlvbi5nZXRUaW1lKCkgOiBNQVhfVElNRTtcbiAgY29uc3QgYlRpbWUgPSBiLmNyZWF0aW9uICYmIGIuY3JlYXRpb24gaW5zdGFuY2VvZiBEYXRlID8gYi5jcmVhdGlvbi5nZXRUaW1lKCkgOiBNQVhfVElNRTtcbiAgY21wID0gYVRpbWUgLSBiVGltZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cbiAgY21wID0gKGEuY3JlYXRpb25JbmRleCB8fCAwKSAtIChiLmNyZWF0aW9uSW5kZXggfHwgMCk7XG4gIHJldHVybiBjbXA7XG59XG5cbi8vIGxpYi9jb29raWUvZGVmYXVsdFBhdGgudHNcbmZ1bmN0aW9uIGRlZmF1bHRQYXRoKHBhdGgpIHtcbiAgaWYgKCFwYXRoIHx8IHBhdGguc2xpY2UoMCwgMSkgIT09IFwiL1wiKSB7XG4gICAgcmV0dXJuIFwiL1wiO1xuICB9XG4gIGlmIChwYXRoID09PSBcIi9cIikge1xuICAgIHJldHVybiBwYXRoO1xuICB9XG4gIGNvbnN0IHJpZ2h0U2xhc2ggPSBwYXRoLmxhc3RJbmRleE9mKFwiL1wiKTtcbiAgaWYgKHJpZ2h0U2xhc2ggPT09IDApIHtcbiAgICByZXR1cm4gXCIvXCI7XG4gIH1cbiAgcmV0dXJuIHBhdGguc2xpY2UoMCwgcmlnaHRTbGFzaCk7XG59XG5cbi8vIGxpYi9jb29raWUvZG9tYWluTWF0Y2gudHNcbnZhciBJUF9SRUdFWF9MT1dFUkNBU0UgPSAvKD86Xig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV1cXGR8XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV1cXGR8XFxkKSl7M30kKXwoPzpeKD86KD86W2EtZlxcZF17MSw0fTopezd9KD86W2EtZlxcZF17MSw0fXw6KXwoPzpbYS1mXFxkXXsxLDR9Oil7Nn0oPzooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldXFxkfFxcZCkoPzpcXC4oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldXFxkfFxcZCkpezN9fDpbYS1mXFxkXXsxLDR9fDopfCg/OlthLWZcXGRdezEsNH06KXs1fSg/OjooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldXFxkfFxcZCkoPzpcXC4oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldXFxkfFxcZCkpezN9fCg/OjpbYS1mXFxkXXsxLDR9KXsxLDJ9fDopfCg/OlthLWZcXGRdezEsNH06KXs0fSg/Oig/OjpbYS1mXFxkXXsxLDR9KXswLDF9Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV1cXGR8XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV1cXGR8XFxkKSl7M318KD86OlthLWZcXGRdezEsNH0pezEsM318Oil8KD86W2EtZlxcZF17MSw0fTopezN9KD86KD86OlthLWZcXGRdezEsNH0pezAsMn06KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XVxcZHxcXGQpKD86XFwuKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XVxcZHxcXGQpKXszfXwoPzo6W2EtZlxcZF17MSw0fSl7MSw0fXw6KXwoPzpbYS1mXFxkXXsxLDR9Oil7Mn0oPzooPzo6W2EtZlxcZF17MSw0fSl7MCwzfTooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldXFxkfFxcZCkoPzpcXC4oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldXFxkfFxcZCkpezN9fCg/OjpbYS1mXFxkXXsxLDR9KXsxLDV9fDopfCg/OlthLWZcXGRdezEsNH06KXsxfSg/Oig/OjpbYS1mXFxkXXsxLDR9KXswLDR9Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV1cXGR8XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV1cXGR8XFxkKSl7M318KD86OlthLWZcXGRdezEsNH0pezEsNn18Oil8KD86Oig/Oig/OjpbYS1mXFxkXXsxLDR9KXswLDV9Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV1cXGR8XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV1cXGR8XFxkKSl7M318KD86OlthLWZcXGRdezEsNH0pezEsN318OikpKSQpLztcbmZ1bmN0aW9uIGRvbWFpbk1hdGNoKGRvbWFpbiwgY29va2llRG9tYWluLCBjYW5vbmljYWxpemUpIHtcbiAgaWYgKGRvbWFpbiA9PSBudWxsIHx8IGNvb2tpZURvbWFpbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBsZXQgX3N0cjtcbiAgbGV0IF9kb21TdHI7XG4gIGlmIChjYW5vbmljYWxpemUgIT09IGZhbHNlKSB7XG4gICAgX3N0ciA9IGNhbm9uaWNhbERvbWFpbihkb21haW4pO1xuICAgIF9kb21TdHIgPSBjYW5vbmljYWxEb21haW4oY29va2llRG9tYWluKTtcbiAgfSBlbHNlIHtcbiAgICBfc3RyID0gZG9tYWluO1xuICAgIF9kb21TdHIgPSBjb29raWVEb21haW47XG4gIH1cbiAgaWYgKF9zdHIgPT0gbnVsbCB8fCBfZG9tU3RyID09IG51bGwpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGlmIChfc3RyID09IF9kb21TdHIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBpZHggPSBfc3RyLmxhc3RJbmRleE9mKF9kb21TdHIpO1xuICBpZiAoaWR4IDw9IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKF9zdHIubGVuZ3RoICE9PSBfZG9tU3RyLmxlbmd0aCArIGlkeCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoX3N0ci5zdWJzdHJpbmcoaWR4IC0gMSwgaWR4KSAhPT0gXCIuXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuICFJUF9SRUdFWF9MT1dFUkNBU0UudGVzdChfc3RyKTtcbn1cblxuLy8gbGliL2Nvb2tpZS9zZWN1cmVDb250ZXh0LnRzXG5mdW5jdGlvbiBpc0xvb3BiYWNrVjQoYWRkcmVzcykge1xuICBjb25zdCBvY3RldHMgPSBhZGRyZXNzLnNwbGl0KFwiLlwiKTtcbiAgcmV0dXJuIG9jdGV0cy5sZW5ndGggPT09IDQgJiYgb2N0ZXRzWzBdICE9PSB2b2lkIDAgJiYgcGFyc2VJbnQob2N0ZXRzWzBdLCAxMCkgPT09IDEyNztcbn1cbmZ1bmN0aW9uIGlzTG9vcGJhY2tWNihhZGRyZXNzKSB7XG4gIHJldHVybiBhZGRyZXNzID09PSBcIjo6MVwiO1xufVxuZnVuY3Rpb24gaXNOb3JtYWxpemVkTG9jYWxob3N0VExEKGxvd2VySG9zdCkge1xuICByZXR1cm4gbG93ZXJIb3N0LmVuZHNXaXRoKFwiLmxvY2FsaG9zdFwiKTtcbn1cbmZ1bmN0aW9uIGlzTG9jYWxIb3N0bmFtZShob3N0KSB7XG4gIGNvbnN0IGxvd2VySG9zdCA9IGhvc3QudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIGxvd2VySG9zdCA9PT0gXCJsb2NhbGhvc3RcIiB8fCBpc05vcm1hbGl6ZWRMb2NhbGhvc3RUTEQobG93ZXJIb3N0KTtcbn1cbmZ1bmN0aW9uIGhvc3ROb0JyYWNrZXRzKGhvc3QpIHtcbiAgaWYgKGhvc3QubGVuZ3RoID49IDIgJiYgaG9zdC5zdGFydHNXaXRoKFwiW1wiKSAmJiBob3N0LmVuZHNXaXRoKFwiXVwiKSkge1xuICAgIHJldHVybiBob3N0LnN1YnN0cmluZygxLCBob3N0Lmxlbmd0aCAtIDEpO1xuICB9XG4gIHJldHVybiBob3N0O1xufVxuZnVuY3Rpb24gaXNQb3RlbnRpYWxseVRydXN0d29ydGh5KGlucHV0VXJsLCBhbGxvd1NlY3VyZU9uTG9jYWwgPSB0cnVlKSB7XG4gIGxldCB1cmw7XG4gIGlmICh0eXBlb2YgaW5wdXRVcmwgPT09IFwic3RyaW5nXCIpIHtcbiAgICB0cnkge1xuICAgICAgdXJsID0gbmV3IFVSTChpbnB1dFVybCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHVybCA9IGlucHV0VXJsO1xuICB9XG4gIGNvbnN0IHNjaGVtZSA9IHVybC5wcm90b2NvbC5yZXBsYWNlKFwiOlwiLCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICBjb25zdCBob3N0bmFtZSA9IGhvc3ROb0JyYWNrZXRzKHVybC5ob3N0bmFtZSkucmVwbGFjZSgvXFwuKyQvLCBcIlwiKTtcbiAgaWYgKHNjaGVtZSA9PT0gXCJodHRwc1wiIHx8IHNjaGVtZSA9PT0gXCJ3c3NcIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICghYWxsb3dTZWN1cmVPbkxvY2FsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChJUF9WNF9SRUdFWF9PQkpFQ1QudGVzdChob3N0bmFtZSkpIHtcbiAgICByZXR1cm4gaXNMb29wYmFja1Y0KGhvc3RuYW1lKTtcbiAgfVxuICBpZiAoSVBfVjZfUkVHRVhfT0JKRUNULnRlc3QoaG9zdG5hbWUpKSB7XG4gICAgcmV0dXJuIGlzTG9vcGJhY2tWNihob3N0bmFtZSk7XG4gIH1cbiAgcmV0dXJuIGlzTG9jYWxIb3N0bmFtZShob3N0bmFtZSk7XG59XG5cbi8vIGxpYi9jb29raWUvY29va2llSmFyLnRzXG52YXIgZGVmYXVsdFNldENvb2tpZU9wdGlvbnMgPSB7XG4gIGxvb3NlOiBmYWxzZSxcbiAgc2FtZVNpdGVDb250ZXh0OiB2b2lkIDAsXG4gIGlnbm9yZUVycm9yOiBmYWxzZSxcbiAgaHR0cDogdHJ1ZVxufTtcbnZhciBkZWZhdWx0R2V0Q29va2llT3B0aW9ucyA9IHtcbiAgaHR0cDogdHJ1ZSxcbiAgZXhwaXJlOiB0cnVlLFxuICBhbGxQYXRoczogZmFsc2UsXG4gIHNhbWVTaXRlQ29udGV4dDogdm9pZCAwLFxuICBzb3J0OiB2b2lkIDBcbn07XG52YXIgU0FNRV9TSVRFX0NPTlRFWFRfVkFMX0VSUiA9ICdJbnZhbGlkIHNhbWVTaXRlQ29udGV4dCBvcHRpb24gZm9yIGdldENvb2tpZXMoKTsgZXhwZWN0ZWQgb25lIG9mIFwic3RyaWN0XCIsIFwibGF4XCIsIG9yIFwibm9uZVwiJztcbmZ1bmN0aW9uIGdldENvb2tpZUNvbnRleHQodXJsKSB7XG4gIGlmICh1cmwgJiYgdHlwZW9mIHVybCA9PT0gXCJvYmplY3RcIiAmJiBcImhvc3RuYW1lXCIgaW4gdXJsICYmIHR5cGVvZiB1cmwuaG9zdG5hbWUgPT09IFwic3RyaW5nXCIgJiYgXCJwYXRobmFtZVwiIGluIHVybCAmJiB0eXBlb2YgdXJsLnBhdGhuYW1lID09PSBcInN0cmluZ1wiICYmIFwicHJvdG9jb2xcIiBpbiB1cmwgJiYgdHlwZW9mIHVybC5wcm90b2NvbCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiB7XG4gICAgICBob3N0bmFtZTogdXJsLmhvc3RuYW1lLFxuICAgICAgcGF0aG5hbWU6IHVybC5wYXRobmFtZSxcbiAgICAgIHByb3RvY29sOiB1cmwucHJvdG9jb2xcbiAgICB9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiB1cmwgPT09IFwic3RyaW5nXCIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBVUkwoZGVjb2RlVVJJKHVybCkpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIG5ldyBVUkwodXJsKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFBhcmFtZXRlckVycm9yKFwiYHVybGAgYXJndW1lbnQgaXMgbm90IGEgc3RyaW5nIG9yIFVSTC5cIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGNoZWNrU2FtZVNpdGVDb250ZXh0KHZhbHVlKSB7XG4gIGNvbnN0IGNvbnRleHQgPSBTdHJpbmcodmFsdWUpLnRvTG93ZXJDYXNlKCk7XG4gIGlmIChjb250ZXh0ID09PSBcIm5vbmVcIiB8fCBjb250ZXh0ID09PSBcImxheFwiIHx8IGNvbnRleHQgPT09IFwic3RyaWN0XCIpIHtcbiAgICByZXR1cm4gY29udGV4dDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG59XG5mdW5jdGlvbiBpc1NlY3VyZVByZWZpeENvbmRpdGlvbk1ldChjb29raWUpIHtcbiAgY29uc3Qgc3RhcnRzV2l0aFNlY3VyZVByZWZpeCA9IHR5cGVvZiBjb29raWUua2V5ID09PSBcInN0cmluZ1wiICYmIGNvb2tpZS5rZXkuc3RhcnRzV2l0aChcIl9fU2VjdXJlLVwiKTtcbiAgcmV0dXJuICFzdGFydHNXaXRoU2VjdXJlUHJlZml4IHx8IGNvb2tpZS5zZWN1cmU7XG59XG5mdW5jdGlvbiBpc0hvc3RQcmVmaXhDb25kaXRpb25NZXQoY29va2llKSB7XG4gIGNvbnN0IHN0YXJ0c1dpdGhIb3N0UHJlZml4ID0gdHlwZW9mIGNvb2tpZS5rZXkgPT09IFwic3RyaW5nXCIgJiYgY29va2llLmtleS5zdGFydHNXaXRoKFwiX19Ib3N0LVwiKTtcbiAgcmV0dXJuICFzdGFydHNXaXRoSG9zdFByZWZpeCB8fCBCb29sZWFuKFxuICAgIGNvb2tpZS5zZWN1cmUgJiYgY29va2llLmhvc3RPbmx5ICYmIGNvb2tpZS5wYXRoICE9IG51bGwgJiYgY29va2llLnBhdGggPT09IFwiL1wiXG4gICk7XG59XG5mdW5jdGlvbiBnZXROb3JtYWxpemVkUHJlZml4U2VjdXJpdHkocHJlZml4U2VjdXJpdHkpIHtcbiAgY29uc3Qgbm9ybWFsaXplZFByZWZpeFNlY3VyaXR5ID0gcHJlZml4U2VjdXJpdHkudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoIChub3JtYWxpemVkUHJlZml4U2VjdXJpdHkpIHtcbiAgICBjYXNlIFByZWZpeFNlY3VyaXR5RW51bS5TVFJJQ1Q6XG4gICAgY2FzZSBQcmVmaXhTZWN1cml0eUVudW0uU0lMRU5UOlxuICAgIGNhc2UgUHJlZml4U2VjdXJpdHlFbnVtLkRJU0FCTEVEOlxuICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRQcmVmaXhTZWN1cml0eTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFByZWZpeFNlY3VyaXR5RW51bS5TSUxFTlQ7XG4gIH1cbn1cbnZhciBDb29raWVKYXIgPSBjbGFzcyBfQ29va2llSmFyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYENvb2tpZUphcmAgaW5zdGFuY2UuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIC0gSWYgYSBjdXN0b20gc3RvcmUgaXMgbm90IHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3IsIGFuIGluLW1lbW9yeSBzdG9yZSAoe0BsaW5rIE1lbW9yeUNvb2tpZVN0b3JlfSB3aWxsIGJlIGNyZWF0ZWQgYW5kIHVzZWQuXG4gICAqIC0gSWYgYSBib29sZWFuIHZhbHVlIGlzIHBhc3NlZCBhcyB0aGUgYG9wdGlvbnNgIHBhcmFtZXRlciwgdGhpcyBpcyBlcXVpdmFsZW50IHRvIHBhc3NpbmcgYHsgcmVqZWN0UHVibGljU3VmZml4ZXM6IDx2YWx1ZT4gfWBcbiAgICpcbiAgICogQHBhcmFtIHN0b3JlIC0gYSBjdXN0b20ge0BsaW5rIFN0b3JlfSBpbXBsZW1lbnRhdGlvbiAoZGVmYXVsdHMgdG8ge0BsaW5rIE1lbW9yeUNvb2tpZVN0b3JlfSlcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBjb25maWd1cmVzIGhvdyBjb29raWVzIGFyZSBwcm9jZXNzZWQgYnkgdGhlIGNvb2tpZSBqYXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKHN0b3JlLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcImJvb2xlYW5cIikge1xuICAgICAgb3B0aW9ucyA9IHsgcmVqZWN0UHVibGljU3VmZml4ZXM6IG9wdGlvbnMgfTtcbiAgICB9XG4gICAgdGhpcy5yZWplY3RQdWJsaWNTdWZmaXhlcyA9IG9wdGlvbnM/LnJlamVjdFB1YmxpY1N1ZmZpeGVzID8/IHRydWU7XG4gICAgdGhpcy5lbmFibGVMb29zZU1vZGUgPSBvcHRpb25zPy5sb29zZU1vZGUgPz8gZmFsc2U7XG4gICAgdGhpcy5hbGxvd1NwZWNpYWxVc2VEb21haW4gPSBvcHRpb25zPy5hbGxvd1NwZWNpYWxVc2VEb21haW4gPz8gdHJ1ZTtcbiAgICB0aGlzLmFsbG93U2VjdXJlT25Mb2NhbCA9IG9wdGlvbnM/LmFsbG93U2VjdXJlT25Mb2NhbCA/PyB0cnVlO1xuICAgIHRoaXMucHJlZml4U2VjdXJpdHkgPSBnZXROb3JtYWxpemVkUHJlZml4U2VjdXJpdHkoXG4gICAgICBvcHRpb25zPy5wcmVmaXhTZWN1cml0eSA/PyBcInNpbGVudFwiXG4gICAgKTtcbiAgICB0aGlzLnN0b3JlID0gc3RvcmUgPz8gbmV3IE1lbW9yeUNvb2tpZVN0b3JlKCk7XG4gIH1cbiAgY2FsbFN5bmMoZm4pIHtcbiAgICBpZiAoIXRoaXMuc3RvcmUuc3luY2hyb25vdXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJDb29raWVKYXIgc3RvcmUgaXMgbm90IHN5bmNocm9ub3VzOyB1c2UgYXN5bmMgQVBJIGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGxldCBzeW5jRXJyID0gbnVsbDtcbiAgICBsZXQgc3luY1Jlc3VsdCA9IHZvaWQgMDtcbiAgICB0cnkge1xuICAgICAgZm4uY2FsbCh0aGlzLCAoZXJyb3IsIHJlc3VsdCkgPT4ge1xuICAgICAgICBzeW5jRXJyID0gZXJyb3I7XG4gICAgICAgIHN5bmNSZXN1bHQgPSByZXN1bHQ7XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHN5bmNFcnIgPSBlcnI7XG4gICAgfVxuICAgIGlmIChzeW5jRXJyKSB0aHJvdyBzeW5jRXJyO1xuICAgIHJldHVybiBzeW5jUmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWwgTm8gZG9jIGJlY2F1c2UgdGhpcyBpcyB0aGUgb3ZlcmxvYWQgaW1wbGVtZW50YXRpb25cbiAgICovXG4gIHNldENvb2tpZShjb29raWUsIHVybCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHZvaWQgMDtcbiAgICB9XG4gICAgY29uc3QgcHJvbWlzZUNhbGxiYWNrID0gY3JlYXRlUHJvbWlzZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgICBjb25zdCBjYiA9IHByb21pc2VDYWxsYmFjay5jYWxsYmFjaztcbiAgICBsZXQgY29udGV4dDtcbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiB1cmwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFsaWRhdGUoXG4gICAgICAgICAgaXNOb25FbXB0eVN0cmluZyh1cmwpLFxuICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgIHNhZmVUb1N0cmluZyhvcHRpb25zKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29udGV4dCA9IGdldENvb2tpZUNvbnRleHQodXJsKTtcbiAgICAgIGlmICh0eXBlb2YgdXJsID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2VDYWxsYmFjay5yZWplY3QobmV3IEVycm9yKFwiTm8gVVJMIHdhcyBzcGVjaWZpZWRcIikpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgb3B0aW9ucyA9IGRlZmF1bHRTZXRDb29raWVPcHRpb25zO1xuICAgICAgfVxuICAgICAgdmFsaWRhdGUodHlwZW9mIGNiID09PSBcImZ1bmN0aW9uXCIsIGNiKTtcbiAgICAgIGlmICghaXNOb25FbXB0eVN0cmluZyhjb29raWUpICYmICFpc09iamVjdChjb29raWUpICYmIGNvb2tpZSBpbnN0YW5jZW9mIFN0cmluZyAmJiBjb29raWUubGVuZ3RoID09IDApIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2VDYWxsYmFjay5yZXNvbHZlKHZvaWQgMCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZUNhbGxiYWNrLnJlamVjdChlcnIpO1xuICAgIH1cbiAgICBjb25zdCBob3N0ID0gY2Fub25pY2FsRG9tYWluKGNvbnRleHQuaG9zdG5hbWUpID8/IG51bGw7XG4gICAgY29uc3QgbG9vc2UgPSBvcHRpb25zPy5sb29zZSB8fCB0aGlzLmVuYWJsZUxvb3NlTW9kZTtcbiAgICBsZXQgc2FtZVNpdGVDb250ZXh0ID0gbnVsbDtcbiAgICBpZiAob3B0aW9ucz8uc2FtZVNpdGVDb250ZXh0KSB7XG4gICAgICBzYW1lU2l0ZUNvbnRleHQgPSBjaGVja1NhbWVTaXRlQ29udGV4dChvcHRpb25zLnNhbWVTaXRlQ29udGV4dCk7XG4gICAgICBpZiAoIXNhbWVTaXRlQ29udGV4dCkge1xuICAgICAgICByZXR1cm4gcHJvbWlzZUNhbGxiYWNrLnJlamVjdChuZXcgRXJyb3IoU0FNRV9TSVRFX0NPTlRFWFRfVkFMX0VSUikpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvb2tpZSA9PT0gXCJzdHJpbmdcIiB8fCBjb29raWUgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgIGNvbnN0IHBhcnNlZENvb2tpZSA9IENvb2tpZS5wYXJzZShjb29raWUudG9TdHJpbmcoKSwgeyBsb29zZSB9KTtcbiAgICAgIGlmICghcGFyc2VkQ29va2llKSB7XG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcIkNvb2tpZSBmYWlsZWQgdG8gcGFyc2VcIik7XG4gICAgICAgIHJldHVybiBvcHRpb25zPy5pZ25vcmVFcnJvciA/IHByb21pc2VDYWxsYmFjay5yZXNvbHZlKHZvaWQgMCkgOiBwcm9taXNlQ2FsbGJhY2sucmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgICBjb29raWUgPSBwYXJzZWRDb29raWU7XG4gICAgfSBlbHNlIGlmICghKGNvb2tpZSBpbnN0YW5jZW9mIENvb2tpZSkpIHtcbiAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgXCJGaXJzdCBhcmd1bWVudCB0byBzZXRDb29raWUgbXVzdCBiZSBhIENvb2tpZSBvYmplY3Qgb3Igc3RyaW5nXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gb3B0aW9ucz8uaWdub3JlRXJyb3IgPyBwcm9taXNlQ2FsbGJhY2sucmVzb2x2ZSh2b2lkIDApIDogcHJvbWlzZUNhbGxiYWNrLnJlamVjdChlcnIpO1xuICAgIH1cbiAgICBjb25zdCBub3cgPSBvcHRpb25zPy5ub3cgfHwgLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgaWYgKHRoaXMucmVqZWN0UHVibGljU3VmZml4ZXMgJiYgY29va2llLmRvbWFpbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY2RvbWFpbiA9IGNvb2tpZS5jZG9tYWluKCk7XG4gICAgICAgIGNvbnN0IHN1ZmZpeCA9IHR5cGVvZiBjZG9tYWluID09PSBcInN0cmluZ1wiID8gZ2V0UHVibGljU3VmZml4KGNkb21haW4sIHtcbiAgICAgICAgICBhbGxvd1NwZWNpYWxVc2VEb21haW46IHRoaXMuYWxsb3dTcGVjaWFsVXNlRG9tYWluLFxuICAgICAgICAgIGlnbm9yZUVycm9yOiBvcHRpb25zPy5pZ25vcmVFcnJvclxuICAgICAgICB9KSA6IG51bGw7XG4gICAgICAgIGlmIChzdWZmaXggPT0gbnVsbCAmJiAhSVBfVjZfUkVHRVhfT0JKRUNULnRlc3QoY29va2llLmRvbWFpbikpIHtcbiAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXCJDb29raWUgaGFzIGRvbWFpbiBzZXQgdG8gYSBwdWJsaWMgc3VmZml4XCIpO1xuICAgICAgICAgIHJldHVybiBvcHRpb25zPy5pZ25vcmVFcnJvciA/IHByb21pc2VDYWxsYmFjay5yZXNvbHZlKHZvaWQgMCkgOiBwcm9taXNlQ2FsbGJhY2sucmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gb3B0aW9ucz8uaWdub3JlRXJyb3IgPyBwcm9taXNlQ2FsbGJhY2sucmVzb2x2ZSh2b2lkIDApIDogKFxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50XG4gICAgICAgICAgcHJvbWlzZUNhbGxiYWNrLnJlamVjdChlcnIpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb29raWUuZG9tYWluKSB7XG4gICAgICBpZiAoIWRvbWFpbk1hdGNoKGhvc3QgPz8gdm9pZCAwLCBjb29raWUuY2RvbWFpbigpID8/IHZvaWQgMCwgZmFsc2UpKSB7XG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICBgQ29va2llIG5vdCBpbiB0aGlzIGhvc3QncyBkb21haW4uIENvb2tpZToke2Nvb2tpZS5jZG9tYWluKCkgPz8gXCJudWxsXCJ9IFJlcXVlc3Q6JHtob3N0ID8/IFwibnVsbFwifWBcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM/Lmlnbm9yZUVycm9yID8gcHJvbWlzZUNhbGxiYWNrLnJlc29sdmUodm9pZCAwKSA6IHByb21pc2VDYWxsYmFjay5yZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb29raWUuaG9zdE9ubHkgPT0gbnVsbCkge1xuICAgICAgICBjb29raWUuaG9zdE9ubHkgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29va2llLmhvc3RPbmx5ID0gdHJ1ZTtcbiAgICAgIGNvb2tpZS5kb21haW4gPSBob3N0O1xuICAgIH1cbiAgICBpZiAoIWNvb2tpZS5wYXRoIHx8IGNvb2tpZS5wYXRoWzBdICE9PSBcIi9cIikge1xuICAgICAgY29va2llLnBhdGggPSBkZWZhdWx0UGF0aChjb250ZXh0LnBhdGhuYW1lKTtcbiAgICAgIGNvb2tpZS5wYXRoSXNEZWZhdWx0ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnM/Lmh0dHAgPT09IGZhbHNlICYmIGNvb2tpZS5odHRwT25seSkge1xuICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFwiQ29va2llIGlzIEh0dHBPbmx5IGFuZCB0aGlzIGlzbid0IGFuIEhUVFAgQVBJXCIpO1xuICAgICAgcmV0dXJuIG9wdGlvbnMuaWdub3JlRXJyb3IgPyBwcm9taXNlQ2FsbGJhY2sucmVzb2x2ZSh2b2lkIDApIDogcHJvbWlzZUNhbGxiYWNrLnJlamVjdChlcnIpO1xuICAgIH1cbiAgICBpZiAoY29va2llLnNhbWVTaXRlICE9PSBcIm5vbmVcIiAmJiBjb29raWUuc2FtZVNpdGUgIT09IHZvaWQgMCAmJiBzYW1lU2l0ZUNvbnRleHQpIHtcbiAgICAgIGlmIChzYW1lU2l0ZUNvbnRleHQgPT09IFwibm9uZVwiKSB7XG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICBcIkNvb2tpZSBpcyBTYW1lU2l0ZSBidXQgdGhpcyBpcyBhIGNyb3NzLW9yaWdpbiByZXF1ZXN0XCJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM/Lmlnbm9yZUVycm9yID8gcHJvbWlzZUNhbGxiYWNrLnJlc29sdmUodm9pZCAwKSA6IHByb21pc2VDYWxsYmFjay5yZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaWdub3JlRXJyb3JGb3JQcmVmaXhTZWN1cml0eSA9IHRoaXMucHJlZml4U2VjdXJpdHkgPT09IFByZWZpeFNlY3VyaXR5RW51bS5TSUxFTlQ7XG4gICAgY29uc3QgcHJlZml4U2VjdXJpdHlEaXNhYmxlZCA9IHRoaXMucHJlZml4U2VjdXJpdHkgPT09IFByZWZpeFNlY3VyaXR5RW51bS5ESVNBQkxFRDtcbiAgICBpZiAoIXByZWZpeFNlY3VyaXR5RGlzYWJsZWQpIHtcbiAgICAgIGxldCBlcnJvckZvdW5kID0gZmFsc2U7XG4gICAgICBsZXQgZXJyb3JNc2c7XG4gICAgICBpZiAoIWlzU2VjdXJlUHJlZml4Q29uZGl0aW9uTWV0KGNvb2tpZSkpIHtcbiAgICAgICAgZXJyb3JGb3VuZCA9IHRydWU7XG4gICAgICAgIGVycm9yTXNnID0gXCJDb29raWUgaGFzIF9fU2VjdXJlIHByZWZpeCBidXQgU2VjdXJlIGF0dHJpYnV0ZSBpcyBub3Qgc2V0XCI7XG4gICAgICB9IGVsc2UgaWYgKCFpc0hvc3RQcmVmaXhDb25kaXRpb25NZXQoY29va2llKSkge1xuICAgICAgICBlcnJvckZvdW5kID0gdHJ1ZTtcbiAgICAgICAgZXJyb3JNc2cgPSBcIkNvb2tpZSBoYXMgX19Ib3N0IHByZWZpeCBidXQgZWl0aGVyIFNlY3VyZSBvciBIb3N0T25seSBhdHRyaWJ1dGUgaXMgbm90IHNldCBvciBQYXRoIGlzIG5vdCAnLydcIjtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvckZvdW5kKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zPy5pZ25vcmVFcnJvciB8fCBpZ25vcmVFcnJvckZvclByZWZpeFNlY3VyaXR5ID8gcHJvbWlzZUNhbGxiYWNrLnJlc29sdmUodm9pZCAwKSA6IHByb21pc2VDYWxsYmFjay5yZWplY3QobmV3IEVycm9yKGVycm9yTXNnKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHN0b3JlID0gdGhpcy5zdG9yZTtcbiAgICBpZiAoIXN0b3JlLnVwZGF0ZUNvb2tpZSkge1xuICAgICAgc3RvcmUudXBkYXRlQ29va2llID0gYXN5bmMgZnVuY3Rpb24oX29sZENvb2tpZSwgbmV3Q29va2llLCBjYjIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHV0Q29va2llKG5ld0Nvb2tpZSkudGhlbihcbiAgICAgICAgICAoKSA9PiBjYjI/LihudWxsKSxcbiAgICAgICAgICAoZXJyb3IpID0+IGNiMj8uKGVycm9yKVxuICAgICAgICApO1xuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgd2l0aENvb2tpZSA9IGZ1bmN0aW9uIHdpdGhDb29raWUyKGVyciwgb2xkQ29va2llKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGNiKGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5leHQgPSBmdW5jdGlvbihlcnIyKSB7XG4gICAgICAgIGlmIChlcnIyKSB7XG4gICAgICAgICAgY2IoZXJyMik7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvb2tpZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGNiKG51bGwsIHZvaWQgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2IobnVsbCwgY29va2llKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChvbGRDb29raWUpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgXCJodHRwXCIgaW4gb3B0aW9ucyAmJiBvcHRpb25zLmh0dHAgPT09IGZhbHNlICYmIG9sZENvb2tpZS5odHRwT25seSkge1xuICAgICAgICAgIGVyciA9IG5ldyBFcnJvcihcIm9sZCBDb29raWUgaXMgSHR0cE9ubHkgYW5kIHRoaXMgaXNuJ3QgYW4gSFRUUCBBUElcIik7XG4gICAgICAgICAgaWYgKG9wdGlvbnMuaWdub3JlRXJyb3IpIGNiKG51bGwsIHZvaWQgMCk7XG4gICAgICAgICAgZWxzZSBjYihlcnIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29va2llIGluc3RhbmNlb2YgQ29va2llKSB7XG4gICAgICAgICAgY29va2llLmNyZWF0aW9uID0gb2xkQ29va2llLmNyZWF0aW9uO1xuICAgICAgICAgIGNvb2tpZS5jcmVhdGlvbkluZGV4ID0gb2xkQ29va2llLmNyZWF0aW9uSW5kZXg7XG4gICAgICAgICAgY29va2llLmxhc3RBY2Nlc3NlZCA9IG5vdztcbiAgICAgICAgICBzdG9yZS51cGRhdGVDb29raWUob2xkQ29va2llLCBjb29raWUsIG5leHQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY29va2llIGluc3RhbmNlb2YgQ29va2llKSB7XG4gICAgICAgICAgY29va2llLmNyZWF0aW9uID0gY29va2llLmxhc3RBY2Nlc3NlZCA9IG5vdztcbiAgICAgICAgICBzdG9yZS5wdXRDb29raWUoY29va2llLCBuZXh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgc3RvcmUuZmluZENvb2tpZShjb29raWUuZG9tYWluLCBjb29raWUucGF0aCwgY29va2llLmtleSwgd2l0aENvb2tpZSk7XG4gICAgcmV0dXJuIHByb21pc2VDYWxsYmFjay5wcm9taXNlO1xuICB9XG4gIC8qKlxuICAgKiBTeW5jaHJvbm91c2x5IGF0dGVtcHQgdG8gc2V0IHRoZSB7QGxpbmsgQ29va2llfSBpbiB0aGUge0BsaW5rIENvb2tpZUphcn0uXG4gICAqXG4gICAqIDxzdHJvbmc+Tm90ZTo8L3N0cm9uZz4gT25seSB3b3JrcyBpZiB0aGUgY29uZmlndXJlZCB7QGxpbmsgU3RvcmV9IGlzIGFsc28gc3luY2hyb25vdXMuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIC0gSWYgc3VjY2Vzc2Z1bGx5IHBlcnNpc3RlZCwgdGhlIHtAbGluayBDb29raWV9IHdpbGwgaGF2ZSB1cGRhdGVkXG4gICAqICAgICB7QGxpbmsgQ29va2llLmNyZWF0aW9ufSwge0BsaW5rIENvb2tpZS5sYXN0QWNjZXNzZWR9IGFuZCB7QGxpbmsgQ29va2llLmhvc3RPbmx5fVxuICAgKiAgICAgcHJvcGVydGllcy5cbiAgICpcbiAgICogLSBBcyBwZXIgdGhlIFJGQywgdGhlIHtAbGluayBDb29raWUuaG9zdE9ubHl9IGZsYWcgaXMgc2V0IGlmIHRoZXJlIHdhcyBubyBgRG9tYWluPXt2YWx1ZX1gXG4gICAqICAgICBhdHRyaWJ1dGUgb24gdGhlIGNvb2tpZSBzdHJpbmcuIFRoZSB7QGxpbmsgQ29va2llLmRvbWFpbn0gcHJvcGVydHkgaXMgc2V0IHRvIHRoZVxuICAgKiAgICAgZnVsbHktcXVhbGlmaWVkIGhvc3RuYW1lIG9mIGBjdXJyZW50VXJsYCBpbiB0aGlzIGNhc2UuIE1hdGNoaW5nIHRoaXMgY29va2llIHJlcXVpcmVzIGFuXG4gICAqICAgICBleGFjdCBob3N0bmFtZSBtYXRjaCAobm90IGEge0BsaW5rIGRvbWFpbk1hdGNofSBhcyBwZXIgdXN1YWwpXG4gICAqXG4gICAqIEBwYXJhbSBjb29raWUgLSBUaGUgY29va2llIG9iamVjdCBvciBjb29raWUgc3RyaW5nIHRvIHN0b3JlLiBBIHN0cmluZyB2YWx1ZSB3aWxsIGJlIHBhcnNlZCBpbnRvIGEgY29va2llIHVzaW5nIHtAbGluayBDb29raWUucGFyc2V9LlxuICAgKiBAcGFyYW0gdXJsIC0gVGhlIGRvbWFpbiB0byBzdG9yZSB0aGUgY29va2llIHdpdGguXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQ29uZmlndXJhdGlvbiBzZXR0aW5ncyB0byB1c2Ugd2hlbiBzdG9yaW5nIHRoZSBjb29raWUuXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNldENvb2tpZVN5bmMoY29va2llLCB1cmwsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzZXRDb29raWVGbiA9IG9wdGlvbnMgPyB0aGlzLnNldENvb2tpZS5iaW5kKHRoaXMsIGNvb2tpZSwgdXJsLCBvcHRpb25zKSA6IHRoaXMuc2V0Q29va2llLmJpbmQodGhpcywgY29va2llLCB1cmwpO1xuICAgIHJldHVybiB0aGlzLmNhbGxTeW5jKHNldENvb2tpZUZuKTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsIE5vIGRvYyBiZWNhdXNlIHRoaXMgaXMgdGhlIG92ZXJsb2FkIGltcGxlbWVudGF0aW9uXG4gICAqL1xuICBnZXRDb29raWVzKHVybCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IGRlZmF1bHRHZXRDb29raWVPcHRpb25zO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0gZGVmYXVsdEdldENvb2tpZU9wdGlvbnM7XG4gICAgfVxuICAgIGNvbnN0IHByb21pc2VDYWxsYmFjayA9IGNyZWF0ZVByb21pc2VDYWxsYmFjayhjYWxsYmFjayk7XG4gICAgY29uc3QgY2IgPSBwcm9taXNlQ2FsbGJhY2suY2FsbGJhY2s7XG4gICAgbGV0IGNvbnRleHQ7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YgdXJsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhbGlkYXRlKGlzTm9uRW1wdHlTdHJpbmcodXJsKSwgY2IsIHVybCk7XG4gICAgICB9XG4gICAgICBjb250ZXh0ID0gZ2V0Q29va2llQ29udGV4dCh1cmwpO1xuICAgICAgdmFsaWRhdGUoXG4gICAgICAgIGlzT2JqZWN0KG9wdGlvbnMpLFxuICAgICAgICBjYixcbiAgICAgICAgc2FmZVRvU3RyaW5nKG9wdGlvbnMpXG4gICAgICApO1xuICAgICAgdmFsaWRhdGUodHlwZW9mIGNiID09PSBcImZ1bmN0aW9uXCIsIGNiKTtcbiAgICB9IGNhdGNoIChwYXJhbWV0ZXJFcnJvcikge1xuICAgICAgcmV0dXJuIHByb21pc2VDYWxsYmFjay5yZWplY3QocGFyYW1ldGVyRXJyb3IpO1xuICAgIH1cbiAgICBjb25zdCBob3N0ID0gY2Fub25pY2FsRG9tYWluKGNvbnRleHQuaG9zdG5hbWUpO1xuICAgIGNvbnN0IHBhdGggPSBjb250ZXh0LnBhdGhuYW1lIHx8IFwiL1wiO1xuICAgIGNvbnN0IHBvdGVudGlhbGx5VHJ1c3R3b3J0aHkgPSBpc1BvdGVudGlhbGx5VHJ1c3R3b3J0aHkoXG4gICAgICB1cmwsXG4gICAgICB0aGlzLmFsbG93U2VjdXJlT25Mb2NhbFxuICAgICk7XG4gICAgbGV0IHNhbWVTaXRlTGV2ZWwgPSAwO1xuICAgIGlmIChvcHRpb25zLnNhbWVTaXRlQ29udGV4dCkge1xuICAgICAgY29uc3Qgc2FtZVNpdGVDb250ZXh0ID0gY2hlY2tTYW1lU2l0ZUNvbnRleHQob3B0aW9ucy5zYW1lU2l0ZUNvbnRleHQpO1xuICAgICAgaWYgKHNhbWVTaXRlQ29udGV4dCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlQ2FsbGJhY2sucmVqZWN0KG5ldyBFcnJvcihTQU1FX1NJVEVfQ09OVEVYVF9WQUxfRVJSKSk7XG4gICAgICB9XG4gICAgICBzYW1lU2l0ZUxldmVsID0gQ29va2llLnNhbWVTaXRlTGV2ZWxbc2FtZVNpdGVDb250ZXh0XTtcbiAgICAgIGlmICghc2FtZVNpdGVMZXZlbCkge1xuICAgICAgICByZXR1cm4gcHJvbWlzZUNhbGxiYWNrLnJlamVjdChuZXcgRXJyb3IoU0FNRV9TSVRFX0NPTlRFWFRfVkFMX0VSUikpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBodHRwID0gb3B0aW9ucy5odHRwID8/IHRydWU7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBleHBpcmVDaGVjayA9IG9wdGlvbnMuZXhwaXJlID8/IHRydWU7XG4gICAgY29uc3QgYWxsUGF0aHMgPSBvcHRpb25zLmFsbFBhdGhzID8/IGZhbHNlO1xuICAgIGNvbnN0IHN0b3JlID0gdGhpcy5zdG9yZTtcbiAgICBmdW5jdGlvbiBtYXRjaGluZ0Nvb2tpZShjKSB7XG4gICAgICBpZiAoYy5ob3N0T25seSkge1xuICAgICAgICBpZiAoYy5kb21haW4gIT0gaG9zdCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFkb21haW5NYXRjaChob3N0ID8/IHZvaWQgMCwgYy5kb21haW4gPz8gdm9pZCAwLCBmYWxzZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghYWxsUGF0aHMgJiYgdHlwZW9mIGMucGF0aCA9PT0gXCJzdHJpbmdcIiAmJiAhcGF0aE1hdGNoKHBhdGgsIGMucGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGMuc2VjdXJlICYmICFwb3RlbnRpYWxseVRydXN0d29ydGh5KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChjLmh0dHBPbmx5ICYmICFodHRwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChzYW1lU2l0ZUxldmVsKSB7XG4gICAgICAgIGxldCBjb29raWVMZXZlbDtcbiAgICAgICAgaWYgKGMuc2FtZVNpdGUgPT09IFwibGF4XCIpIHtcbiAgICAgICAgICBjb29raWVMZXZlbCA9IENvb2tpZS5zYW1lU2l0ZUxldmVsLmxheDtcbiAgICAgICAgfSBlbHNlIGlmIChjLnNhbWVTaXRlID09PSBcInN0cmljdFwiKSB7XG4gICAgICAgICAgY29va2llTGV2ZWwgPSBDb29raWUuc2FtZVNpdGVMZXZlbC5zdHJpY3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29va2llTGV2ZWwgPSBDb29raWUuc2FtZVNpdGVMZXZlbC5ub25lO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb29raWVMZXZlbCA+IHNhbWVTaXRlTGV2ZWwpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGV4cGlyeVRpbWUgPSBjLmV4cGlyeVRpbWUoKTtcbiAgICAgIGlmIChleHBpcmVDaGVjayAmJiBleHBpcnlUaW1lICE9IHZvaWQgMCAmJiBleHBpcnlUaW1lIDw9IG5vdykge1xuICAgICAgICBzdG9yZS5yZW1vdmVDb29raWUoYy5kb21haW4sIGMucGF0aCwgYy5rZXksICgpID0+IHtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBzdG9yZS5maW5kQ29va2llcyhcbiAgICAgIGhvc3QsXG4gICAgICBhbGxQYXRocyA/IG51bGwgOiBwYXRoLFxuICAgICAgdGhpcy5hbGxvd1NwZWNpYWxVc2VEb21haW4sXG4gICAgICAoZXJyLCBjb29raWVzKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBjYihlcnIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29va2llcyA9PSBudWxsKSB7XG4gICAgICAgICAgY2IobnVsbCwgW10pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb29raWVzID0gY29va2llcy5maWx0ZXIobWF0Y2hpbmdDb29raWUpO1xuICAgICAgICBpZiAoXCJzb3J0XCIgaW4gb3B0aW9ucyAmJiBvcHRpb25zLnNvcnQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgY29va2llcyA9IGNvb2tpZXMuc29ydChjb29raWVDb21wYXJlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub3cyID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICAgIGZvciAoY29uc3QgY29va2llIG9mIGNvb2tpZXMpIHtcbiAgICAgICAgICBjb29raWUubGFzdEFjY2Vzc2VkID0gbm93MjtcbiAgICAgICAgfVxuICAgICAgICBjYihudWxsLCBjb29raWVzKTtcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiBwcm9taXNlQ2FsbGJhY2sucHJvbWlzZTtcbiAgfVxuICAvKipcbiAgICogU3luY2hyb25vdXNseSByZXRyaWV2ZSB0aGUgbGlzdCBvZiBjb29raWVzIHRoYXQgY2FuIGJlIHNlbnQgaW4gYSBDb29raWUgaGVhZGVyIGZvciB0aGVcbiAgICogY3VycmVudCBVUkwuXG4gICAqXG4gICAqIDxzdHJvbmc+Tm90ZTwvc3Ryb25nPjogT25seSB3b3JrcyBpZiB0aGUgY29uZmlndXJlZCBTdG9yZSBpcyBhbHNvIHN5bmNocm9ub3VzLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiAtIFRoZSBhcnJheSBvZiBjb29raWVzIHJldHVybmVkIHdpbGwgYmUgc29ydGVkIGFjY29yZGluZyB0byB7QGxpbmsgY29va2llQ29tcGFyZX0uXG4gICAqXG4gICAqIC0gVGhlIHtAbGluayBDb29raWUubGFzdEFjY2Vzc2VkfSBwcm9wZXJ0eSB3aWxsIGJlIHVwZGF0ZWQgb24gYWxsIHJldHVybmVkIGNvb2tpZXMuXG4gICAqXG4gICAqIEBwYXJhbSB1cmwgLSBUaGUgZG9tYWluIHRvIHN0b3JlIHRoZSBjb29raWUgd2l0aC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBDb25maWd1cmF0aW9uIHNldHRpbmdzIHRvIHVzZSB3aGVuIHJldHJpZXZpbmcgdGhlIGNvb2tpZXMuXG4gICAqL1xuICBnZXRDb29raWVzU3luYyh1cmwsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5jYWxsU3luYyh0aGlzLmdldENvb2tpZXMuYmluZCh0aGlzLCB1cmwsIG9wdGlvbnMpKSA/PyBbXTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsIE5vIGRvYyBiZWNhdXNlIHRoaXMgaXMgdGhlIG92ZXJsb2FkIGltcGxlbWVudGF0aW9uXG4gICAqL1xuICBnZXRDb29raWVTdHJpbmcodXJsLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICBvcHRpb25zID0gdm9pZCAwO1xuICAgIH1cbiAgICBjb25zdCBwcm9taXNlQ2FsbGJhY2sgPSBjcmVhdGVQcm9taXNlQ2FsbGJhY2soY2FsbGJhY2spO1xuICAgIGNvbnN0IG5leHQgPSBmdW5jdGlvbihlcnIsIGNvb2tpZXMpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcHJvbWlzZUNhbGxiYWNrLmNhbGxiYWNrKGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9taXNlQ2FsbGJhY2suY2FsbGJhY2soXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBjb29raWVzPy5zb3J0KGNvb2tpZUNvbXBhcmUpLm1hcCgoYykgPT4gYy5jb29raWVTdHJpbmcoKSkuam9pbihcIjsgXCIpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmdldENvb2tpZXModXJsLCBvcHRpb25zLCBuZXh0KTtcbiAgICByZXR1cm4gcHJvbWlzZUNhbGxiYWNrLnByb21pc2U7XG4gIH1cbiAgLyoqXG4gICAqIFN5bmNocm9ub3VzIHZlcnNpb24gb2YgYC5nZXRDb29raWVTdHJpbmcoKWAuIEFjY2VwdHMgdGhlIHNhbWUgb3B0aW9ucyBhcyBgLmdldENvb2tpZXMoKWAgYnV0IHJldHVybnMgYSBzdHJpbmcgc3VpdGFibGUgZm9yIGFcbiAgICogYENvb2tpZWAgaGVhZGVyIHJhdGhlciB0aGFuIGFuIEFycmF5LlxuICAgKlxuICAgKiA8c3Ryb25nPk5vdGU8L3N0cm9uZz46IE9ubHkgd29ya3MgaWYgdGhlIGNvbmZpZ3VyZWQgU3RvcmUgaXMgYWxzbyBzeW5jaHJvbm91cy5cbiAgICpcbiAgICogQHBhcmFtIHVybCAtIFRoZSBkb21haW4gdG8gc3RvcmUgdGhlIGNvb2tpZSB3aXRoLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIENvbmZpZ3VyYXRpb24gc2V0dGluZ3MgdG8gdXNlIHdoZW4gcmV0cmlldmluZyB0aGUgY29va2llcy5cbiAgICovXG4gIGdldENvb2tpZVN0cmluZ1N5bmModXJsLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FsbFN5bmMoXG4gICAgICBvcHRpb25zID8gdGhpcy5nZXRDb29raWVTdHJpbmcuYmluZCh0aGlzLCB1cmwsIG9wdGlvbnMpIDogdGhpcy5nZXRDb29raWVTdHJpbmcuYmluZCh0aGlzLCB1cmwpXG4gICAgKSA/PyBcIlwiO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWwgTm8gZG9jIGJlY2F1c2UgdGhpcyBpcyB0aGUgb3ZlcmxvYWQgaW1wbGVtZW50YXRpb25cbiAgICovXG4gIGdldFNldENvb2tpZVN0cmluZ3ModXJsLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICBvcHRpb25zID0gdm9pZCAwO1xuICAgIH1cbiAgICBjb25zdCBwcm9taXNlQ2FsbGJhY2sgPSBjcmVhdGVQcm9taXNlQ2FsbGJhY2soXG4gICAgICBjYWxsYmFja1xuICAgICk7XG4gICAgY29uc3QgbmV4dCA9IGZ1bmN0aW9uKGVyciwgY29va2llcykge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBwcm9taXNlQ2FsbGJhY2suY2FsbGJhY2soZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb21pc2VDYWxsYmFjay5jYWxsYmFjayhcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIGNvb2tpZXM/Lm1hcCgoYykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGMudG9TdHJpbmcoKTtcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5nZXRDb29raWVzKHVybCwgb3B0aW9ucywgbmV4dCk7XG4gICAgcmV0dXJuIHByb21pc2VDYWxsYmFjay5wcm9taXNlO1xuICB9XG4gIC8qKlxuICAgKiBTeW5jaHJvbm91cyB2ZXJzaW9uIG9mIGAuZ2V0U2V0Q29va2llU3RyaW5ncygpYC4gUmV0dXJucyBhbiBhcnJheSBvZiBzdHJpbmdzIHN1aXRhYmxlIGZvciBgU2V0LUNvb2tpZWAgaGVhZGVycy5cbiAgICogQWNjZXB0cyB0aGUgc2FtZSBvcHRpb25zIGFzIGAuZ2V0Q29va2llcygpYC5cbiAgICpcbiAgICogPHN0cm9uZz5Ob3RlPC9zdHJvbmc+OiBPbmx5IHdvcmtzIGlmIHRoZSBjb25maWd1cmVkIFN0b3JlIGlzIGFsc28gc3luY2hyb25vdXMuXG4gICAqXG4gICAqIEBwYXJhbSB1cmwgLSBUaGUgZG9tYWluIHRvIHN0b3JlIHRoZSBjb29raWUgd2l0aC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBDb25maWd1cmF0aW9uIHNldHRpbmdzIHRvIHVzZSB3aGVuIHJldHJpZXZpbmcgdGhlIGNvb2tpZXMuXG4gICAqL1xuICBnZXRTZXRDb29raWVTdHJpbmdzU3luYyh1cmwsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmNhbGxTeW5jKHRoaXMuZ2V0U2V0Q29va2llU3RyaW5ncy5iaW5kKHRoaXMsIHVybCwgb3B0aW9ucykpID8/IFtdO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWwgTm8gZG9jIGJlY2F1c2UgdGhpcyBpcyB0aGUgb3ZlcmxvYWQgaW1wbGVtZW50YXRpb25cbiAgICovXG4gIHNlcmlhbGl6ZShjYWxsYmFjaykge1xuICAgIGNvbnN0IHByb21pc2VDYWxsYmFjayA9IGNyZWF0ZVByb21pc2VDYWxsYmFjayhjYWxsYmFjayk7XG4gICAgbGV0IHR5cGUgPSB0aGlzLnN0b3JlLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgaWYgKGlzT2JqZWN0KHR5cGUpKSB7XG4gICAgICB0eXBlID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IHtcbiAgICAgIC8vIFRoZSB2ZXJzaW9uIG9mIHRvdWdoLWNvb2tpZSB0aGF0IHNlcmlhbGl6ZWQgdGhpcyBqYXIuIEdlbmVyYWxseSBhIGdvb2RcbiAgICAgIC8vIHByYWN0aWNlIHNpbmNlIGZ1dHVyZSB2ZXJzaW9ucyBjYW4gbWFrZSBkYXRhIGltcG9ydCBkZWNpc2lvbnMgYmFzZWQgb25cbiAgICAgIC8vIGtub3duIHBhc3QgYmVoYXZpb3IuIFdoZW4vaWYgdGhpcyBtYXR0ZXJzLCB1c2UgYHNlbXZlcmAuXG4gICAgICB2ZXJzaW9uOiBgdG91Z2gtY29va2llQCR7dmVyc2lvbn1gLFxuICAgICAgLy8gYWRkIHRoZSBzdG9yZSB0eXBlLCB0byBtYWtlIGh1bWFucyBoYXBweTpcbiAgICAgIHN0b3JlVHlwZTogdHlwZSxcbiAgICAgIC8vIENvb2tpZUphciBjb25maWd1cmF0aW9uOlxuICAgICAgcmVqZWN0UHVibGljU3VmZml4ZXM6IHRoaXMucmVqZWN0UHVibGljU3VmZml4ZXMsXG4gICAgICBlbmFibGVMb29zZU1vZGU6IHRoaXMuZW5hYmxlTG9vc2VNb2RlLFxuICAgICAgYWxsb3dTcGVjaWFsVXNlRG9tYWluOiB0aGlzLmFsbG93U3BlY2lhbFVzZURvbWFpbixcbiAgICAgIHByZWZpeFNlY3VyaXR5OiBnZXROb3JtYWxpemVkUHJlZml4U2VjdXJpdHkodGhpcy5wcmVmaXhTZWN1cml0eSksXG4gICAgICAvLyB0aGlzIGdldHMgZmlsbGVkIGZyb20gZ2V0QWxsQ29va2llczpcbiAgICAgIGNvb2tpZXM6IFtdXG4gICAgfTtcbiAgICBpZiAodHlwZW9mIHRoaXMuc3RvcmUuZ2V0QWxsQ29va2llcyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZUNhbGxiYWNrLnJlamVjdChcbiAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgIFwic3RvcmUgZG9lcyBub3Qgc3VwcG9ydCBnZXRBbGxDb29raWVzIGFuZCBjYW5ub3QgYmUgc2VyaWFsaXplZFwiXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuc3RvcmUuZ2V0QWxsQ29va2llcygoZXJyLCBjb29raWVzKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHByb21pc2VDYWxsYmFjay5jYWxsYmFjayhlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoY29va2llcyA9PSBudWxsKSB7XG4gICAgICAgIHByb21pc2VDYWxsYmFjay5jYWxsYmFjayhudWxsLCBzZXJpYWxpemVkKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2VyaWFsaXplZC5jb29raWVzID0gY29va2llcy5tYXAoKGNvb2tpZSkgPT4ge1xuICAgICAgICBjb25zdCBzZXJpYWxpemVkQ29va2llID0gY29va2llLnRvSlNPTigpO1xuICAgICAgICBkZWxldGUgc2VyaWFsaXplZENvb2tpZS5jcmVhdGlvbkluZGV4O1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplZENvb2tpZTtcbiAgICAgIH0pO1xuICAgICAgcHJvbWlzZUNhbGxiYWNrLmNhbGxiYWNrKG51bGwsIHNlcmlhbGl6ZWQpO1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlQ2FsbGJhY2sucHJvbWlzZTtcbiAgfVxuICAvKipcbiAgICogU2VyaWFsaXplIHRoZSBDb29raWVKYXIgaWYgdGhlIHVuZGVybHlpbmcgc3RvcmUgc3VwcG9ydHMgYC5nZXRBbGxDb29raWVzYC5cbiAgICpcbiAgICogPHN0cm9uZz5Ob3RlPC9zdHJvbmc+OiBPbmx5IHdvcmtzIGlmIHRoZSBjb25maWd1cmVkIFN0b3JlIGlzIGFsc28gc3luY2hyb25vdXMuXG4gICAqL1xuICBzZXJpYWxpemVTeW5jKCkge1xuICAgIHJldHVybiB0aGlzLmNhbGxTeW5jKChjYWxsYmFjaykgPT4ge1xuICAgICAgdGhpcy5zZXJpYWxpemUoY2FsbGJhY2spO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBBbGlhcyBvZiB7QGxpbmsgQ29va2llSmFyLnNlcmlhbGl6ZVN5bmN9LiBBbGxvd3MgdGhlIGNvb2tpZSB0byBiZSBzZXJpYWxpemVkXG4gICAqIHdpdGggYEpTT04uc3RyaW5naWZ5KGNvb2tpZUphcilgLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZVN5bmMoKTtcbiAgfVxuICAvKipcbiAgICogVXNlIHRoZSBjbGFzcyBtZXRob2QgQ29va2llSmFyLmRlc2VyaWFsaXplIGluc3RlYWQgb2YgY2FsbGluZyB0aGlzIGRpcmVjdGx5XG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2ltcG9ydENvb2tpZXMoc2VyaWFsaXplZCwgY2FsbGJhY2spIHtcbiAgICBsZXQgY29va2llcyA9IHZvaWQgMDtcbiAgICBpZiAoc2VyaWFsaXplZCAmJiB0eXBlb2Ygc2VyaWFsaXplZCA9PT0gXCJvYmplY3RcIiAmJiBpbk9wZXJhdG9yKFwiY29va2llc1wiLCBzZXJpYWxpemVkKSAmJiBBcnJheS5pc0FycmF5KHNlcmlhbGl6ZWQuY29va2llcykpIHtcbiAgICAgIGNvb2tpZXMgPSBzZXJpYWxpemVkLmNvb2tpZXM7XG4gICAgfVxuICAgIGlmICghY29va2llcykge1xuICAgICAgY2FsbGJhY2sobmV3IEVycm9yKFwic2VyaWFsaXplZCBqYXIgaGFzIG5vIGNvb2tpZXMgYXJyYXlcIiksIHZvaWQgMCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvb2tpZXMgPSBjb29raWVzLnNsaWNlKCk7XG4gICAgY29uc3QgcHV0TmV4dCA9IChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyLCB2b2lkIDApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjb29raWVzKSkge1xuICAgICAgICBpZiAoIWNvb2tpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgY2FsbGJhY2soZXJyLCB0aGlzKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvb2tpZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb29raWUgPSBDb29raWUuZnJvbUpTT04oY29va2llcy5zaGlmdCgpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNhbGxiYWNrKGUgaW5zdGFuY2VvZiBFcnJvciA/IGUgOiBuZXcgRXJyb3IoKSwgdm9pZCAwKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvb2tpZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgcHV0TmV4dChudWxsKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdG9yZS5wdXRDb29raWUoY29va2llLCBwdXROZXh0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHB1dE5leHQobnVsbCk7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2ltcG9ydENvb2tpZXNTeW5jKHNlcmlhbGl6ZWQpIHtcbiAgICB0aGlzLmNhbGxTeW5jKHRoaXMuX2ltcG9ydENvb2tpZXMuYmluZCh0aGlzLCBzZXJpYWxpemVkKSk7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbCBObyBkb2MgYmVjYXVzZSB0aGlzIGlzIHRoZSBvdmVybG9hZCBpbXBsZW1lbnRhdGlvblxuICAgKi9cbiAgY2xvbmUobmV3U3RvcmUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBuZXdTdG9yZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBjYWxsYmFjayA9IG5ld1N0b3JlO1xuICAgICAgbmV3U3RvcmUgPSB2b2lkIDA7XG4gICAgfVxuICAgIGNvbnN0IHByb21pc2VDYWxsYmFjayA9IGNyZWF0ZVByb21pc2VDYWxsYmFjayhjYWxsYmFjayk7XG4gICAgY29uc3QgY2IgPSBwcm9taXNlQ2FsbGJhY2suY2FsbGJhY2s7XG4gICAgdGhpcy5zZXJpYWxpemUoKGVyciwgc2VyaWFsaXplZCkgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gcHJvbWlzZUNhbGxiYWNrLnJlamVjdChlcnIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9Db29raWVKYXIuZGVzZXJpYWxpemUoc2VyaWFsaXplZCA/PyBcIlwiLCBuZXdTdG9yZSwgY2IpO1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlQ2FsbGJhY2sucHJvbWlzZTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfY2xvbmVTeW5jKG5ld1N0b3JlKSB7XG4gICAgY29uc3QgY2xvbmVGbiA9IG5ld1N0b3JlICYmIHR5cGVvZiBuZXdTdG9yZSAhPT0gXCJmdW5jdGlvblwiID8gdGhpcy5jbG9uZS5iaW5kKHRoaXMsIG5ld1N0b3JlKSA6IHRoaXMuY2xvbmUuYmluZCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5jYWxsU3luYygoY2FsbGJhY2spID0+IHtcbiAgICAgIGNsb25lRm4oY2FsbGJhY2spO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBQcm9kdWNlcyBhIGRlZXAgY2xvbmUgb2YgdGhpcyBDb29raWVKYXIuIE1vZGlmaWNhdGlvbnMgdG8gdGhlIG9yaWdpbmFsIGRvXG4gICAqIG5vdCBhZmZlY3QgdGhlIGNsb25lLCBhbmQgdmljZSB2ZXJzYS5cbiAgICpcbiAgICogPHN0cm9uZz5Ob3RlPC9zdHJvbmc+OiBPbmx5IHdvcmtzIGlmIGJvdGggdGhlIGNvbmZpZ3VyZWQgU3RvcmUgYW5kIGRlc3RpbmF0aW9uXG4gICAqIFN0b3JlIGFyZSBzeW5jaHJvbm91cy5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogLSBXaGVuIG5vIHtAbGluayBTdG9yZX0gaXMgcHJvdmlkZWQsIGEgbmV3IHtAbGluayBNZW1vcnlDb29raWVTdG9yZX0gd2lsbCBiZSB1c2VkLlxuICAgKlxuICAgKiAtIFRyYW5zZmVycmluZyBiZXR3ZWVuIHN0b3JlIHR5cGVzIGlzIHN1cHBvcnRlZCBzbyBsb25nIGFzIHRoZSBzb3VyY2VcbiAgICogICAgIGltcGxlbWVudHMgYC5nZXRBbGxDb29raWVzKClgIGFuZCB0aGUgZGVzdGluYXRpb24gaW1wbGVtZW50cyBgLnB1dENvb2tpZSgpYC5cbiAgICpcbiAgICogQHBhcmFtIG5ld1N0b3JlIC0gVGhlIHRhcmdldCB7QGxpbmsgU3RvcmV9IHRvIGNsb25lIGNvb2tpZXMgaW50by5cbiAgICovXG4gIGNsb25lU3luYyhuZXdTdG9yZSkge1xuICAgIGlmICghbmV3U3RvcmUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jbG9uZVN5bmMoKTtcbiAgICB9XG4gICAgaWYgKCFuZXdTdG9yZS5zeW5jaHJvbm91cykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkNvb2tpZUphciBjbG9uZSBkZXN0aW5hdGlvbiBzdG9yZSBpcyBub3Qgc3luY2hyb25vdXM7IHVzZSBhc3luYyBBUEkgaW5zdGVhZC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2Nsb25lU3luYyhuZXdTdG9yZSk7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbCBObyBkb2MgYmVjYXVzZSB0aGlzIGlzIHRoZSBvdmVybG9hZCBpbXBsZW1lbnRhdGlvblxuICAgKi9cbiAgcmVtb3ZlQWxsQ29va2llcyhjYWxsYmFjaykge1xuICAgIGNvbnN0IHByb21pc2VDYWxsYmFjayA9IGNyZWF0ZVByb21pc2VDYWxsYmFjayhjYWxsYmFjayk7XG4gICAgY29uc3QgY2IgPSBwcm9taXNlQ2FsbGJhY2suY2FsbGJhY2s7XG4gICAgY29uc3Qgc3RvcmUgPSB0aGlzLnN0b3JlO1xuICAgIGlmICh0eXBlb2Ygc3RvcmUucmVtb3ZlQWxsQ29va2llcyA9PT0gXCJmdW5jdGlvblwiICYmIHN0b3JlLnJlbW92ZUFsbENvb2tpZXMgIT09IFN0b3JlLnByb3RvdHlwZS5yZW1vdmVBbGxDb29raWVzKSB7XG4gICAgICBzdG9yZS5yZW1vdmVBbGxDb29raWVzKGNiKTtcbiAgICAgIHJldHVybiBwcm9taXNlQ2FsbGJhY2sucHJvbWlzZTtcbiAgICB9XG4gICAgc3RvcmUuZ2V0QWxsQ29va2llcygoZXJyLCBjb29raWVzKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGNiKGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghY29va2llcykge1xuICAgICAgICBjb29raWVzID0gW107XG4gICAgICB9XG4gICAgICBpZiAoY29va2llcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY2IobnVsbCwgdm9pZCAwKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IGNvbXBsZXRlZENvdW50ID0gMDtcbiAgICAgIGNvbnN0IHJlbW92ZUVycm9ycyA9IFtdO1xuICAgICAgY29uc3QgcmVtb3ZlQ29va2llQ2IgPSBmdW5jdGlvbiByZW1vdmVDb29raWVDYjIocmVtb3ZlRXJyKSB7XG4gICAgICAgIGlmIChyZW1vdmVFcnIpIHtcbiAgICAgICAgICByZW1vdmVFcnJvcnMucHVzaChyZW1vdmVFcnIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbXBsZXRlZENvdW50Kys7XG4gICAgICAgIGlmIChjb21wbGV0ZWRDb3VudCA9PT0gY29va2llcy5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAocmVtb3ZlRXJyb3JzWzBdKSBjYihyZW1vdmVFcnJvcnNbMF0pO1xuICAgICAgICAgIGVsc2UgY2IobnVsbCwgdm9pZCAwKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb29raWVzLmZvckVhY2goKGNvb2tpZSkgPT4ge1xuICAgICAgICBzdG9yZS5yZW1vdmVDb29raWUoXG4gICAgICAgICAgY29va2llLmRvbWFpbixcbiAgICAgICAgICBjb29raWUucGF0aCxcbiAgICAgICAgICBjb29raWUua2V5LFxuICAgICAgICAgIHJlbW92ZUNvb2tpZUNiXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZUNhbGxiYWNrLnByb21pc2U7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIGNvb2tpZXMgZnJvbSB0aGUgQ29va2llSmFyLlxuICAgKlxuICAgKiA8c3Ryb25nPk5vdGU8L3N0cm9uZz46IE9ubHkgd29ya3MgaWYgdGhlIGNvbmZpZ3VyZWQgU3RvcmUgaXMgYWxzbyBzeW5jaHJvbm91cy5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogLSBUaGlzIGlzIGEgbmV3IGJhY2t3YXJkcy1jb21wYXRpYmxlIGZlYXR1cmUgb2YgdG91Z2gtY29va2llIHZlcnNpb24gMi41LFxuICAgKiAgICAgc28gbm90IGFsbCBTdG9yZXMgd2lsbCBpbXBsZW1lbnQgaXQgZWZmaWNpZW50bHkuIEZvciBTdG9yZXMgdGhhdCBkbyBub3RcbiAgICogICAgIGltcGxlbWVudCBgcmVtb3ZlQWxsQ29va2llc2AsIHRoZSBmYWxsYmFjayBpcyB0byBjYWxsIGByZW1vdmVDb29raWVgIGFmdGVyXG4gICAqICAgICBgZ2V0QWxsQ29va2llc2AuXG4gICAqXG4gICAqIC0gSWYgYGdldEFsbENvb2tpZXNgIGZhaWxzIG9yIGlzbid0IGltcGxlbWVudGVkIGluIHRoZSBTdG9yZSwgYW4gZXJyb3IgaXMgcmV0dXJuZWQuXG4gICAqXG4gICAqIC0gSWYgb25lIG9yIG1vcmUgb2YgdGhlIGByZW1vdmVDb29raWVgIGNhbGxzIGZhaWwsIG9ubHkgdGhlIGZpcnN0IGVycm9yIGlzIHJldHVybmVkLlxuICAgKi9cbiAgcmVtb3ZlQWxsQ29va2llc1N5bmMoKSB7XG4gICAgdGhpcy5jYWxsU3luYygoY2FsbGJhY2spID0+IHtcbiAgICAgIHRoaXMucmVtb3ZlQWxsQ29va2llcyhjYWxsYmFjayk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbCBObyBkb2MgYmVjYXVzZSB0aGlzIGlzIHRoZSBvdmVybG9hZCBpbXBsZW1lbnRhdGlvblxuICAgKi9cbiAgc3RhdGljIGRlc2VyaWFsaXplKHN0ck9yT2JqLCBzdG9yZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIHN0b3JlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNhbGxiYWNrID0gc3RvcmU7XG4gICAgICBzdG9yZSA9IHZvaWQgMDtcbiAgICB9XG4gICAgY29uc3QgcHJvbWlzZUNhbGxiYWNrID0gY3JlYXRlUHJvbWlzZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgICBsZXQgc2VyaWFsaXplZDtcbiAgICBpZiAodHlwZW9mIHN0ck9yT2JqID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzZXJpYWxpemVkID0gSlNPTi5wYXJzZShzdHJPck9iaik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlQ2FsbGJhY2sucmVqZWN0KGUgaW5zdGFuY2VvZiBFcnJvciA/IGUgOiBuZXcgRXJyb3IoKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlcmlhbGl6ZWQgPSBzdHJPck9iajtcbiAgICB9XG4gICAgY29uc3QgcmVhZFNlcmlhbGl6ZWRQcm9wZXJ0eSA9IChwcm9wZXJ0eSkgPT4ge1xuICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQgJiYgdHlwZW9mIHNlcmlhbGl6ZWQgPT09IFwib2JqZWN0XCIgJiYgaW5PcGVyYXRvcihwcm9wZXJ0eSwgc2VyaWFsaXplZCkgPyBzZXJpYWxpemVkW3Byb3BlcnR5XSA6IHZvaWQgMDtcbiAgICB9O1xuICAgIGNvbnN0IHJlYWRTZXJpYWxpemVkQm9vbGVhbiA9IChwcm9wZXJ0eSkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSByZWFkU2VyaWFsaXplZFByb3BlcnR5KHByb3BlcnR5KTtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiID8gdmFsdWUgOiB2b2lkIDA7XG4gICAgfTtcbiAgICBjb25zdCByZWFkU2VyaWFsaXplZFN0cmluZyA9IChwcm9wZXJ0eSkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSByZWFkU2VyaWFsaXplZFByb3BlcnR5KHByb3BlcnR5KTtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZSA6IHZvaWQgMDtcbiAgICB9O1xuICAgIGNvbnN0IGphciA9IG5ldyBfQ29va2llSmFyKHN0b3JlLCB7XG4gICAgICByZWplY3RQdWJsaWNTdWZmaXhlczogcmVhZFNlcmlhbGl6ZWRCb29sZWFuKFwicmVqZWN0UHVibGljU3VmZml4ZXNcIiksXG4gICAgICBsb29zZU1vZGU6IHJlYWRTZXJpYWxpemVkQm9vbGVhbihcImVuYWJsZUxvb3NlTW9kZVwiKSxcbiAgICAgIGFsbG93U3BlY2lhbFVzZURvbWFpbjogcmVhZFNlcmlhbGl6ZWRCb29sZWFuKFwiYWxsb3dTcGVjaWFsVXNlRG9tYWluXCIpLFxuICAgICAgcHJlZml4U2VjdXJpdHk6IGdldE5vcm1hbGl6ZWRQcmVmaXhTZWN1cml0eShcbiAgICAgICAgcmVhZFNlcmlhbGl6ZWRTdHJpbmcoXCJwcmVmaXhTZWN1cml0eVwiKSA/PyBcInNpbGVudFwiXG4gICAgICApXG4gICAgfSk7XG4gICAgamFyLl9pbXBvcnRDb29raWVzKHNlcmlhbGl6ZWQsIChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcHJvbWlzZUNhbGxiYWNrLmNhbGxiYWNrKGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHByb21pc2VDYWxsYmFjay5jYWxsYmFjayhudWxsLCBqYXIpO1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlQ2FsbGJhY2sucHJvbWlzZTtcbiAgfVxuICAvKipcbiAgICogQSBuZXcgQ29va2llSmFyIGlzIGNyZWF0ZWQgYW5kIHRoZSBzZXJpYWxpemVkIHtAbGluayBDb29raWV9IHZhbHVlcyBhcmUgYWRkZWQgdG9cbiAgICogdGhlIHVuZGVybHlpbmcgc3RvcmUuIEVhY2gge0BsaW5rIENvb2tpZX0gaXMgYWRkZWQgdmlhIGBzdG9yZS5wdXRDb29raWUoLi4uKWAgaW5cbiAgICogdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgYXBwZWFyIGluIHRoZSBzZXJpYWxpemF0aW9uLlxuICAgKlxuICAgKiA8c3Ryb25nPk5vdGU8L3N0cm9uZz46IE9ubHkgd29ya3MgaWYgdGhlIGNvbmZpZ3VyZWQgU3RvcmUgaXMgYWxzbyBzeW5jaHJvbm91cy5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogLSBXaGVuIG5vIHtAbGluayBTdG9yZX0gaXMgcHJvdmlkZWQsIGEgbmV3IHtAbGluayBNZW1vcnlDb29raWVTdG9yZX0gd2lsbCBiZSB1c2VkLlxuICAgKlxuICAgKiAtIEFzIGEgY29udmVuaWVuY2UsIGlmIGBzdHJPck9iamAgaXMgYSBzdHJpbmcsIGl0IGlzIHBhc3NlZCB0aHJvdWdoIGBKU09OLnBhcnNlYCBmaXJzdC5cbiAgICpcbiAgICogQHBhcmFtIHN0ck9yT2JqIC0gQSBKU09OIHN0cmluZyBvciBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBkZXNlcmlhbGl6ZWQgY29va2llcy5cbiAgICogQHBhcmFtIHN0b3JlIC0gVGhlIHVuZGVybHlpbmcgc3RvcmUgdG8gcGVyc2lzdCB0aGUgZGVzZXJpYWxpemVkIGNvb2tpZXMgaW50by5cbiAgICovXG4gIHN0YXRpYyBkZXNlcmlhbGl6ZVN5bmMoc3RyT3JPYmosIHN0b3JlKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IHR5cGVvZiBzdHJPck9iaiA9PT0gXCJzdHJpbmdcIiA/IEpTT04ucGFyc2Uoc3RyT3JPYmopIDogc3RyT3JPYmo7XG4gICAgY29uc3QgcmVhZFNlcmlhbGl6ZWRQcm9wZXJ0eSA9IChwcm9wZXJ0eSkgPT4ge1xuICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQgJiYgdHlwZW9mIHNlcmlhbGl6ZWQgPT09IFwib2JqZWN0XCIgJiYgaW5PcGVyYXRvcihwcm9wZXJ0eSwgc2VyaWFsaXplZCkgPyBzZXJpYWxpemVkW3Byb3BlcnR5XSA6IHZvaWQgMDtcbiAgICB9O1xuICAgIGNvbnN0IHJlYWRTZXJpYWxpemVkQm9vbGVhbiA9IChwcm9wZXJ0eSkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSByZWFkU2VyaWFsaXplZFByb3BlcnR5KHByb3BlcnR5KTtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiID8gdmFsdWUgOiB2b2lkIDA7XG4gICAgfTtcbiAgICBjb25zdCByZWFkU2VyaWFsaXplZFN0cmluZyA9IChwcm9wZXJ0eSkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSByZWFkU2VyaWFsaXplZFByb3BlcnR5KHByb3BlcnR5KTtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZSA6IHZvaWQgMDtcbiAgICB9O1xuICAgIGNvbnN0IGphciA9IG5ldyBfQ29va2llSmFyKHN0b3JlLCB7XG4gICAgICByZWplY3RQdWJsaWNTdWZmaXhlczogcmVhZFNlcmlhbGl6ZWRCb29sZWFuKFwicmVqZWN0UHVibGljU3VmZml4ZXNcIiksXG4gICAgICBsb29zZU1vZGU6IHJlYWRTZXJpYWxpemVkQm9vbGVhbihcImVuYWJsZUxvb3NlTW9kZVwiKSxcbiAgICAgIGFsbG93U3BlY2lhbFVzZURvbWFpbjogcmVhZFNlcmlhbGl6ZWRCb29sZWFuKFwiYWxsb3dTcGVjaWFsVXNlRG9tYWluXCIpLFxuICAgICAgcHJlZml4U2VjdXJpdHk6IGdldE5vcm1hbGl6ZWRQcmVmaXhTZWN1cml0eShcbiAgICAgICAgcmVhZFNlcmlhbGl6ZWRTdHJpbmcoXCJwcmVmaXhTZWN1cml0eVwiKSA/PyBcInNpbGVudFwiXG4gICAgICApXG4gICAgfSk7XG4gICAgaWYgKCFqYXIuc3RvcmUuc3luY2hyb25vdXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJDb29raWVKYXIgc3RvcmUgaXMgbm90IHN5bmNocm9ub3VzOyB1c2UgYXN5bmMgQVBJIGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGphci5faW1wb3J0Q29va2llc1N5bmMoc2VyaWFsaXplZCk7XG4gICAgcmV0dXJuIGphcjtcbiAgfVxuICAvKipcbiAgICogQWxpYXMgb2Yge0BsaW5rIENvb2tpZUphci5kZXNlcmlhbGl6ZVN5bmN9LlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiAtIFdoZW4gbm8ge0BsaW5rIFN0b3JlfSBpcyBwcm92aWRlZCwgYSBuZXcge0BsaW5rIE1lbW9yeUNvb2tpZVN0b3JlfSB3aWxsIGJlIHVzZWQuXG4gICAqXG4gICAqIC0gQXMgYSBjb252ZW5pZW5jZSwgaWYgYHN0ck9yT2JqYCBpcyBhIHN0cmluZywgaXQgaXMgcGFzc2VkIHRocm91Z2ggYEpTT04ucGFyc2VgIGZpcnN0LlxuICAgKlxuICAgKiBAcGFyYW0ganNvblN0cmluZyAtIEEgSlNPTiBzdHJpbmcgb3Igb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgZGVzZXJpYWxpemVkIGNvb2tpZXMuXG4gICAqIEBwYXJhbSBzdG9yZSAtIFRoZSB1bmRlcmx5aW5nIHN0b3JlIHRvIHBlcnNpc3QgdGhlIGRlc2VyaWFsaXplZCBjb29raWVzIGludG8uXG4gICAqL1xuICBzdGF0aWMgZnJvbUpTT04oanNvblN0cmluZywgc3RvcmUpIHtcbiAgICByZXR1cm4gX0Nvb2tpZUphci5kZXNlcmlhbGl6ZVN5bmMoanNvblN0cmluZywgc3RvcmUpO1xuICB9XG59O1xuXG4vLyBsaWIvY29va2llL3Blcm11dGVQYXRoLnRzXG5mdW5jdGlvbiBwZXJtdXRlUGF0aChwYXRoKSB7XG4gIGlmIChwYXRoID09PSBcIi9cIikge1xuICAgIHJldHVybiBbXCIvXCJdO1xuICB9XG4gIGNvbnN0IHBlcm11dGF0aW9ucyA9IFtwYXRoXTtcbiAgd2hpbGUgKHBhdGgubGVuZ3RoID4gMSkge1xuICAgIGNvbnN0IGxpbmRleCA9IHBhdGgubGFzdEluZGV4T2YoXCIvXCIpO1xuICAgIGlmIChsaW5kZXggPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBwYXRoID0gcGF0aC5zbGljZSgwLCBsaW5kZXgpO1xuICAgIHBlcm11dGF0aW9ucy5wdXNoKHBhdGgpO1xuICB9XG4gIHBlcm11dGF0aW9ucy5wdXNoKFwiL1wiKTtcbiAgcmV0dXJuIHBlcm11dGF0aW9ucztcbn1cblxuLy8gbGliL2Nvb2tpZS9pbmRleC50c1xuZnVuY3Rpb24gcGFyc2UyKHN0ciwgb3B0aW9ucykge1xuICByZXR1cm4gQ29va2llLnBhcnNlKHN0ciwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBmcm9tSlNPTjIoc3RyKSB7XG4gIHJldHVybiBDb29raWUuZnJvbUpTT04oc3RyKTtcbn1cbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBDb29raWUsXG4gIENvb2tpZUphcixcbiAgTWVtb3J5Q29va2llU3RvcmUsXG4gIFBhcmFtZXRlckVycm9yLFxuICBQcmVmaXhTZWN1cml0eUVudW0sXG4gIFN0b3JlLFxuICBjYW5vbmljYWxEb21haW4sXG4gIGNvb2tpZUNvbXBhcmUsXG4gIGRlZmF1bHRQYXRoLFxuICBkb21haW5NYXRjaCxcbiAgZm9ybWF0RGF0ZSxcbiAgZnJvbUpTT04sXG4gIGdldFB1YmxpY1N1ZmZpeCxcbiAgcGFyc2UsXG4gIHBhcnNlRGF0ZSxcbiAgcGF0aE1hdGNoLFxuICBwZXJtdXRlRG9tYWluLFxuICBwZXJtdXRlUGF0aCxcbiAgdmVyc2lvblxufSk7XG4vKiFcbiAqIENvcHlyaWdodCAoYykgMjAxNS0yMDIwLCBTYWxlc2ZvcmNlLmNvbSwgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICpcbiAqIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvblxuICogYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogMy4gTmVpdGhlciB0aGUgbmFtZSBvZiBTYWxlc2ZvcmNlLmNvbSBub3IgdGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnMgbWF5XG4gKiBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0XG4gKiBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAqIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAqIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gKiBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFXG4gKiBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SXG4gKiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRlxuICogU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTXG4gKiBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTlxuICogQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSlcbiAqIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4gKiBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguY2pzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/tough-cookie/dist/index.cjs\n");

/***/ })

};
;