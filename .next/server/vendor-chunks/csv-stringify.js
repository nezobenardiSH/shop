"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/csv-stringify";
exports.ids = ["vendor-chunks/csv-stringify"];
exports.modules = {

/***/ "(rsc)/./node_modules/csv-stringify/dist/cjs/index.cjs":
/*!*******************************************************!*\
  !*** ./node_modules/csv-stringify/dist/cjs/index.cjs ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar stream = __webpack_require__(/*! stream */ \"stream\");\n\nclass CsvError extends Error {\n  constructor(code, message, ...contexts) {\n    if (Array.isArray(message)) message = message.join(\" \");\n    super(message);\n    if (Error.captureStackTrace !== undefined) {\n      Error.captureStackTrace(this, CsvError);\n    }\n    this.code = code;\n    for (const context of contexts) {\n      for (const key in context) {\n        const value = context[key];\n        this[key] = Buffer.isBuffer(value)\n          ? value.toString()\n          : value == null\n            ? value\n            : JSON.parse(JSON.stringify(value));\n      }\n    }\n  }\n}\n\nconst is_object = function (obj) {\n  return typeof obj === \"object\" && obj !== null && !Array.isArray(obj);\n};\n\n// Lodash implementation of `get`\n\nconst charCodeOfDot = \".\".charCodeAt(0);\nconst reEscapeChar = /\\\\(\\\\)?/g;\nconst rePropName = RegExp(\n  // Match anything that isn't a dot or bracket.\n  \"[^.[\\\\]]+\" +\n    \"|\" +\n    // Or match property names within brackets.\n    \"\\\\[(?:\" +\n    // Match a non-string expression.\n    \"([^\\\"'][^[]*)\" +\n    \"|\" +\n    // Or match strings (supports escaping characters).\n    \"([\\\"'])((?:(?!\\\\2)[^\\\\\\\\]|\\\\\\\\.)*?)\\\\2\" +\n    \")\\\\]\" +\n    \"|\" +\n    // Or match \"\" as the space between consecutive dots or empty brackets.\n    \"(?=(?:\\\\.|\\\\[\\\\])(?:\\\\.|\\\\[\\\\]|$))\",\n  \"g\",\n);\nconst reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\nconst reIsPlainProp = /^\\w*$/;\n\nconst getTag = function (value) {\n  // if (!value) value === undefined ? \"[object Undefined]\" : \"[object Null]\";\n  return Object.prototype.toString.call(value);\n};\n\nconst isSymbol = function (value) {\n  const type = typeof value;\n  return (\n    type === \"symbol\" ||\n    (type === \"object\" && value && getTag(value) === \"[object Symbol]\")\n  );\n};\n\nconst isKey = function (value, object) {\n  if (Array.isArray(value)) {\n    return false;\n  }\n  const type = typeof value;\n  if (\n    type === \"number\" ||\n    type === \"symbol\" ||\n    type === \"boolean\" ||\n    !value ||\n    isSymbol(value)\n  ) {\n    return true;\n  }\n  return (\n    reIsPlainProp.test(value) ||\n    !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object))\n  );\n};\n\nconst stringToPath = function (string) {\n  const result = [];\n  if (string.charCodeAt(0) === charCodeOfDot) {\n    result.push(\"\");\n  }\n  string.replace(rePropName, function (match, expression, quote, subString) {\n    let key = match;\n    if (quote) {\n      key = subString.replace(reEscapeChar, \"$1\");\n    } else if (expression) {\n      key = expression.trim();\n    }\n    result.push(key);\n  });\n  return result;\n};\n\nconst castPath = function (value, object) {\n  if (Array.isArray(value)) {\n    return value;\n  } else {\n    return isKey(value, object) ? [value] : stringToPath(value);\n  }\n};\n\nconst toKey = function (value) {\n  if (typeof value === \"string\" || isSymbol(value)) return value;\n  const result = `${value}`;\n  // eslint-disable-next-line\n  return result == \"0\" && 1 / value == -INFINITY ? \"-0\" : result;\n};\n\nconst get = function (object, path) {\n  path = castPath(path, object);\n  let index = 0;\n  const length = path.length;\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return index && index === length ? object : undefined;\n};\n\nconst normalize_columns = function (columns) {\n  if (columns === undefined || columns === null) {\n    return [undefined, undefined];\n  }\n  if (typeof columns !== \"object\") {\n    return [Error('Invalid option \"columns\": expect an array or an object')];\n  }\n  if (!Array.isArray(columns)) {\n    const newcolumns = [];\n    for (const k in columns) {\n      newcolumns.push({\n        key: k,\n        header: columns[k],\n      });\n    }\n    columns = newcolumns;\n  } else {\n    const newcolumns = [];\n    for (const column of columns) {\n      if (typeof column === \"string\") {\n        newcolumns.push({\n          key: column,\n          header: column,\n        });\n      } else if (\n        typeof column === \"object\" &&\n        column !== null &&\n        !Array.isArray(column)\n      ) {\n        if (!column.key) {\n          return [\n            Error('Invalid column definition: property \"key\" is required'),\n          ];\n        }\n        if (column.header === undefined) {\n          column.header = column.key;\n        }\n        newcolumns.push(column);\n      } else {\n        return [\n          Error(\"Invalid column definition: expect a string or an object\"),\n        ];\n      }\n    }\n    columns = newcolumns;\n  }\n  return [undefined, columns];\n};\n\nconst underscore = function (str) {\n  return str.replace(/([A-Z])/g, function (_, match) {\n    return \"_\" + match.toLowerCase();\n  });\n};\n\nconst normalize_options = function (opts) {\n  const options = {};\n  // Merge with user options\n  for (const opt in opts) {\n    options[underscore(opt)] = opts[opt];\n  }\n  // Normalize option `bom`\n  if (\n    options.bom === undefined ||\n    options.bom === null ||\n    options.bom === false\n  ) {\n    options.bom = false;\n  } else if (options.bom !== true) {\n    return [\n      new CsvError(\"CSV_OPTION_BOOLEAN_INVALID_TYPE\", [\n        \"option `bom` is optional and must be a boolean value,\",\n        `got ${JSON.stringify(options.bom)}`,\n      ]),\n    ];\n  }\n  // Normalize option `delimiter`\n  if (options.delimiter === undefined || options.delimiter === null) {\n    options.delimiter = \",\";\n  } else if (Buffer.isBuffer(options.delimiter)) {\n    options.delimiter = options.delimiter.toString();\n  } else if (typeof options.delimiter !== \"string\") {\n    return [\n      new CsvError(\"CSV_OPTION_DELIMITER_INVALID_TYPE\", [\n        \"option `delimiter` must be a buffer or a string,\",\n        `got ${JSON.stringify(options.delimiter)}`,\n      ]),\n    ];\n  }\n  // Normalize option `quote`\n  if (options.quote === undefined || options.quote === null) {\n    options.quote = '\"';\n  } else if (options.quote === true) {\n    options.quote = '\"';\n  } else if (options.quote === false) {\n    options.quote = \"\";\n  } else if (Buffer.isBuffer(options.quote)) {\n    options.quote = options.quote.toString();\n  } else if (typeof options.quote !== \"string\") {\n    return [\n      new CsvError(\"CSV_OPTION_QUOTE_INVALID_TYPE\", [\n        \"option `quote` must be a boolean, a buffer or a string,\",\n        `got ${JSON.stringify(options.quote)}`,\n      ]),\n    ];\n  }\n  // Normalize option `quoted`\n  if (options.quoted === undefined || options.quoted === null) {\n    options.quoted = false;\n  }\n  // Normalize option `escape_formulas`\n  if (\n    options.escape_formulas === undefined ||\n    options.escape_formulas === null\n  ) {\n    options.escape_formulas = false;\n  } else if (typeof options.escape_formulas !== \"boolean\") {\n    return [\n      new CsvError(\"CSV_OPTION_ESCAPE_FORMULAS_INVALID_TYPE\", [\n        \"option `escape_formulas` must be a boolean,\",\n        `got ${JSON.stringify(options.escape_formulas)}`,\n      ]),\n    ];\n  }\n  // Normalize option `quoted_empty`\n  if (options.quoted_empty === undefined || options.quoted_empty === null) {\n    options.quoted_empty = undefined;\n  }\n  // Normalize option `quoted_match`\n  if (\n    options.quoted_match === undefined ||\n    options.quoted_match === null ||\n    options.quoted_match === false\n  ) {\n    options.quoted_match = null;\n  } else if (!Array.isArray(options.quoted_match)) {\n    options.quoted_match = [options.quoted_match];\n  }\n  if (options.quoted_match) {\n    for (const quoted_match of options.quoted_match) {\n      const isString = typeof quoted_match === \"string\";\n      const isRegExp = quoted_match instanceof RegExp;\n      if (!isString && !isRegExp) {\n        return [\n          Error(\n            `Invalid Option: quoted_match must be a string or a regex, got ${JSON.stringify(quoted_match)}`,\n          ),\n        ];\n      }\n    }\n  }\n  // Normalize option `quoted_string`\n  if (options.quoted_string === undefined || options.quoted_string === null) {\n    options.quoted_string = false;\n  }\n  // Normalize option `eof`\n  if (options.eof === undefined || options.eof === null) {\n    options.eof = true;\n  }\n  // Normalize option `escape`\n  if (options.escape === undefined || options.escape === null) {\n    options.escape = '\"';\n  } else if (Buffer.isBuffer(options.escape)) {\n    options.escape = options.escape.toString();\n  } else if (typeof options.escape !== \"string\") {\n    return [\n      Error(\n        `Invalid Option: escape must be a buffer or a string, got ${JSON.stringify(options.escape)}`,\n      ),\n    ];\n  }\n  if (options.escape.length > 1) {\n    return [\n      Error(\n        `Invalid Option: escape must be one character, got ${options.escape.length} characters`,\n      ),\n    ];\n  }\n  // Normalize option `header`\n  if (options.header === undefined || options.header === null) {\n    options.header = false;\n  }\n  // Normalize option `columns`\n  const [errColumns, columns] = normalize_columns(options.columns);\n  if (errColumns !== undefined) return [errColumns];\n  options.columns = columns;\n  // Normalize option `quoted`\n  if (options.quoted === undefined || options.quoted === null) {\n    options.quoted = false;\n  }\n  // Normalize option `cast`\n  if (options.cast === undefined || options.cast === null) {\n    options.cast = {};\n  }\n  // Normalize option cast.bigint\n  if (options.cast.bigint === undefined || options.cast.bigint === null) {\n    // Cast boolean to string by default\n    options.cast.bigint = (value) => \"\" + value;\n  }\n  // Normalize option cast.boolean\n  if (options.cast.boolean === undefined || options.cast.boolean === null) {\n    // Cast boolean to string by default\n    options.cast.boolean = (value) => (value ? \"1\" : \"\");\n  }\n  // Normalize option cast.date\n  if (options.cast.date === undefined || options.cast.date === null) {\n    // Cast date to timestamp string by default\n    options.cast.date = (value) => \"\" + value.getTime();\n  }\n  // Normalize option cast.number\n  if (options.cast.number === undefined || options.cast.number === null) {\n    // Cast number to string using native casting by default\n    options.cast.number = (value) => \"\" + value;\n  }\n  // Normalize option cast.object\n  if (options.cast.object === undefined || options.cast.object === null) {\n    // Stringify object as JSON by default\n    options.cast.object = (value) => JSON.stringify(value);\n  }\n  // Normalize option cast.string\n  if (options.cast.string === undefined || options.cast.string === null) {\n    // Leave string untouched\n    options.cast.string = function (value) {\n      return value;\n    };\n  }\n  // Normalize option `on_record`\n  if (\n    options.on_record !== undefined &&\n    typeof options.on_record !== \"function\"\n  ) {\n    return [Error(`Invalid Option: \"on_record\" must be a function.`)];\n  }\n  // Normalize option `record_delimiter`\n  if (\n    options.record_delimiter === undefined ||\n    options.record_delimiter === null\n  ) {\n    options.record_delimiter = \"\\n\";\n  } else if (Buffer.isBuffer(options.record_delimiter)) {\n    options.record_delimiter = options.record_delimiter.toString();\n  } else if (typeof options.record_delimiter !== \"string\") {\n    return [\n      Error(\n        `Invalid Option: record_delimiter must be a buffer or a string, got ${JSON.stringify(options.record_delimiter)}`,\n      ),\n    ];\n  }\n  switch (options.record_delimiter) {\n    case \"unix\":\n      options.record_delimiter = \"\\n\";\n      break;\n    case \"mac\":\n      options.record_delimiter = \"\\r\";\n      break;\n    case \"windows\":\n      options.record_delimiter = \"\\r\\n\";\n      break;\n    case \"ascii\":\n      options.record_delimiter = \"\\u001e\";\n      break;\n    case \"unicode\":\n      options.record_delimiter = \"\\u2028\";\n      break;\n  }\n  return [undefined, options];\n};\n\nconst bom_utf8 = Buffer.from([239, 187, 191]);\n\nconst stringifier = function (options, state, info) {\n  return {\n    options: options,\n    state: state,\n    info: info,\n    __transform: function (chunk, push) {\n      // Chunk validation\n      if (!Array.isArray(chunk) && typeof chunk !== \"object\") {\n        return Error(\n          `Invalid Record: expect an array or an object, got ${JSON.stringify(chunk)}`,\n        );\n      }\n      // Detect columns from the first record\n      if (this.info.records === 0) {\n        if (Array.isArray(chunk)) {\n          if (\n            this.options.header === true &&\n            this.options.columns === undefined\n          ) {\n            return Error(\n              \"Undiscoverable Columns: header option requires column option or object records\",\n            );\n          }\n        } else if (this.options.columns === undefined) {\n          const [err, columns] = normalize_columns(Object.keys(chunk));\n          if (err) return;\n          this.options.columns = columns;\n        }\n      }\n      // Emit the header\n      if (this.info.records === 0) {\n        this.bom(push);\n        const err = this.headers(push);\n        if (err) return err;\n      }\n      // Emit and stringify the record if an object or an array\n      try {\n        // this.emit('record', chunk, this.info.records);\n        if (this.options.on_record) {\n          this.options.on_record(chunk, this.info.records);\n        }\n      } catch (err) {\n        return err;\n      }\n      // Convert the record into a string\n      let err, chunk_string;\n      if (this.options.eof) {\n        [err, chunk_string] = this.stringify(chunk);\n        if (err) return err;\n        if (chunk_string === undefined) {\n          return;\n        } else {\n          chunk_string = chunk_string + this.options.record_delimiter;\n        }\n      } else {\n        [err, chunk_string] = this.stringify(chunk);\n        if (err) return err;\n        if (chunk_string === undefined) {\n          return;\n        } else {\n          if (this.options.header || this.info.records) {\n            chunk_string = this.options.record_delimiter + chunk_string;\n          }\n        }\n      }\n      // Emit the csv\n      this.info.records++;\n      push(chunk_string);\n    },\n    stringify: function (chunk, chunkIsHeader = false) {\n      if (typeof chunk !== \"object\") {\n        return [undefined, chunk];\n      }\n      const { columns } = this.options;\n      const record = [];\n      // Record is an array\n      if (Array.isArray(chunk)) {\n        // We are getting an array but the user has specified output columns. In\n        // this case, we respect the columns indexes\n        if (columns) {\n          chunk.splice(columns.length);\n        }\n        // Cast record elements\n        for (let i = 0; i < chunk.length; i++) {\n          const field = chunk[i];\n          const [err, value] = this.__cast(field, {\n            index: i,\n            column: i,\n            records: this.info.records,\n            header: chunkIsHeader,\n          });\n          if (err) return [err];\n          record[i] = [value, field];\n        }\n        // Record is a literal object\n        // `columns` is always defined: it is either provided or discovered.\n      } else {\n        for (let i = 0; i < columns.length; i++) {\n          const field = get(chunk, columns[i].key);\n          const [err, value] = this.__cast(field, {\n            index: i,\n            column: columns[i].key,\n            records: this.info.records,\n            header: chunkIsHeader,\n          });\n          if (err) return [err];\n          record[i] = [value, field];\n        }\n      }\n      let csvrecord = \"\";\n      for (let i = 0; i < record.length; i++) {\n        let options, err;\n\n        let [value, field] = record[i];\n        if (typeof value === \"string\") {\n          options = this.options;\n        } else if (is_object(value)) {\n          options = value;\n          value = options.value;\n          delete options.value;\n          if (\n            typeof value !== \"string\" &&\n            value !== undefined &&\n            value !== null\n          ) {\n            if (err)\n              return [\n                Error(\n                  `Invalid Casting Value: returned value must return a string, null or undefined, got ${JSON.stringify(value)}`,\n                ),\n              ];\n          }\n          options = { ...this.options, ...options };\n          [err, options] = normalize_options(options);\n          if (err !== undefined) {\n            return [err];\n          }\n        } else if (value === undefined || value === null) {\n          options = this.options;\n        } else {\n          return [\n            Error(\n              `Invalid Casting Value: returned value must return a string, an object, null or undefined, got ${JSON.stringify(value)}`,\n            ),\n          ];\n        }\n        const {\n          delimiter,\n          escape,\n          quote,\n          quoted,\n          quoted_empty,\n          quoted_string,\n          quoted_match,\n          record_delimiter,\n          escape_formulas,\n        } = options;\n        if (\"\" === value && \"\" === field) {\n          let quotedMatch =\n            quoted_match &&\n            quoted_match.filter((quoted_match) => {\n              if (typeof quoted_match === \"string\") {\n                return value.indexOf(quoted_match) !== -1;\n              } else {\n                return quoted_match.test(value);\n              }\n            });\n          quotedMatch = quotedMatch && quotedMatch.length > 0;\n          const shouldQuote =\n            quotedMatch ||\n            true === quoted_empty ||\n            (true === quoted_string && false !== quoted_empty);\n          if (shouldQuote === true) {\n            value = quote + value + quote;\n          }\n          csvrecord += value;\n        } else if (value) {\n          if (typeof value !== \"string\") {\n            return [\n              Error(\n                `Formatter must return a string, null or undefined, got ${JSON.stringify(value)}`,\n              ),\n            ];\n          }\n          const containsdelimiter =\n            delimiter.length && value.indexOf(delimiter) >= 0;\n          const containsQuote = quote !== \"\" && value.indexOf(quote) >= 0;\n          const containsEscape = value.indexOf(escape) >= 0 && escape !== quote;\n          const containsRecordDelimiter = value.indexOf(record_delimiter) >= 0;\n          const quotedString = quoted_string && typeof field === \"string\";\n          let quotedMatch =\n            quoted_match &&\n            quoted_match.filter((quoted_match) => {\n              if (typeof quoted_match === \"string\") {\n                return value.indexOf(quoted_match) !== -1;\n              } else {\n                return quoted_match.test(value);\n              }\n            });\n          quotedMatch = quotedMatch && quotedMatch.length > 0;\n          // See https://github.com/adaltas/node-csv/pull/387\n          // More about CSV injection or formula injection, when websites embed\n          // untrusted input inside CSV files:\n          // https://owasp.org/www-community/attacks/CSV_Injection\n          // http://georgemauer.net/2017/10/07/csv-injection.html\n          // Apple Numbers unicode normalization is empirical from testing\n          if (escape_formulas) {\n            switch (value[0]) {\n              case \"=\":\n              case \"+\":\n              case \"-\":\n              case \"@\":\n              case \"\\t\":\n              case \"\\r\":\n              case \"\\uFF1D\": // Unicode '='\n              case \"\\uFF0B\": // Unicode '+'\n              case \"\\uFF0D\": // Unicode '-'\n              case \"\\uFF20\": // Unicode '@'\n                value = `'${value}`;\n                break;\n            }\n          }\n          const shouldQuote =\n            containsQuote === true ||\n            containsdelimiter ||\n            containsRecordDelimiter ||\n            quoted ||\n            quotedString ||\n            quotedMatch;\n          if (shouldQuote === true && containsEscape === true) {\n            const regexp =\n              escape === \"\\\\\"\n                ? new RegExp(escape + escape, \"g\")\n                : new RegExp(escape, \"g\");\n            value = value.replace(regexp, escape + escape);\n          }\n          if (containsQuote === true) {\n            const regexp = new RegExp(quote, \"g\");\n            value = value.replace(regexp, escape + quote);\n          }\n          if (shouldQuote === true) {\n            value = quote + value + quote;\n          }\n          csvrecord += value;\n        } else if (\n          quoted_empty === true ||\n          (field === \"\" && quoted_string === true && quoted_empty !== false)\n        ) {\n          csvrecord += quote + quote;\n        }\n        if (i !== record.length - 1) {\n          csvrecord += delimiter;\n        }\n      }\n      return [undefined, csvrecord];\n    },\n    bom: function (push) {\n      if (this.options.bom !== true) {\n        return;\n      }\n      push(bom_utf8);\n    },\n    headers: function (push) {\n      if (this.options.header === false) {\n        return;\n      }\n      if (this.options.columns === undefined) {\n        return;\n      }\n      let err;\n      let headers = this.options.columns.map((column) => column.header);\n      if (this.options.eof) {\n        [err, headers] = this.stringify(headers, true);\n        headers += this.options.record_delimiter;\n      } else {\n        [err, headers] = this.stringify(headers);\n      }\n      if (err) return err;\n      push(headers);\n    },\n    __cast: function (value, context) {\n      const type = typeof value;\n      try {\n        if (type === \"string\") {\n          // Fine for 99% of the cases\n          return [undefined, this.options.cast.string(value, context)];\n        } else if (type === \"bigint\") {\n          return [undefined, this.options.cast.bigint(value, context)];\n        } else if (type === \"number\") {\n          return [undefined, this.options.cast.number(value, context)];\n        } else if (type === \"boolean\") {\n          return [undefined, this.options.cast.boolean(value, context)];\n        } else if (value instanceof Date) {\n          return [undefined, this.options.cast.date(value, context)];\n        } else if (type === \"object\" && value !== null) {\n          return [undefined, this.options.cast.object(value, context)];\n        } else {\n          return [undefined, value, value];\n        }\n      } catch (err) {\n        return [err];\n      }\n    },\n  };\n};\n\n/*\nCSV Stringify\n\nPlease look at the [project documentation](https://csv.js.org/stringify/) for\nadditional information.\n*/\n\n\nclass Stringifier extends stream.Transform {\n  constructor(opts = {}) {\n    super({ ...{ writableObjectMode: true }, ...opts });\n    const [err, options] = normalize_options(opts);\n    if (err !== undefined) throw err;\n    // Expose options\n    this.options = options;\n    // Internal state\n    this.state = {\n      stop: false,\n    };\n    // Information\n    this.info = {\n      records: 0,\n    };\n    this.api = stringifier(this.options, this.state, this.info);\n    this.api.options.on_record = (...args) => {\n      this.emit(\"record\", ...args);\n    };\n  }\n  _transform(chunk, encoding, callback) {\n    if (this.state.stop === true) {\n      return;\n    }\n    const err = this.api.__transform(chunk, this.push.bind(this));\n    if (err !== undefined) {\n      this.state.stop = true;\n    }\n    callback(err);\n  }\n  _flush(callback) {\n    if (this.state.stop === true) {\n      // Note, Node.js 12 call flush even after an error, we must prevent\n      // `callback` from being called in flush without any error.\n      return;\n    }\n    if (this.info.records === 0) {\n      this.api.bom(this.push.bind(this));\n      const err = this.api.headers(this.push.bind(this));\n      if (err) callback(err);\n    }\n    callback();\n  }\n}\n\nconst stringify = function () {\n  let data, options, callback;\n  for (const i in arguments) {\n    const argument = arguments[i];\n    const type = typeof argument;\n    if (data === undefined && Array.isArray(argument)) {\n      data = argument;\n    } else if (options === undefined && is_object(argument)) {\n      options = argument;\n    } else if (callback === undefined && type === \"function\") {\n      callback = argument;\n    } else {\n      throw new CsvError(\"CSV_INVALID_ARGUMENT\", [\n        \"Invalid argument:\",\n        `got ${JSON.stringify(argument)} at index ${i}`,\n      ]);\n    }\n  }\n  const stringifier = new Stringifier(options);\n  if (callback) {\n    const chunks = [];\n    stringifier.on(\"readable\", function () {\n      let chunk;\n      while ((chunk = this.read()) !== null) {\n        chunks.push(chunk);\n      }\n    });\n    stringifier.on(\"error\", function (err) {\n      callback(err);\n    });\n    stringifier.on(\"end\", function () {\n      try {\n        callback(undefined, chunks.join(\"\"));\n      } catch (err) {\n        // This can happen if the `chunks` is extremely long; it may throw\n        // \"Cannot create a string longer than 0x1fffffe8 characters\"\n        // See [#386](https://github.com/adaltas/node-csv/pull/386)\n        callback(err);\n        return;\n      }\n    });\n  }\n  if (data !== undefined) {\n    const writer = function () {\n      for (const record of data) {\n        stringifier.write(record);\n      }\n      stringifier.end();\n    };\n    // Support Deno, Rollup doesnt provide a shim for setImmediate\n    if (typeof setImmediate === \"function\") {\n      setImmediate(writer);\n    } else {\n      setTimeout(writer, 0);\n    }\n  }\n  return stringifier;\n};\n\nexports.CsvError = CsvError;\nexports.Stringifier = Stringifier;\nexports.stringify = stringify;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY3N2LXN0cmluZ2lmeS9kaXN0L2Nqcy9pbmRleC5janMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsYUFBYSxtQkFBTyxDQUFDLHNCQUFROztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxlQUFlLDRCQUE0QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQ0FBa0M7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOEJBQThCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0NBQXdDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLDZCQUE2QjtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0Esb0VBQW9FLCtCQUErQjtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsdUJBQXVCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSw4RUFBOEUseUNBQXlDO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxzQkFBc0I7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBbUI7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3R0FBd0csc0JBQXNCO0FBQzlIO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsK0dBQStHLHNCQUFzQjtBQUNySTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLHNCQUFzQjtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsTUFBTTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsdUJBQXVCO0FBQ3ZCLFlBQVksS0FBSywwQkFBMEIsV0FBVztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxlQUFlLDBCQUEwQixXQUFXLEVBQUU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUiw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCO0FBQ2hCLG1CQUFtQjtBQUNuQixpQkFBaUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9uZXpvYmVuYXJkaS9BSV9zdHVmZi9PbmJvYXJkaW5nUG9ydGFsL25vZGVfbW9kdWxlcy9jc3Ytc3RyaW5naWZ5L2Rpc3QvY2pzL2luZGV4LmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBzdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxuY2xhc3MgQ3N2RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNvZGUsIG1lc3NhZ2UsIC4uLmNvbnRleHRzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobWVzc2FnZSkpIG1lc3NhZ2UgPSBtZXNzYWdlLmpvaW4oXCIgXCIpO1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBDc3ZFcnJvcik7XG4gICAgfVxuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgZm9yIChjb25zdCBjb250ZXh0IG9mIGNvbnRleHRzKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gY29udGV4dFtrZXldO1xuICAgICAgICB0aGlzW2tleV0gPSBCdWZmZXIuaXNCdWZmZXIodmFsdWUpXG4gICAgICAgICAgPyB2YWx1ZS50b1N0cmluZygpXG4gICAgICAgICAgOiB2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgICA/IHZhbHVlXG4gICAgICAgICAgICA6IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuY29uc3QgaXNfb2JqZWN0ID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJiBvYmogIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkob2JqKTtcbn07XG5cbi8vIExvZGFzaCBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0YFxuXG5jb25zdCBjaGFyQ29kZU9mRG90ID0gXCIuXCIuY2hhckNvZGVBdCgwKTtcbmNvbnN0IHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuY29uc3QgcmVQcm9wTmFtZSA9IFJlZ0V4cChcbiAgLy8gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIGRvdCBvciBicmFja2V0LlxuICBcIlteLltcXFxcXV0rXCIgK1xuICAgIFwifFwiICtcbiAgICAvLyBPciBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gYnJhY2tldHMuXG4gICAgXCJcXFxcWyg/OlwiICtcbiAgICAvLyBNYXRjaCBhIG5vbi1zdHJpbmcgZXhwcmVzc2lvbi5cbiAgICBcIihbXlxcXCInXVteW10qKVwiICtcbiAgICBcInxcIiArXG4gICAgLy8gT3IgbWF0Y2ggc3RyaW5ncyAoc3VwcG9ydHMgZXNjYXBpbmcgY2hhcmFjdGVycykuXG4gICAgXCIoW1xcXCInXSkoKD86KD8hXFxcXDIpW15cXFxcXFxcXF18XFxcXFxcXFwuKSo/KVxcXFwyXCIgK1xuICAgIFwiKVxcXFxdXCIgK1xuICAgIFwifFwiICtcbiAgICAvLyBPciBtYXRjaCBcIlwiIGFzIHRoZSBzcGFjZSBiZXR3ZWVuIGNvbnNlY3V0aXZlIGRvdHMgb3IgZW1wdHkgYnJhY2tldHMuXG4gICAgXCIoPz0oPzpcXFxcLnxcXFxcW1xcXFxdKSg/OlxcXFwufFxcXFxbXFxcXF18JCkpXCIsXG4gIFwiZ1wiLFxuKTtcbmNvbnN0IHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS87XG5jb25zdCByZUlzUGxhaW5Qcm9wID0gL15cXHcqJC87XG5cbmNvbnN0IGdldFRhZyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAvLyBpZiAoIXZhbHVlKSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gXCJbb2JqZWN0IFVuZGVmaW5lZF1cIiA6IFwiW29iamVjdCBOdWxsXVwiO1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbn07XG5cbmNvbnN0IGlzU3ltYm9sID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAoXG4gICAgdHlwZSA9PT0gXCJzeW1ib2xcIiB8fFxuICAgICh0eXBlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICYmIGdldFRhZyh2YWx1ZSkgPT09IFwiW29iamVjdCBTeW1ib2xdXCIpXG4gICk7XG59O1xuXG5jb25zdCBpc0tleSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAoXG4gICAgdHlwZSA9PT0gXCJudW1iZXJcIiB8fFxuICAgIHR5cGUgPT09IFwic3ltYm9sXCIgfHxcbiAgICB0eXBlID09PSBcImJvb2xlYW5cIiB8fFxuICAgICF2YWx1ZSB8fFxuICAgIGlzU3ltYm9sKHZhbHVlKVxuICApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gKFxuICAgIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHxcbiAgICAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKVxuICApO1xufTtcblxuY29uc3Qgc3RyaW5nVG9QYXRoID0gZnVuY3Rpb24gKHN0cmluZykge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KDApID09PSBjaGFyQ29kZU9mRG90KSB7XG4gICAgcmVzdWx0LnB1c2goXCJcIik7XG4gIH1cbiAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24gKG1hdGNoLCBleHByZXNzaW9uLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG4gICAgbGV0IGtleSA9IG1hdGNoO1xuICAgIGlmIChxdW90ZSkge1xuICAgICAga2V5ID0gc3ViU3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCBcIiQxXCIpO1xuICAgIH0gZWxzZSBpZiAoZXhwcmVzc2lvbikge1xuICAgICAga2V5ID0gZXhwcmVzc2lvbi50cmltKCk7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuY29uc3QgY2FzdFBhdGggPSBmdW5jdGlvbiAodmFsdWUsIG9iamVjdCkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGlzS2V5KHZhbHVlLCBvYmplY3QpID8gW3ZhbHVlXSA6IHN0cmluZ1RvUGF0aCh2YWx1ZSk7XG4gIH1cbn07XG5cbmNvbnN0IHRvS2V5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgaXNTeW1ib2wodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gIGNvbnN0IHJlc3VsdCA9IGAke3ZhbHVlfWA7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICByZXR1cm4gcmVzdWx0ID09IFwiMFwiICYmIDEgLyB2YWx1ZSA9PSAtSU5GSU5JVFkgPyBcIi0wXCIgOiByZXN1bHQ7XG59O1xuXG5jb25zdCBnZXQgPSBmdW5jdGlvbiAob2JqZWN0LCBwYXRoKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuICBsZXQgaW5kZXggPSAwO1xuICBjb25zdCBsZW5ndGggPSBwYXRoLmxlbmd0aDtcbiAgd2hpbGUgKG9iamVjdCAhPSBudWxsICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgb2JqZWN0ID0gb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXgrK10pXTtcbiAgfVxuICByZXR1cm4gaW5kZXggJiYgaW5kZXggPT09IGxlbmd0aCA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbn07XG5cbmNvbnN0IG5vcm1hbGl6ZV9jb2x1bW5zID0gZnVuY3Rpb24gKGNvbHVtbnMpIHtcbiAgaWYgKGNvbHVtbnMgPT09IHVuZGVmaW5lZCB8fCBjb2x1bW5zID09PSBudWxsKSB7XG4gICAgcmV0dXJuIFt1bmRlZmluZWQsIHVuZGVmaW5lZF07XG4gIH1cbiAgaWYgKHR5cGVvZiBjb2x1bW5zICE9PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIFtFcnJvcignSW52YWxpZCBvcHRpb24gXCJjb2x1bW5zXCI6IGV4cGVjdCBhbiBhcnJheSBvciBhbiBvYmplY3QnKV07XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KGNvbHVtbnMpKSB7XG4gICAgY29uc3QgbmV3Y29sdW1ucyA9IFtdO1xuICAgIGZvciAoY29uc3QgayBpbiBjb2x1bW5zKSB7XG4gICAgICBuZXdjb2x1bW5zLnB1c2goe1xuICAgICAgICBrZXk6IGssXG4gICAgICAgIGhlYWRlcjogY29sdW1uc1trXSxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb2x1bW5zID0gbmV3Y29sdW1ucztcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBuZXdjb2x1bW5zID0gW107XG4gICAgZm9yIChjb25zdCBjb2x1bW4gb2YgY29sdW1ucykge1xuICAgICAgaWYgKHR5cGVvZiBjb2x1bW4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbmV3Y29sdW1ucy5wdXNoKHtcbiAgICAgICAgICBrZXk6IGNvbHVtbixcbiAgICAgICAgICBoZWFkZXI6IGNvbHVtbixcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICB0eXBlb2YgY29sdW1uID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIGNvbHVtbiAhPT0gbnVsbCAmJlxuICAgICAgICAhQXJyYXkuaXNBcnJheShjb2x1bW4pXG4gICAgICApIHtcbiAgICAgICAgaWYgKCFjb2x1bW4ua2V5KSB7XG4gICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIEVycm9yKCdJbnZhbGlkIGNvbHVtbiBkZWZpbml0aW9uOiBwcm9wZXJ0eSBcImtleVwiIGlzIHJlcXVpcmVkJyksXG4gICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29sdW1uLmhlYWRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY29sdW1uLmhlYWRlciA9IGNvbHVtbi5rZXk7XG4gICAgICAgIH1cbiAgICAgICAgbmV3Y29sdW1ucy5wdXNoKGNvbHVtbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIEVycm9yKFwiSW52YWxpZCBjb2x1bW4gZGVmaW5pdGlvbjogZXhwZWN0IGEgc3RyaW5nIG9yIGFuIG9iamVjdFwiKSxcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29sdW1ucyA9IG5ld2NvbHVtbnM7XG4gIH1cbiAgcmV0dXJuIFt1bmRlZmluZWQsIGNvbHVtbnNdO1xufTtcblxuY29uc3QgdW5kZXJzY29yZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oW0EtWl0pL2csIGZ1bmN0aW9uIChfLCBtYXRjaCkge1xuICAgIHJldHVybiBcIl9cIiArIG1hdGNoLnRvTG93ZXJDYXNlKCk7XG4gIH0pO1xufTtcblxuY29uc3Qgbm9ybWFsaXplX29wdGlvbnMgPSBmdW5jdGlvbiAob3B0cykge1xuICBjb25zdCBvcHRpb25zID0ge307XG4gIC8vIE1lcmdlIHdpdGggdXNlciBvcHRpb25zXG4gIGZvciAoY29uc3Qgb3B0IGluIG9wdHMpIHtcbiAgICBvcHRpb25zW3VuZGVyc2NvcmUob3B0KV0gPSBvcHRzW29wdF07XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgYm9tYFxuICBpZiAoXG4gICAgb3B0aW9ucy5ib20gPT09IHVuZGVmaW5lZCB8fFxuICAgIG9wdGlvbnMuYm9tID09PSBudWxsIHx8XG4gICAgb3B0aW9ucy5ib20gPT09IGZhbHNlXG4gICkge1xuICAgIG9wdGlvbnMuYm9tID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5ib20gIT09IHRydWUpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbmV3IENzdkVycm9yKFwiQ1NWX09QVElPTl9CT09MRUFOX0lOVkFMSURfVFlQRVwiLCBbXG4gICAgICAgIFwib3B0aW9uIGBib21gIGlzIG9wdGlvbmFsIGFuZCBtdXN0IGJlIGEgYm9vbGVhbiB2YWx1ZSxcIixcbiAgICAgICAgYGdvdCAke0pTT04uc3RyaW5naWZ5KG9wdGlvbnMuYm9tKX1gLFxuICAgICAgXSksXG4gICAgXTtcbiAgfVxuICAvLyBOb3JtYWxpemUgb3B0aW9uIGBkZWxpbWl0ZXJgXG4gIGlmIChvcHRpb25zLmRlbGltaXRlciA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuZGVsaW1pdGVyID09PSBudWxsKSB7XG4gICAgb3B0aW9ucy5kZWxpbWl0ZXIgPSBcIixcIjtcbiAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIob3B0aW9ucy5kZWxpbWl0ZXIpKSB7XG4gICAgb3B0aW9ucy5kZWxpbWl0ZXIgPSBvcHRpb25zLmRlbGltaXRlci50b1N0cmluZygpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmRlbGltaXRlciAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBbXG4gICAgICBuZXcgQ3N2RXJyb3IoXCJDU1ZfT1BUSU9OX0RFTElNSVRFUl9JTlZBTElEX1RZUEVcIiwgW1xuICAgICAgICBcIm9wdGlvbiBgZGVsaW1pdGVyYCBtdXN0IGJlIGEgYnVmZmVyIG9yIGEgc3RyaW5nLFwiLFxuICAgICAgICBgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucy5kZWxpbWl0ZXIpfWAsXG4gICAgICBdKSxcbiAgICBdO1xuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gYHF1b3RlYFxuICBpZiAob3B0aW9ucy5xdW90ZSA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMucXVvdGUgPT09IG51bGwpIHtcbiAgICBvcHRpb25zLnF1b3RlID0gJ1wiJztcbiAgfSBlbHNlIGlmIChvcHRpb25zLnF1b3RlID09PSB0cnVlKSB7XG4gICAgb3B0aW9ucy5xdW90ZSA9ICdcIic7XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5xdW90ZSA9PT0gZmFsc2UpIHtcbiAgICBvcHRpb25zLnF1b3RlID0gXCJcIjtcbiAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIob3B0aW9ucy5xdW90ZSkpIHtcbiAgICBvcHRpb25zLnF1b3RlID0gb3B0aW9ucy5xdW90ZS50b1N0cmluZygpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLnF1b3RlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBDc3ZFcnJvcihcIkNTVl9PUFRJT05fUVVPVEVfSU5WQUxJRF9UWVBFXCIsIFtcbiAgICAgICAgXCJvcHRpb24gYHF1b3RlYCBtdXN0IGJlIGEgYm9vbGVhbiwgYSBidWZmZXIgb3IgYSBzdHJpbmcsXCIsXG4gICAgICAgIGBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLnF1b3RlKX1gLFxuICAgICAgXSksXG4gICAgXTtcbiAgfVxuICAvLyBOb3JtYWxpemUgb3B0aW9uIGBxdW90ZWRgXG4gIGlmIChvcHRpb25zLnF1b3RlZCA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMucXVvdGVkID09PSBudWxsKSB7XG4gICAgb3B0aW9ucy5xdW90ZWQgPSBmYWxzZTtcbiAgfVxuICAvLyBOb3JtYWxpemUgb3B0aW9uIGBlc2NhcGVfZm9ybXVsYXNgXG4gIGlmIChcbiAgICBvcHRpb25zLmVzY2FwZV9mb3JtdWxhcyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgb3B0aW9ucy5lc2NhcGVfZm9ybXVsYXMgPT09IG51bGxcbiAgKSB7XG4gICAgb3B0aW9ucy5lc2NhcGVfZm9ybXVsYXMgPSBmYWxzZTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5lc2NhcGVfZm9ybXVsYXMgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBDc3ZFcnJvcihcIkNTVl9PUFRJT05fRVNDQVBFX0ZPUk1VTEFTX0lOVkFMSURfVFlQRVwiLCBbXG4gICAgICAgIFwib3B0aW9uIGBlc2NhcGVfZm9ybXVsYXNgIG11c3QgYmUgYSBib29sZWFuLFwiLFxuICAgICAgICBgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucy5lc2NhcGVfZm9ybXVsYXMpfWAsXG4gICAgICBdKSxcbiAgICBdO1xuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gYHF1b3RlZF9lbXB0eWBcbiAgaWYgKG9wdGlvbnMucXVvdGVkX2VtcHR5ID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5xdW90ZWRfZW1wdHkgPT09IG51bGwpIHtcbiAgICBvcHRpb25zLnF1b3RlZF9lbXB0eSA9IHVuZGVmaW5lZDtcbiAgfVxuICAvLyBOb3JtYWxpemUgb3B0aW9uIGBxdW90ZWRfbWF0Y2hgXG4gIGlmIChcbiAgICBvcHRpb25zLnF1b3RlZF9tYXRjaCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgb3B0aW9ucy5xdW90ZWRfbWF0Y2ggPT09IG51bGwgfHxcbiAgICBvcHRpb25zLnF1b3RlZF9tYXRjaCA9PT0gZmFsc2VcbiAgKSB7XG4gICAgb3B0aW9ucy5xdW90ZWRfbWF0Y2ggPSBudWxsO1xuICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMucXVvdGVkX21hdGNoKSkge1xuICAgIG9wdGlvbnMucXVvdGVkX21hdGNoID0gW29wdGlvbnMucXVvdGVkX21hdGNoXTtcbiAgfVxuICBpZiAob3B0aW9ucy5xdW90ZWRfbWF0Y2gpIHtcbiAgICBmb3IgKGNvbnN0IHF1b3RlZF9tYXRjaCBvZiBvcHRpb25zLnF1b3RlZF9tYXRjaCkge1xuICAgICAgY29uc3QgaXNTdHJpbmcgPSB0eXBlb2YgcXVvdGVkX21hdGNoID09PSBcInN0cmluZ1wiO1xuICAgICAgY29uc3QgaXNSZWdFeHAgPSBxdW90ZWRfbWF0Y2ggaW5zdGFuY2VvZiBSZWdFeHA7XG4gICAgICBpZiAoIWlzU3RyaW5nICYmICFpc1JlZ0V4cCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIEVycm9yKFxuICAgICAgICAgICAgYEludmFsaWQgT3B0aW9uOiBxdW90ZWRfbWF0Y2ggbXVzdCBiZSBhIHN0cmluZyBvciBhIHJlZ2V4LCBnb3QgJHtKU09OLnN0cmluZ2lmeShxdW90ZWRfbWF0Y2gpfWAsXG4gICAgICAgICAgKSxcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgcXVvdGVkX3N0cmluZ2BcbiAgaWYgKG9wdGlvbnMucXVvdGVkX3N0cmluZyA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMucXVvdGVkX3N0cmluZyA9PT0gbnVsbCkge1xuICAgIG9wdGlvbnMucXVvdGVkX3N0cmluZyA9IGZhbHNlO1xuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gYGVvZmBcbiAgaWYgKG9wdGlvbnMuZW9mID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5lb2YgPT09IG51bGwpIHtcbiAgICBvcHRpb25zLmVvZiA9IHRydWU7XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgZXNjYXBlYFxuICBpZiAob3B0aW9ucy5lc2NhcGUgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmVzY2FwZSA9PT0gbnVsbCkge1xuICAgIG9wdGlvbnMuZXNjYXBlID0gJ1wiJztcbiAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIob3B0aW9ucy5lc2NhcGUpKSB7XG4gICAgb3B0aW9ucy5lc2NhcGUgPSBvcHRpb25zLmVzY2FwZS50b1N0cmluZygpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmVzY2FwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBbXG4gICAgICBFcnJvcihcbiAgICAgICAgYEludmFsaWQgT3B0aW9uOiBlc2NhcGUgbXVzdCBiZSBhIGJ1ZmZlciBvciBhIHN0cmluZywgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucy5lc2NhcGUpfWAsXG4gICAgICApLFxuICAgIF07XG4gIH1cbiAgaWYgKG9wdGlvbnMuZXNjYXBlLmxlbmd0aCA+IDEpIHtcbiAgICByZXR1cm4gW1xuICAgICAgRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIE9wdGlvbjogZXNjYXBlIG11c3QgYmUgb25lIGNoYXJhY3RlciwgZ290ICR7b3B0aW9ucy5lc2NhcGUubGVuZ3RofSBjaGFyYWN0ZXJzYCxcbiAgICAgICksXG4gICAgXTtcbiAgfVxuICAvLyBOb3JtYWxpemUgb3B0aW9uIGBoZWFkZXJgXG4gIGlmIChvcHRpb25zLmhlYWRlciA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuaGVhZGVyID09PSBudWxsKSB7XG4gICAgb3B0aW9ucy5oZWFkZXIgPSBmYWxzZTtcbiAgfVxuICAvLyBOb3JtYWxpemUgb3B0aW9uIGBjb2x1bW5zYFxuICBjb25zdCBbZXJyQ29sdW1ucywgY29sdW1uc10gPSBub3JtYWxpemVfY29sdW1ucyhvcHRpb25zLmNvbHVtbnMpO1xuICBpZiAoZXJyQ29sdW1ucyAhPT0gdW5kZWZpbmVkKSByZXR1cm4gW2VyckNvbHVtbnNdO1xuICBvcHRpb25zLmNvbHVtbnMgPSBjb2x1bW5zO1xuICAvLyBOb3JtYWxpemUgb3B0aW9uIGBxdW90ZWRgXG4gIGlmIChvcHRpb25zLnF1b3RlZCA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMucXVvdGVkID09PSBudWxsKSB7XG4gICAgb3B0aW9ucy5xdW90ZWQgPSBmYWxzZTtcbiAgfVxuICAvLyBOb3JtYWxpemUgb3B0aW9uIGBjYXN0YFxuICBpZiAob3B0aW9ucy5jYXN0ID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5jYXN0ID09PSBudWxsKSB7XG4gICAgb3B0aW9ucy5jYXN0ID0ge307XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBjYXN0LmJpZ2ludFxuICBpZiAob3B0aW9ucy5jYXN0LmJpZ2ludCA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuY2FzdC5iaWdpbnQgPT09IG51bGwpIHtcbiAgICAvLyBDYXN0IGJvb2xlYW4gdG8gc3RyaW5nIGJ5IGRlZmF1bHRcbiAgICBvcHRpb25zLmNhc3QuYmlnaW50ID0gKHZhbHVlKSA9PiBcIlwiICsgdmFsdWU7XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBjYXN0LmJvb2xlYW5cbiAgaWYgKG9wdGlvbnMuY2FzdC5ib29sZWFuID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5jYXN0LmJvb2xlYW4gPT09IG51bGwpIHtcbiAgICAvLyBDYXN0IGJvb2xlYW4gdG8gc3RyaW5nIGJ5IGRlZmF1bHRcbiAgICBvcHRpb25zLmNhc3QuYm9vbGVhbiA9ICh2YWx1ZSkgPT4gKHZhbHVlID8gXCIxXCIgOiBcIlwiKTtcbiAgfVxuICAvLyBOb3JtYWxpemUgb3B0aW9uIGNhc3QuZGF0ZVxuICBpZiAob3B0aW9ucy5jYXN0LmRhdGUgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmNhc3QuZGF0ZSA9PT0gbnVsbCkge1xuICAgIC8vIENhc3QgZGF0ZSB0byB0aW1lc3RhbXAgc3RyaW5nIGJ5IGRlZmF1bHRcbiAgICBvcHRpb25zLmNhc3QuZGF0ZSA9ICh2YWx1ZSkgPT4gXCJcIiArIHZhbHVlLmdldFRpbWUoKTtcbiAgfVxuICAvLyBOb3JtYWxpemUgb3B0aW9uIGNhc3QubnVtYmVyXG4gIGlmIChvcHRpb25zLmNhc3QubnVtYmVyID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5jYXN0Lm51bWJlciA9PT0gbnVsbCkge1xuICAgIC8vIENhc3QgbnVtYmVyIHRvIHN0cmluZyB1c2luZyBuYXRpdmUgY2FzdGluZyBieSBkZWZhdWx0XG4gICAgb3B0aW9ucy5jYXN0Lm51bWJlciA9ICh2YWx1ZSkgPT4gXCJcIiArIHZhbHVlO1xuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gY2FzdC5vYmplY3RcbiAgaWYgKG9wdGlvbnMuY2FzdC5vYmplY3QgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmNhc3Qub2JqZWN0ID09PSBudWxsKSB7XG4gICAgLy8gU3RyaW5naWZ5IG9iamVjdCBhcyBKU09OIGJ5IGRlZmF1bHRcbiAgICBvcHRpb25zLmNhc3Qub2JqZWN0ID0gKHZhbHVlKSA9PiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBjYXN0LnN0cmluZ1xuICBpZiAob3B0aW9ucy5jYXN0LnN0cmluZyA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuY2FzdC5zdHJpbmcgPT09IG51bGwpIHtcbiAgICAvLyBMZWF2ZSBzdHJpbmcgdW50b3VjaGVkXG4gICAgb3B0aW9ucy5jYXN0LnN0cmluZyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgb25fcmVjb3JkYFxuICBpZiAoXG4gICAgb3B0aW9ucy5vbl9yZWNvcmQgIT09IHVuZGVmaW5lZCAmJlxuICAgIHR5cGVvZiBvcHRpb25zLm9uX3JlY29yZCAhPT0gXCJmdW5jdGlvblwiXG4gICkge1xuICAgIHJldHVybiBbRXJyb3IoYEludmFsaWQgT3B0aW9uOiBcIm9uX3JlY29yZFwiIG11c3QgYmUgYSBmdW5jdGlvbi5gKV07XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgcmVjb3JkX2RlbGltaXRlcmBcbiAgaWYgKFxuICAgIG9wdGlvbnMucmVjb3JkX2RlbGltaXRlciA9PT0gdW5kZWZpbmVkIHx8XG4gICAgb3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyID09PSBudWxsXG4gICkge1xuICAgIG9wdGlvbnMucmVjb3JkX2RlbGltaXRlciA9IFwiXFxuXCI7XG4gIH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKG9wdGlvbnMucmVjb3JkX2RlbGltaXRlcikpIHtcbiAgICBvcHRpb25zLnJlY29yZF9kZWxpbWl0ZXIgPSBvcHRpb25zLnJlY29yZF9kZWxpbWl0ZXIudG9TdHJpbmcoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIEVycm9yKFxuICAgICAgICBgSW52YWxpZCBPcHRpb246IHJlY29yZF9kZWxpbWl0ZXIgbXVzdCBiZSBhIGJ1ZmZlciBvciBhIHN0cmluZywgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyKX1gLFxuICAgICAgKSxcbiAgICBdO1xuICB9XG4gIHN3aXRjaCAob3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyKSB7XG4gICAgY2FzZSBcInVuaXhcIjpcbiAgICAgIG9wdGlvbnMucmVjb3JkX2RlbGltaXRlciA9IFwiXFxuXCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwibWFjXCI6XG4gICAgICBvcHRpb25zLnJlY29yZF9kZWxpbWl0ZXIgPSBcIlxcclwiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIndpbmRvd3NcIjpcbiAgICAgIG9wdGlvbnMucmVjb3JkX2RlbGltaXRlciA9IFwiXFxyXFxuXCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiYXNjaWlcIjpcbiAgICAgIG9wdGlvbnMucmVjb3JkX2RlbGltaXRlciA9IFwiXFx1MDAxZVwiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInVuaWNvZGVcIjpcbiAgICAgIG9wdGlvbnMucmVjb3JkX2RlbGltaXRlciA9IFwiXFx1MjAyOFwiO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIFt1bmRlZmluZWQsIG9wdGlvbnNdO1xufTtcblxuY29uc3QgYm9tX3V0ZjggPSBCdWZmZXIuZnJvbShbMjM5LCAxODcsIDE5MV0pO1xuXG5jb25zdCBzdHJpbmdpZmllciA9IGZ1bmN0aW9uIChvcHRpb25zLCBzdGF0ZSwgaW5mbykge1xuICByZXR1cm4ge1xuICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgc3RhdGU6IHN0YXRlLFxuICAgIGluZm86IGluZm8sXG4gICAgX190cmFuc2Zvcm06IGZ1bmN0aW9uIChjaHVuaywgcHVzaCkge1xuICAgICAgLy8gQ2h1bmsgdmFsaWRhdGlvblxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIEVycm9yKFxuICAgICAgICAgIGBJbnZhbGlkIFJlY29yZDogZXhwZWN0IGFuIGFycmF5IG9yIGFuIG9iamVjdCwgZ290ICR7SlNPTi5zdHJpbmdpZnkoY2h1bmspfWAsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICAvLyBEZXRlY3QgY29sdW1ucyBmcm9tIHRoZSBmaXJzdCByZWNvcmRcbiAgICAgIGlmICh0aGlzLmluZm8ucmVjb3JkcyA9PT0gMCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjaHVuaykpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuaGVhZGVyID09PSB0cnVlICYmXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuY29sdW1ucyA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gRXJyb3IoXG4gICAgICAgICAgICAgIFwiVW5kaXNjb3ZlcmFibGUgQ29sdW1uczogaGVhZGVyIG9wdGlvbiByZXF1aXJlcyBjb2x1bW4gb3B0aW9uIG9yIG9iamVjdCByZWNvcmRzXCIsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuY29sdW1ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY29uc3QgW2VyciwgY29sdW1uc10gPSBub3JtYWxpemVfY29sdW1ucyhPYmplY3Qua2V5cyhjaHVuaykpO1xuICAgICAgICAgIGlmIChlcnIpIHJldHVybjtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuY29sdW1ucyA9IGNvbHVtbnM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEVtaXQgdGhlIGhlYWRlclxuICAgICAgaWYgKHRoaXMuaW5mby5yZWNvcmRzID09PSAwKSB7XG4gICAgICAgIHRoaXMuYm9tKHB1c2gpO1xuICAgICAgICBjb25zdCBlcnIgPSB0aGlzLmhlYWRlcnMocHVzaCk7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBlcnI7XG4gICAgICB9XG4gICAgICAvLyBFbWl0IGFuZCBzdHJpbmdpZnkgdGhlIHJlY29yZCBpZiBhbiBvYmplY3Qgb3IgYW4gYXJyYXlcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIHRoaXMuZW1pdCgncmVjb3JkJywgY2h1bmssIHRoaXMuaW5mby5yZWNvcmRzKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5vbl9yZWNvcmQpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMub25fcmVjb3JkKGNodW5rLCB0aGlzLmluZm8ucmVjb3Jkcyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgfVxuICAgICAgLy8gQ29udmVydCB0aGUgcmVjb3JkIGludG8gYSBzdHJpbmdcbiAgICAgIGxldCBlcnIsIGNodW5rX3N0cmluZztcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZW9mKSB7XG4gICAgICAgIFtlcnIsIGNodW5rX3N0cmluZ10gPSB0aGlzLnN0cmluZ2lmeShjaHVuayk7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBlcnI7XG4gICAgICAgIGlmIChjaHVua19zdHJpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaHVua19zdHJpbmcgPSBjaHVua19zdHJpbmcgKyB0aGlzLm9wdGlvbnMucmVjb3JkX2RlbGltaXRlcjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgW2VyciwgY2h1bmtfc3RyaW5nXSA9IHRoaXMuc3RyaW5naWZ5KGNodW5rKTtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGVycjtcbiAgICAgICAgaWYgKGNodW5rX3N0cmluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGVhZGVyIHx8IHRoaXMuaW5mby5yZWNvcmRzKSB7XG4gICAgICAgICAgICBjaHVua19zdHJpbmcgPSB0aGlzLm9wdGlvbnMucmVjb3JkX2RlbGltaXRlciArIGNodW5rX3N0cmluZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEVtaXQgdGhlIGNzdlxuICAgICAgdGhpcy5pbmZvLnJlY29yZHMrKztcbiAgICAgIHB1c2goY2h1bmtfc3RyaW5nKTtcbiAgICB9LFxuICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKGNodW5rLCBjaHVua0lzSGVhZGVyID0gZmFsc2UpIHtcbiAgICAgIGlmICh0eXBlb2YgY2h1bmsgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIFt1bmRlZmluZWQsIGNodW5rXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgY29sdW1ucyB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgY29uc3QgcmVjb3JkID0gW107XG4gICAgICAvLyBSZWNvcmQgaXMgYW4gYXJyYXlcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNodW5rKSkge1xuICAgICAgICAvLyBXZSBhcmUgZ2V0dGluZyBhbiBhcnJheSBidXQgdGhlIHVzZXIgaGFzIHNwZWNpZmllZCBvdXRwdXQgY29sdW1ucy4gSW5cbiAgICAgICAgLy8gdGhpcyBjYXNlLCB3ZSByZXNwZWN0IHRoZSBjb2x1bW5zIGluZGV4ZXNcbiAgICAgICAgaWYgKGNvbHVtbnMpIHtcbiAgICAgICAgICBjaHVuay5zcGxpY2UoY29sdW1ucy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhc3QgcmVjb3JkIGVsZW1lbnRzXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2h1bmsubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBmaWVsZCA9IGNodW5rW2ldO1xuICAgICAgICAgIGNvbnN0IFtlcnIsIHZhbHVlXSA9IHRoaXMuX19jYXN0KGZpZWxkLCB7XG4gICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgIGNvbHVtbjogaSxcbiAgICAgICAgICAgIHJlY29yZHM6IHRoaXMuaW5mby5yZWNvcmRzLFxuICAgICAgICAgICAgaGVhZGVyOiBjaHVua0lzSGVhZGVyLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChlcnIpIHJldHVybiBbZXJyXTtcbiAgICAgICAgICByZWNvcmRbaV0gPSBbdmFsdWUsIGZpZWxkXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWNvcmQgaXMgYSBsaXRlcmFsIG9iamVjdFxuICAgICAgICAvLyBgY29sdW1uc2AgaXMgYWx3YXlzIGRlZmluZWQ6IGl0IGlzIGVpdGhlciBwcm92aWRlZCBvciBkaXNjb3ZlcmVkLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2x1bW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoY2h1bmssIGNvbHVtbnNbaV0ua2V5KTtcbiAgICAgICAgICBjb25zdCBbZXJyLCB2YWx1ZV0gPSB0aGlzLl9fY2FzdChmaWVsZCwge1xuICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICBjb2x1bW46IGNvbHVtbnNbaV0ua2V5LFxuICAgICAgICAgICAgcmVjb3JkczogdGhpcy5pbmZvLnJlY29yZHMsXG4gICAgICAgICAgICBoZWFkZXI6IGNodW5rSXNIZWFkZXIsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGVycikgcmV0dXJuIFtlcnJdO1xuICAgICAgICAgIHJlY29yZFtpXSA9IFt2YWx1ZSwgZmllbGRdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgY3N2cmVjb3JkID0gXCJcIjtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVjb3JkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBvcHRpb25zLCBlcnI7XG5cbiAgICAgICAgbGV0IFt2YWx1ZSwgZmllbGRdID0gcmVjb3JkW2ldO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgfSBlbHNlIGlmIChpc19vYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IHZhbHVlO1xuICAgICAgICAgIHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICAgICAgICBkZWxldGUgb3B0aW9ucy52YWx1ZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgIHZhbHVlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHZhbHVlICE9PSBudWxsXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIEVycm9yKFxuICAgICAgICAgICAgICAgICAgYEludmFsaWQgQ2FzdGluZyBWYWx1ZTogcmV0dXJuZWQgdmFsdWUgbXVzdCByZXR1cm4gYSBzdHJpbmcsIG51bGwgb3IgdW5kZWZpbmVkLCBnb3QgJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9YCxcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvcHRpb25zID0geyAuLi50aGlzLm9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICBbZXJyLCBvcHRpb25zXSA9IG5vcm1hbGl6ZV9vcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICAgIGlmIChlcnIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIFtlcnJdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgRXJyb3IoXG4gICAgICAgICAgICAgIGBJbnZhbGlkIENhc3RpbmcgVmFsdWU6IHJldHVybmVkIHZhbHVlIG11c3QgcmV0dXJuIGEgc3RyaW5nLCBhbiBvYmplY3QsIG51bGwgb3IgdW5kZWZpbmVkLCBnb3QgJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9YCxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZGVsaW1pdGVyLFxuICAgICAgICAgIGVzY2FwZSxcbiAgICAgICAgICBxdW90ZSxcbiAgICAgICAgICBxdW90ZWQsXG4gICAgICAgICAgcXVvdGVkX2VtcHR5LFxuICAgICAgICAgIHF1b3RlZF9zdHJpbmcsXG4gICAgICAgICAgcXVvdGVkX21hdGNoLFxuICAgICAgICAgIHJlY29yZF9kZWxpbWl0ZXIsXG4gICAgICAgICAgZXNjYXBlX2Zvcm11bGFzLFxuICAgICAgICB9ID0gb3B0aW9ucztcbiAgICAgICAgaWYgKFwiXCIgPT09IHZhbHVlICYmIFwiXCIgPT09IGZpZWxkKSB7XG4gICAgICAgICAgbGV0IHF1b3RlZE1hdGNoID1cbiAgICAgICAgICAgIHF1b3RlZF9tYXRjaCAmJlxuICAgICAgICAgICAgcXVvdGVkX21hdGNoLmZpbHRlcigocXVvdGVkX21hdGNoKSA9PiB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgcXVvdGVkX21hdGNoID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmluZGV4T2YocXVvdGVkX21hdGNoKSAhPT0gLTE7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHF1b3RlZF9tYXRjaC50ZXN0KHZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgcXVvdGVkTWF0Y2ggPSBxdW90ZWRNYXRjaCAmJiBxdW90ZWRNYXRjaC5sZW5ndGggPiAwO1xuICAgICAgICAgIGNvbnN0IHNob3VsZFF1b3RlID1cbiAgICAgICAgICAgIHF1b3RlZE1hdGNoIHx8XG4gICAgICAgICAgICB0cnVlID09PSBxdW90ZWRfZW1wdHkgfHxcbiAgICAgICAgICAgICh0cnVlID09PSBxdW90ZWRfc3RyaW5nICYmIGZhbHNlICE9PSBxdW90ZWRfZW1wdHkpO1xuICAgICAgICAgIGlmIChzaG91bGRRdW90ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSBxdW90ZSArIHZhbHVlICsgcXVvdGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNzdnJlY29yZCArPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgIEVycm9yKFxuICAgICAgICAgICAgICAgIGBGb3JtYXR0ZXIgbXVzdCByZXR1cm4gYSBzdHJpbmcsIG51bGwgb3IgdW5kZWZpbmVkLCBnb3QgJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9YCxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGNvbnRhaW5zZGVsaW1pdGVyID1cbiAgICAgICAgICAgIGRlbGltaXRlci5sZW5ndGggJiYgdmFsdWUuaW5kZXhPZihkZWxpbWl0ZXIpID49IDA7XG4gICAgICAgICAgY29uc3QgY29udGFpbnNRdW90ZSA9IHF1b3RlICE9PSBcIlwiICYmIHZhbHVlLmluZGV4T2YocXVvdGUpID49IDA7XG4gICAgICAgICAgY29uc3QgY29udGFpbnNFc2NhcGUgPSB2YWx1ZS5pbmRleE9mKGVzY2FwZSkgPj0gMCAmJiBlc2NhcGUgIT09IHF1b3RlO1xuICAgICAgICAgIGNvbnN0IGNvbnRhaW5zUmVjb3JkRGVsaW1pdGVyID0gdmFsdWUuaW5kZXhPZihyZWNvcmRfZGVsaW1pdGVyKSA+PSAwO1xuICAgICAgICAgIGNvbnN0IHF1b3RlZFN0cmluZyA9IHF1b3RlZF9zdHJpbmcgJiYgdHlwZW9mIGZpZWxkID09PSBcInN0cmluZ1wiO1xuICAgICAgICAgIGxldCBxdW90ZWRNYXRjaCA9XG4gICAgICAgICAgICBxdW90ZWRfbWF0Y2ggJiZcbiAgICAgICAgICAgIHF1b3RlZF9tYXRjaC5maWx0ZXIoKHF1b3RlZF9tYXRjaCkgPT4ge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIHF1b3RlZF9tYXRjaCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5pbmRleE9mKHF1b3RlZF9tYXRjaCkgIT09IC0xO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBxdW90ZWRfbWF0Y2gudGVzdCh2YWx1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIHF1b3RlZE1hdGNoID0gcXVvdGVkTWF0Y2ggJiYgcXVvdGVkTWF0Y2gubGVuZ3RoID4gMDtcbiAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2FkYWx0YXMvbm9kZS1jc3YvcHVsbC8zODdcbiAgICAgICAgICAvLyBNb3JlIGFib3V0IENTViBpbmplY3Rpb24gb3IgZm9ybXVsYSBpbmplY3Rpb24sIHdoZW4gd2Vic2l0ZXMgZW1iZWRcbiAgICAgICAgICAvLyB1bnRydXN0ZWQgaW5wdXQgaW5zaWRlIENTViBmaWxlczpcbiAgICAgICAgICAvLyBodHRwczovL293YXNwLm9yZy93d3ctY29tbXVuaXR5L2F0dGFja3MvQ1NWX0luamVjdGlvblxuICAgICAgICAgIC8vIGh0dHA6Ly9nZW9yZ2VtYXVlci5uZXQvMjAxNy8xMC8wNy9jc3YtaW5qZWN0aW9uLmh0bWxcbiAgICAgICAgICAvLyBBcHBsZSBOdW1iZXJzIHVuaWNvZGUgbm9ybWFsaXphdGlvbiBpcyBlbXBpcmljYWwgZnJvbSB0ZXN0aW5nXG4gICAgICAgICAgaWYgKGVzY2FwZV9mb3JtdWxhcykge1xuICAgICAgICAgICAgc3dpdGNoICh2YWx1ZVswXSkge1xuICAgICAgICAgICAgICBjYXNlIFwiPVwiOlxuICAgICAgICAgICAgICBjYXNlIFwiK1wiOlxuICAgICAgICAgICAgICBjYXNlIFwiLVwiOlxuICAgICAgICAgICAgICBjYXNlIFwiQFwiOlxuICAgICAgICAgICAgICBjYXNlIFwiXFx0XCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJcXHJcIjpcbiAgICAgICAgICAgICAgY2FzZSBcIlxcdUZGMURcIjogLy8gVW5pY29kZSAnPSdcbiAgICAgICAgICAgICAgY2FzZSBcIlxcdUZGMEJcIjogLy8gVW5pY29kZSAnKydcbiAgICAgICAgICAgICAgY2FzZSBcIlxcdUZGMERcIjogLy8gVW5pY29kZSAnLSdcbiAgICAgICAgICAgICAgY2FzZSBcIlxcdUZGMjBcIjogLy8gVW5pY29kZSAnQCdcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGAnJHt2YWx1ZX1gO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzaG91bGRRdW90ZSA9XG4gICAgICAgICAgICBjb250YWluc1F1b3RlID09PSB0cnVlIHx8XG4gICAgICAgICAgICBjb250YWluc2RlbGltaXRlciB8fFxuICAgICAgICAgICAgY29udGFpbnNSZWNvcmREZWxpbWl0ZXIgfHxcbiAgICAgICAgICAgIHF1b3RlZCB8fFxuICAgICAgICAgICAgcXVvdGVkU3RyaW5nIHx8XG4gICAgICAgICAgICBxdW90ZWRNYXRjaDtcbiAgICAgICAgICBpZiAoc2hvdWxkUXVvdGUgPT09IHRydWUgJiYgY29udGFpbnNFc2NhcGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlZ2V4cCA9XG4gICAgICAgICAgICAgIGVzY2FwZSA9PT0gXCJcXFxcXCJcbiAgICAgICAgICAgICAgICA/IG5ldyBSZWdFeHAoZXNjYXBlICsgZXNjYXBlLCBcImdcIilcbiAgICAgICAgICAgICAgICA6IG5ldyBSZWdFeHAoZXNjYXBlLCBcImdcIik7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocmVnZXhwLCBlc2NhcGUgKyBlc2NhcGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29udGFpbnNRdW90ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgcmVnZXhwID0gbmV3IFJlZ0V4cChxdW90ZSwgXCJnXCIpO1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlZ2V4cCwgZXNjYXBlICsgcXVvdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2hvdWxkUXVvdGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gcXVvdGUgKyB2YWx1ZSArIHF1b3RlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjc3ZyZWNvcmQgKz0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgcXVvdGVkX2VtcHR5ID09PSB0cnVlIHx8XG4gICAgICAgICAgKGZpZWxkID09PSBcIlwiICYmIHF1b3RlZF9zdHJpbmcgPT09IHRydWUgJiYgcXVvdGVkX2VtcHR5ICE9PSBmYWxzZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgY3N2cmVjb3JkICs9IHF1b3RlICsgcXVvdGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgIT09IHJlY29yZC5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgY3N2cmVjb3JkICs9IGRlbGltaXRlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFt1bmRlZmluZWQsIGNzdnJlY29yZF07XG4gICAgfSxcbiAgICBib206IGZ1bmN0aW9uIChwdXNoKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmJvbSAhPT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBwdXNoKGJvbV91dGY4KTtcbiAgICB9LFxuICAgIGhlYWRlcnM6IGZ1bmN0aW9uIChwdXNoKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmhlYWRlciA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb2x1bW5zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IGVycjtcbiAgICAgIGxldCBoZWFkZXJzID0gdGhpcy5vcHRpb25zLmNvbHVtbnMubWFwKChjb2x1bW4pID0+IGNvbHVtbi5oZWFkZXIpO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lb2YpIHtcbiAgICAgICAgW2VyciwgaGVhZGVyc10gPSB0aGlzLnN0cmluZ2lmeShoZWFkZXJzLCB0cnVlKTtcbiAgICAgICAgaGVhZGVycyArPSB0aGlzLm9wdGlvbnMucmVjb3JkX2RlbGltaXRlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFtlcnIsIGhlYWRlcnNdID0gdGhpcy5zdHJpbmdpZnkoaGVhZGVycyk7XG4gICAgICB9XG4gICAgICBpZiAoZXJyKSByZXR1cm4gZXJyO1xuICAgICAgcHVzaChoZWFkZXJzKTtcbiAgICB9LFxuICAgIF9fY2FzdDogZnVuY3Rpb24gKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAvLyBGaW5lIGZvciA5OSUgb2YgdGhlIGNhc2VzXG4gICAgICAgICAgcmV0dXJuIFt1bmRlZmluZWQsIHRoaXMub3B0aW9ucy5jYXN0LnN0cmluZyh2YWx1ZSwgY29udGV4dCldO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgICByZXR1cm4gW3VuZGVmaW5lZCwgdGhpcy5vcHRpb25zLmNhc3QuYmlnaW50KHZhbHVlLCBjb250ZXh0KV07XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIHJldHVybiBbdW5kZWZpbmVkLCB0aGlzLm9wdGlvbnMuY2FzdC5udW1iZXIodmFsdWUsIGNvbnRleHQpXTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgIHJldHVybiBbdW5kZWZpbmVkLCB0aGlzLm9wdGlvbnMuY2FzdC5ib29sZWFuKHZhbHVlLCBjb250ZXh0KV07XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIFt1bmRlZmluZWQsIHRoaXMub3B0aW9ucy5jYXN0LmRhdGUodmFsdWUsIGNvbnRleHQpXTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIFt1bmRlZmluZWQsIHRoaXMub3B0aW9ucy5jYXN0Lm9iamVjdCh2YWx1ZSwgY29udGV4dCldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBbdW5kZWZpbmVkLCB2YWx1ZSwgdmFsdWVdO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIFtlcnJdO1xuICAgICAgfVxuICAgIH0sXG4gIH07XG59O1xuXG4vKlxuQ1NWIFN0cmluZ2lmeVxuXG5QbGVhc2UgbG9vayBhdCB0aGUgW3Byb2plY3QgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9jc3YuanMub3JnL3N0cmluZ2lmeS8pIGZvclxuYWRkaXRpb25hbCBpbmZvcm1hdGlvbi5cbiovXG5cblxuY2xhc3MgU3RyaW5naWZpZXIgZXh0ZW5kcyBzdHJlYW0uVHJhbnNmb3JtIHtcbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgc3VwZXIoeyAuLi57IHdyaXRhYmxlT2JqZWN0TW9kZTogdHJ1ZSB9LCAuLi5vcHRzIH0pO1xuICAgIGNvbnN0IFtlcnIsIG9wdGlvbnNdID0gbm9ybWFsaXplX29wdGlvbnMob3B0cyk7XG4gICAgaWYgKGVyciAhPT0gdW5kZWZpbmVkKSB0aHJvdyBlcnI7XG4gICAgLy8gRXhwb3NlIG9wdGlvbnNcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIC8vIEludGVybmFsIHN0YXRlXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHN0b3A6IGZhbHNlLFxuICAgIH07XG4gICAgLy8gSW5mb3JtYXRpb25cbiAgICB0aGlzLmluZm8gPSB7XG4gICAgICByZWNvcmRzOiAwLFxuICAgIH07XG4gICAgdGhpcy5hcGkgPSBzdHJpbmdpZmllcih0aGlzLm9wdGlvbnMsIHRoaXMuc3RhdGUsIHRoaXMuaW5mbyk7XG4gICAgdGhpcy5hcGkub3B0aW9ucy5vbl9yZWNvcmQgPSAoLi4uYXJncykgPT4ge1xuICAgICAgdGhpcy5lbWl0KFwicmVjb3JkXCIsIC4uLmFyZ3MpO1xuICAgIH07XG4gIH1cbiAgX3RyYW5zZm9ybShjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuc3RvcCA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBlcnIgPSB0aGlzLmFwaS5fX3RyYW5zZm9ybShjaHVuaywgdGhpcy5wdXNoLmJpbmQodGhpcykpO1xuICAgIGlmIChlcnIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5zdGF0ZS5zdG9wID0gdHJ1ZTtcbiAgICB9XG4gICAgY2FsbGJhY2soZXJyKTtcbiAgfVxuICBfZmx1c2goY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5zdG9wID09PSB0cnVlKSB7XG4gICAgICAvLyBOb3RlLCBOb2RlLmpzIDEyIGNhbGwgZmx1c2ggZXZlbiBhZnRlciBhbiBlcnJvciwgd2UgbXVzdCBwcmV2ZW50XG4gICAgICAvLyBgY2FsbGJhY2tgIGZyb20gYmVpbmcgY2FsbGVkIGluIGZsdXNoIHdpdGhvdXQgYW55IGVycm9yLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5pbmZvLnJlY29yZHMgPT09IDApIHtcbiAgICAgIHRoaXMuYXBpLmJvbSh0aGlzLnB1c2guYmluZCh0aGlzKSk7XG4gICAgICBjb25zdCBlcnIgPSB0aGlzLmFwaS5oZWFkZXJzKHRoaXMucHVzaC5iaW5kKHRoaXMpKTtcbiAgICAgIGlmIChlcnIpIGNhbGxiYWNrKGVycik7XG4gICAgfVxuICAgIGNhbGxiYWNrKCk7XG4gIH1cbn1cblxuY29uc3Qgc3RyaW5naWZ5ID0gZnVuY3Rpb24gKCkge1xuICBsZXQgZGF0YSwgb3B0aW9ucywgY2FsbGJhY2s7XG4gIGZvciAoY29uc3QgaSBpbiBhcmd1bWVudHMpIHtcbiAgICBjb25zdCBhcmd1bWVudCA9IGFyZ3VtZW50c1tpXTtcbiAgICBjb25zdCB0eXBlID0gdHlwZW9mIGFyZ3VtZW50O1xuICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQgJiYgQXJyYXkuaXNBcnJheShhcmd1bWVudCkpIHtcbiAgICAgIGRhdGEgPSBhcmd1bWVudDtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCAmJiBpc19vYmplY3QoYXJndW1lbnQpKSB7XG4gICAgICBvcHRpb25zID0gYXJndW1lbnQ7XG4gICAgfSBlbHNlIGlmIChjYWxsYmFjayA9PT0gdW5kZWZpbmVkICYmIHR5cGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY2FsbGJhY2sgPSBhcmd1bWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IENzdkVycm9yKFwiQ1NWX0lOVkFMSURfQVJHVU1FTlRcIiwgW1xuICAgICAgICBcIkludmFsaWQgYXJndW1lbnQ6XCIsXG4gICAgICAgIGBnb3QgJHtKU09OLnN0cmluZ2lmeShhcmd1bWVudCl9IGF0IGluZGV4ICR7aX1gLFxuICAgICAgXSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHN0cmluZ2lmaWVyID0gbmV3IFN0cmluZ2lmaWVyKG9wdGlvbnMpO1xuICBpZiAoY2FsbGJhY2spIHtcbiAgICBjb25zdCBjaHVua3MgPSBbXTtcbiAgICBzdHJpbmdpZmllci5vbihcInJlYWRhYmxlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGxldCBjaHVuaztcbiAgICAgIHdoaWxlICgoY2h1bmsgPSB0aGlzLnJlYWQoKSkgIT09IG51bGwpIHtcbiAgICAgICAgY2h1bmtzLnB1c2goY2h1bmspO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHN0cmluZ2lmaWVyLm9uKFwiZXJyb3JcIiwgZnVuY3Rpb24gKGVycikge1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9KTtcbiAgICBzdHJpbmdpZmllci5vbihcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjYWxsYmFjayh1bmRlZmluZWQsIGNodW5rcy5qb2luKFwiXCIpKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgdGhlIGBjaHVua3NgIGlzIGV4dHJlbWVseSBsb25nOyBpdCBtYXkgdGhyb3dcbiAgICAgICAgLy8gXCJDYW5ub3QgY3JlYXRlIGEgc3RyaW5nIGxvbmdlciB0aGFuIDB4MWZmZmZmZTggY2hhcmFjdGVyc1wiXG4gICAgICAgIC8vIFNlZSBbIzM4Nl0oaHR0cHM6Ly9naXRodWIuY29tL2FkYWx0YXMvbm9kZS1jc3YvcHVsbC8zODYpXG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3Qgd3JpdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yIChjb25zdCByZWNvcmQgb2YgZGF0YSkge1xuICAgICAgICBzdHJpbmdpZmllci53cml0ZShyZWNvcmQpO1xuICAgICAgfVxuICAgICAgc3RyaW5naWZpZXIuZW5kKCk7XG4gICAgfTtcbiAgICAvLyBTdXBwb3J0IERlbm8sIFJvbGx1cCBkb2VzbnQgcHJvdmlkZSBhIHNoaW0gZm9yIHNldEltbWVkaWF0ZVxuICAgIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHNldEltbWVkaWF0ZSh3cml0ZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRUaW1lb3V0KHdyaXRlciwgMCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHJpbmdpZmllcjtcbn07XG5cbmV4cG9ydHMuQ3N2RXJyb3IgPSBDc3ZFcnJvcjtcbmV4cG9ydHMuU3RyaW5naWZpZXIgPSBTdHJpbmdpZmllcjtcbmV4cG9ydHMuc3RyaW5naWZ5ID0gc3RyaW5naWZ5O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/csv-stringify/dist/cjs/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/csv-stringify/dist/cjs/sync.cjs":
/*!******************************************************!*\
  !*** ./node_modules/csv-stringify/dist/cjs/sync.cjs ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\n// Lodash implementation of `get`\n\nconst charCodeOfDot = \".\".charCodeAt(0);\nconst reEscapeChar = /\\\\(\\\\)?/g;\nconst rePropName = RegExp(\n  // Match anything that isn't a dot or bracket.\n  \"[^.[\\\\]]+\" +\n    \"|\" +\n    // Or match property names within brackets.\n    \"\\\\[(?:\" +\n    // Match a non-string expression.\n    \"([^\\\"'][^[]*)\" +\n    \"|\" +\n    // Or match strings (supports escaping characters).\n    \"([\\\"'])((?:(?!\\\\2)[^\\\\\\\\]|\\\\\\\\.)*?)\\\\2\" +\n    \")\\\\]\" +\n    \"|\" +\n    // Or match \"\" as the space between consecutive dots or empty brackets.\n    \"(?=(?:\\\\.|\\\\[\\\\])(?:\\\\.|\\\\[\\\\]|$))\",\n  \"g\",\n);\nconst reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\nconst reIsPlainProp = /^\\w*$/;\n\nconst getTag = function (value) {\n  // if (!value) value === undefined ? \"[object Undefined]\" : \"[object Null]\";\n  return Object.prototype.toString.call(value);\n};\n\nconst isSymbol = function (value) {\n  const type = typeof value;\n  return (\n    type === \"symbol\" ||\n    (type === \"object\" && value && getTag(value) === \"[object Symbol]\")\n  );\n};\n\nconst isKey = function (value, object) {\n  if (Array.isArray(value)) {\n    return false;\n  }\n  const type = typeof value;\n  if (\n    type === \"number\" ||\n    type === \"symbol\" ||\n    type === \"boolean\" ||\n    !value ||\n    isSymbol(value)\n  ) {\n    return true;\n  }\n  return (\n    reIsPlainProp.test(value) ||\n    !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object))\n  );\n};\n\nconst stringToPath = function (string) {\n  const result = [];\n  if (string.charCodeAt(0) === charCodeOfDot) {\n    result.push(\"\");\n  }\n  string.replace(rePropName, function (match, expression, quote, subString) {\n    let key = match;\n    if (quote) {\n      key = subString.replace(reEscapeChar, \"$1\");\n    } else if (expression) {\n      key = expression.trim();\n    }\n    result.push(key);\n  });\n  return result;\n};\n\nconst castPath = function (value, object) {\n  if (Array.isArray(value)) {\n    return value;\n  } else {\n    return isKey(value, object) ? [value] : stringToPath(value);\n  }\n};\n\nconst toKey = function (value) {\n  if (typeof value === \"string\" || isSymbol(value)) return value;\n  const result = `${value}`;\n  // eslint-disable-next-line\n  return result == \"0\" && 1 / value == -INFINITY ? \"-0\" : result;\n};\n\nconst get = function (object, path) {\n  path = castPath(path, object);\n  let index = 0;\n  const length = path.length;\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return index && index === length ? object : undefined;\n};\n\nconst is_object = function (obj) {\n  return typeof obj === \"object\" && obj !== null && !Array.isArray(obj);\n};\n\nconst normalize_columns = function (columns) {\n  if (columns === undefined || columns === null) {\n    return [undefined, undefined];\n  }\n  if (typeof columns !== \"object\") {\n    return [Error('Invalid option \"columns\": expect an array or an object')];\n  }\n  if (!Array.isArray(columns)) {\n    const newcolumns = [];\n    for (const k in columns) {\n      newcolumns.push({\n        key: k,\n        header: columns[k],\n      });\n    }\n    columns = newcolumns;\n  } else {\n    const newcolumns = [];\n    for (const column of columns) {\n      if (typeof column === \"string\") {\n        newcolumns.push({\n          key: column,\n          header: column,\n        });\n      } else if (\n        typeof column === \"object\" &&\n        column !== null &&\n        !Array.isArray(column)\n      ) {\n        if (!column.key) {\n          return [\n            Error('Invalid column definition: property \"key\" is required'),\n          ];\n        }\n        if (column.header === undefined) {\n          column.header = column.key;\n        }\n        newcolumns.push(column);\n      } else {\n        return [\n          Error(\"Invalid column definition: expect a string or an object\"),\n        ];\n      }\n    }\n    columns = newcolumns;\n  }\n  return [undefined, columns];\n};\n\nclass CsvError extends Error {\n  constructor(code, message, ...contexts) {\n    if (Array.isArray(message)) message = message.join(\" \");\n    super(message);\n    if (Error.captureStackTrace !== undefined) {\n      Error.captureStackTrace(this, CsvError);\n    }\n    this.code = code;\n    for (const context of contexts) {\n      for (const key in context) {\n        const value = context[key];\n        this[key] = Buffer.isBuffer(value)\n          ? value.toString()\n          : value == null\n            ? value\n            : JSON.parse(JSON.stringify(value));\n      }\n    }\n  }\n}\n\nconst underscore = function (str) {\n  return str.replace(/([A-Z])/g, function (_, match) {\n    return \"_\" + match.toLowerCase();\n  });\n};\n\nconst normalize_options = function (opts) {\n  const options = {};\n  // Merge with user options\n  for (const opt in opts) {\n    options[underscore(opt)] = opts[opt];\n  }\n  // Normalize option `bom`\n  if (\n    options.bom === undefined ||\n    options.bom === null ||\n    options.bom === false\n  ) {\n    options.bom = false;\n  } else if (options.bom !== true) {\n    return [\n      new CsvError(\"CSV_OPTION_BOOLEAN_INVALID_TYPE\", [\n        \"option `bom` is optional and must be a boolean value,\",\n        `got ${JSON.stringify(options.bom)}`,\n      ]),\n    ];\n  }\n  // Normalize option `delimiter`\n  if (options.delimiter === undefined || options.delimiter === null) {\n    options.delimiter = \",\";\n  } else if (Buffer.isBuffer(options.delimiter)) {\n    options.delimiter = options.delimiter.toString();\n  } else if (typeof options.delimiter !== \"string\") {\n    return [\n      new CsvError(\"CSV_OPTION_DELIMITER_INVALID_TYPE\", [\n        \"option `delimiter` must be a buffer or a string,\",\n        `got ${JSON.stringify(options.delimiter)}`,\n      ]),\n    ];\n  }\n  // Normalize option `quote`\n  if (options.quote === undefined || options.quote === null) {\n    options.quote = '\"';\n  } else if (options.quote === true) {\n    options.quote = '\"';\n  } else if (options.quote === false) {\n    options.quote = \"\";\n  } else if (Buffer.isBuffer(options.quote)) {\n    options.quote = options.quote.toString();\n  } else if (typeof options.quote !== \"string\") {\n    return [\n      new CsvError(\"CSV_OPTION_QUOTE_INVALID_TYPE\", [\n        \"option `quote` must be a boolean, a buffer or a string,\",\n        `got ${JSON.stringify(options.quote)}`,\n      ]),\n    ];\n  }\n  // Normalize option `quoted`\n  if (options.quoted === undefined || options.quoted === null) {\n    options.quoted = false;\n  }\n  // Normalize option `escape_formulas`\n  if (\n    options.escape_formulas === undefined ||\n    options.escape_formulas === null\n  ) {\n    options.escape_formulas = false;\n  } else if (typeof options.escape_formulas !== \"boolean\") {\n    return [\n      new CsvError(\"CSV_OPTION_ESCAPE_FORMULAS_INVALID_TYPE\", [\n        \"option `escape_formulas` must be a boolean,\",\n        `got ${JSON.stringify(options.escape_formulas)}`,\n      ]),\n    ];\n  }\n  // Normalize option `quoted_empty`\n  if (options.quoted_empty === undefined || options.quoted_empty === null) {\n    options.quoted_empty = undefined;\n  }\n  // Normalize option `quoted_match`\n  if (\n    options.quoted_match === undefined ||\n    options.quoted_match === null ||\n    options.quoted_match === false\n  ) {\n    options.quoted_match = null;\n  } else if (!Array.isArray(options.quoted_match)) {\n    options.quoted_match = [options.quoted_match];\n  }\n  if (options.quoted_match) {\n    for (const quoted_match of options.quoted_match) {\n      const isString = typeof quoted_match === \"string\";\n      const isRegExp = quoted_match instanceof RegExp;\n      if (!isString && !isRegExp) {\n        return [\n          Error(\n            `Invalid Option: quoted_match must be a string or a regex, got ${JSON.stringify(quoted_match)}`,\n          ),\n        ];\n      }\n    }\n  }\n  // Normalize option `quoted_string`\n  if (options.quoted_string === undefined || options.quoted_string === null) {\n    options.quoted_string = false;\n  }\n  // Normalize option `eof`\n  if (options.eof === undefined || options.eof === null) {\n    options.eof = true;\n  }\n  // Normalize option `escape`\n  if (options.escape === undefined || options.escape === null) {\n    options.escape = '\"';\n  } else if (Buffer.isBuffer(options.escape)) {\n    options.escape = options.escape.toString();\n  } else if (typeof options.escape !== \"string\") {\n    return [\n      Error(\n        `Invalid Option: escape must be a buffer or a string, got ${JSON.stringify(options.escape)}`,\n      ),\n    ];\n  }\n  if (options.escape.length > 1) {\n    return [\n      Error(\n        `Invalid Option: escape must be one character, got ${options.escape.length} characters`,\n      ),\n    ];\n  }\n  // Normalize option `header`\n  if (options.header === undefined || options.header === null) {\n    options.header = false;\n  }\n  // Normalize option `columns`\n  const [errColumns, columns] = normalize_columns(options.columns);\n  if (errColumns !== undefined) return [errColumns];\n  options.columns = columns;\n  // Normalize option `quoted`\n  if (options.quoted === undefined || options.quoted === null) {\n    options.quoted = false;\n  }\n  // Normalize option `cast`\n  if (options.cast === undefined || options.cast === null) {\n    options.cast = {};\n  }\n  // Normalize option cast.bigint\n  if (options.cast.bigint === undefined || options.cast.bigint === null) {\n    // Cast boolean to string by default\n    options.cast.bigint = (value) => \"\" + value;\n  }\n  // Normalize option cast.boolean\n  if (options.cast.boolean === undefined || options.cast.boolean === null) {\n    // Cast boolean to string by default\n    options.cast.boolean = (value) => (value ? \"1\" : \"\");\n  }\n  // Normalize option cast.date\n  if (options.cast.date === undefined || options.cast.date === null) {\n    // Cast date to timestamp string by default\n    options.cast.date = (value) => \"\" + value.getTime();\n  }\n  // Normalize option cast.number\n  if (options.cast.number === undefined || options.cast.number === null) {\n    // Cast number to string using native casting by default\n    options.cast.number = (value) => \"\" + value;\n  }\n  // Normalize option cast.object\n  if (options.cast.object === undefined || options.cast.object === null) {\n    // Stringify object as JSON by default\n    options.cast.object = (value) => JSON.stringify(value);\n  }\n  // Normalize option cast.string\n  if (options.cast.string === undefined || options.cast.string === null) {\n    // Leave string untouched\n    options.cast.string = function (value) {\n      return value;\n    };\n  }\n  // Normalize option `on_record`\n  if (\n    options.on_record !== undefined &&\n    typeof options.on_record !== \"function\"\n  ) {\n    return [Error(`Invalid Option: \"on_record\" must be a function.`)];\n  }\n  // Normalize option `record_delimiter`\n  if (\n    options.record_delimiter === undefined ||\n    options.record_delimiter === null\n  ) {\n    options.record_delimiter = \"\\n\";\n  } else if (Buffer.isBuffer(options.record_delimiter)) {\n    options.record_delimiter = options.record_delimiter.toString();\n  } else if (typeof options.record_delimiter !== \"string\") {\n    return [\n      Error(\n        `Invalid Option: record_delimiter must be a buffer or a string, got ${JSON.stringify(options.record_delimiter)}`,\n      ),\n    ];\n  }\n  switch (options.record_delimiter) {\n    case \"unix\":\n      options.record_delimiter = \"\\n\";\n      break;\n    case \"mac\":\n      options.record_delimiter = \"\\r\";\n      break;\n    case \"windows\":\n      options.record_delimiter = \"\\r\\n\";\n      break;\n    case \"ascii\":\n      options.record_delimiter = \"\\u001e\";\n      break;\n    case \"unicode\":\n      options.record_delimiter = \"\\u2028\";\n      break;\n  }\n  return [undefined, options];\n};\n\nconst bom_utf8 = Buffer.from([239, 187, 191]);\n\nconst stringifier = function (options, state, info) {\n  return {\n    options: options,\n    state: state,\n    info: info,\n    __transform: function (chunk, push) {\n      // Chunk validation\n      if (!Array.isArray(chunk) && typeof chunk !== \"object\") {\n        return Error(\n          `Invalid Record: expect an array or an object, got ${JSON.stringify(chunk)}`,\n        );\n      }\n      // Detect columns from the first record\n      if (this.info.records === 0) {\n        if (Array.isArray(chunk)) {\n          if (\n            this.options.header === true &&\n            this.options.columns === undefined\n          ) {\n            return Error(\n              \"Undiscoverable Columns: header option requires column option or object records\",\n            );\n          }\n        } else if (this.options.columns === undefined) {\n          const [err, columns] = normalize_columns(Object.keys(chunk));\n          if (err) return;\n          this.options.columns = columns;\n        }\n      }\n      // Emit the header\n      if (this.info.records === 0) {\n        this.bom(push);\n        const err = this.headers(push);\n        if (err) return err;\n      }\n      // Emit and stringify the record if an object or an array\n      try {\n        // this.emit('record', chunk, this.info.records);\n        if (this.options.on_record) {\n          this.options.on_record(chunk, this.info.records);\n        }\n      } catch (err) {\n        return err;\n      }\n      // Convert the record into a string\n      let err, chunk_string;\n      if (this.options.eof) {\n        [err, chunk_string] = this.stringify(chunk);\n        if (err) return err;\n        if (chunk_string === undefined) {\n          return;\n        } else {\n          chunk_string = chunk_string + this.options.record_delimiter;\n        }\n      } else {\n        [err, chunk_string] = this.stringify(chunk);\n        if (err) return err;\n        if (chunk_string === undefined) {\n          return;\n        } else {\n          if (this.options.header || this.info.records) {\n            chunk_string = this.options.record_delimiter + chunk_string;\n          }\n        }\n      }\n      // Emit the csv\n      this.info.records++;\n      push(chunk_string);\n    },\n    stringify: function (chunk, chunkIsHeader = false) {\n      if (typeof chunk !== \"object\") {\n        return [undefined, chunk];\n      }\n      const { columns } = this.options;\n      const record = [];\n      // Record is an array\n      if (Array.isArray(chunk)) {\n        // We are getting an array but the user has specified output columns. In\n        // this case, we respect the columns indexes\n        if (columns) {\n          chunk.splice(columns.length);\n        }\n        // Cast record elements\n        for (let i = 0; i < chunk.length; i++) {\n          const field = chunk[i];\n          const [err, value] = this.__cast(field, {\n            index: i,\n            column: i,\n            records: this.info.records,\n            header: chunkIsHeader,\n          });\n          if (err) return [err];\n          record[i] = [value, field];\n        }\n        // Record is a literal object\n        // `columns` is always defined: it is either provided or discovered.\n      } else {\n        for (let i = 0; i < columns.length; i++) {\n          const field = get(chunk, columns[i].key);\n          const [err, value] = this.__cast(field, {\n            index: i,\n            column: columns[i].key,\n            records: this.info.records,\n            header: chunkIsHeader,\n          });\n          if (err) return [err];\n          record[i] = [value, field];\n        }\n      }\n      let csvrecord = \"\";\n      for (let i = 0; i < record.length; i++) {\n        let options, err;\n\n        let [value, field] = record[i];\n        if (typeof value === \"string\") {\n          options = this.options;\n        } else if (is_object(value)) {\n          options = value;\n          value = options.value;\n          delete options.value;\n          if (\n            typeof value !== \"string\" &&\n            value !== undefined &&\n            value !== null\n          ) {\n            if (err)\n              return [\n                Error(\n                  `Invalid Casting Value: returned value must return a string, null or undefined, got ${JSON.stringify(value)}`,\n                ),\n              ];\n          }\n          options = { ...this.options, ...options };\n          [err, options] = normalize_options(options);\n          if (err !== undefined) {\n            return [err];\n          }\n        } else if (value === undefined || value === null) {\n          options = this.options;\n        } else {\n          return [\n            Error(\n              `Invalid Casting Value: returned value must return a string, an object, null or undefined, got ${JSON.stringify(value)}`,\n            ),\n          ];\n        }\n        const {\n          delimiter,\n          escape,\n          quote,\n          quoted,\n          quoted_empty,\n          quoted_string,\n          quoted_match,\n          record_delimiter,\n          escape_formulas,\n        } = options;\n        if (\"\" === value && \"\" === field) {\n          let quotedMatch =\n            quoted_match &&\n            quoted_match.filter((quoted_match) => {\n              if (typeof quoted_match === \"string\") {\n                return value.indexOf(quoted_match) !== -1;\n              } else {\n                return quoted_match.test(value);\n              }\n            });\n          quotedMatch = quotedMatch && quotedMatch.length > 0;\n          const shouldQuote =\n            quotedMatch ||\n            true === quoted_empty ||\n            (true === quoted_string && false !== quoted_empty);\n          if (shouldQuote === true) {\n            value = quote + value + quote;\n          }\n          csvrecord += value;\n        } else if (value) {\n          if (typeof value !== \"string\") {\n            return [\n              Error(\n                `Formatter must return a string, null or undefined, got ${JSON.stringify(value)}`,\n              ),\n            ];\n          }\n          const containsdelimiter =\n            delimiter.length && value.indexOf(delimiter) >= 0;\n          const containsQuote = quote !== \"\" && value.indexOf(quote) >= 0;\n          const containsEscape = value.indexOf(escape) >= 0 && escape !== quote;\n          const containsRecordDelimiter = value.indexOf(record_delimiter) >= 0;\n          const quotedString = quoted_string && typeof field === \"string\";\n          let quotedMatch =\n            quoted_match &&\n            quoted_match.filter((quoted_match) => {\n              if (typeof quoted_match === \"string\") {\n                return value.indexOf(quoted_match) !== -1;\n              } else {\n                return quoted_match.test(value);\n              }\n            });\n          quotedMatch = quotedMatch && quotedMatch.length > 0;\n          // See https://github.com/adaltas/node-csv/pull/387\n          // More about CSV injection or formula injection, when websites embed\n          // untrusted input inside CSV files:\n          // https://owasp.org/www-community/attacks/CSV_Injection\n          // http://georgemauer.net/2017/10/07/csv-injection.html\n          // Apple Numbers unicode normalization is empirical from testing\n          if (escape_formulas) {\n            switch (value[0]) {\n              case \"=\":\n              case \"+\":\n              case \"-\":\n              case \"@\":\n              case \"\\t\":\n              case \"\\r\":\n              case \"\\uFF1D\": // Unicode '='\n              case \"\\uFF0B\": // Unicode '+'\n              case \"\\uFF0D\": // Unicode '-'\n              case \"\\uFF20\": // Unicode '@'\n                value = `'${value}`;\n                break;\n            }\n          }\n          const shouldQuote =\n            containsQuote === true ||\n            containsdelimiter ||\n            containsRecordDelimiter ||\n            quoted ||\n            quotedString ||\n            quotedMatch;\n          if (shouldQuote === true && containsEscape === true) {\n            const regexp =\n              escape === \"\\\\\"\n                ? new RegExp(escape + escape, \"g\")\n                : new RegExp(escape, \"g\");\n            value = value.replace(regexp, escape + escape);\n          }\n          if (containsQuote === true) {\n            const regexp = new RegExp(quote, \"g\");\n            value = value.replace(regexp, escape + quote);\n          }\n          if (shouldQuote === true) {\n            value = quote + value + quote;\n          }\n          csvrecord += value;\n        } else if (\n          quoted_empty === true ||\n          (field === \"\" && quoted_string === true && quoted_empty !== false)\n        ) {\n          csvrecord += quote + quote;\n        }\n        if (i !== record.length - 1) {\n          csvrecord += delimiter;\n        }\n      }\n      return [undefined, csvrecord];\n    },\n    bom: function (push) {\n      if (this.options.bom !== true) {\n        return;\n      }\n      push(bom_utf8);\n    },\n    headers: function (push) {\n      if (this.options.header === false) {\n        return;\n      }\n      if (this.options.columns === undefined) {\n        return;\n      }\n      let err;\n      let headers = this.options.columns.map((column) => column.header);\n      if (this.options.eof) {\n        [err, headers] = this.stringify(headers, true);\n        headers += this.options.record_delimiter;\n      } else {\n        [err, headers] = this.stringify(headers);\n      }\n      if (err) return err;\n      push(headers);\n    },\n    __cast: function (value, context) {\n      const type = typeof value;\n      try {\n        if (type === \"string\") {\n          // Fine for 99% of the cases\n          return [undefined, this.options.cast.string(value, context)];\n        } else if (type === \"bigint\") {\n          return [undefined, this.options.cast.bigint(value, context)];\n        } else if (type === \"number\") {\n          return [undefined, this.options.cast.number(value, context)];\n        } else if (type === \"boolean\") {\n          return [undefined, this.options.cast.boolean(value, context)];\n        } else if (value instanceof Date) {\n          return [undefined, this.options.cast.date(value, context)];\n        } else if (type === \"object\" && value !== null) {\n          return [undefined, this.options.cast.object(value, context)];\n        } else {\n          return [undefined, value, value];\n        }\n      } catch (err) {\n        return [err];\n      }\n    },\n  };\n};\n\nconst stringify = function (records, opts = {}) {\n  const data = [];\n  const [err, options] = normalize_options(opts);\n  if (err !== undefined) throw err;\n  const state = {\n    stop: false,\n  };\n  // Information\n  const info = {\n    records: 0,\n  };\n  const api = stringifier(options, state, info);\n  for (const record of records) {\n    const err = api.__transform(record, function (record) {\n      data.push(record);\n    });\n    if (err !== undefined) throw err;\n  }\n  if (data.length === 0) {\n    api.bom((d) => {\n      data.push(d);\n    });\n    const err = api.headers((headers) => {\n      data.push(headers);\n    });\n    if (err !== undefined) throw err;\n  }\n  return data.join(\"\");\n};\n\nexports.stringify = stringify;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY3N2LXN0cmluZ2lmeS9kaXN0L2Nqcy9zeW5jLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxlQUFlLDRCQUE0QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQ0FBa0M7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOEJBQThCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0NBQXdDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLDZCQUE2QjtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0Esb0VBQW9FLCtCQUErQjtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsdUJBQXVCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSw4RUFBOEUseUNBQXlDO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxzQkFBc0I7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBbUI7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3R0FBd0csc0JBQXNCO0FBQzlIO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsK0dBQStHLHNCQUFzQjtBQUNySTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLHNCQUFzQjtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsTUFBTTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQiIsInNvdXJjZXMiOlsiL1VzZXJzL25lem9iZW5hcmRpL0FJX3N0dWZmL09uYm9hcmRpbmdQb3J0YWwvbm9kZV9tb2R1bGVzL2Nzdi1zdHJpbmdpZnkvZGlzdC9janMvc3luYy5janMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vLyBMb2Rhc2ggaW1wbGVtZW50YXRpb24gb2YgYGdldGBcblxuY29uc3QgY2hhckNvZGVPZkRvdCA9IFwiLlwiLmNoYXJDb2RlQXQoMCk7XG5jb25zdCByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcbmNvbnN0IHJlUHJvcE5hbWUgPSBSZWdFeHAoXG4gIC8vIE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBkb3Qgb3IgYnJhY2tldC5cbiAgXCJbXi5bXFxcXF1dK1wiICtcbiAgICBcInxcIiArXG4gICAgLy8gT3IgbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIGJyYWNrZXRzLlxuICAgIFwiXFxcXFsoPzpcIiArXG4gICAgLy8gTWF0Y2ggYSBub24tc3RyaW5nIGV4cHJlc3Npb24uXG4gICAgXCIoW15cXFwiJ11bXltdKilcIiArXG4gICAgXCJ8XCIgK1xuICAgIC8vIE9yIG1hdGNoIHN0cmluZ3MgKHN1cHBvcnRzIGVzY2FwaW5nIGNoYXJhY3RlcnMpLlxuICAgIFwiKFtcXFwiJ10pKCg/Oig/IVxcXFwyKVteXFxcXFxcXFxdfFxcXFxcXFxcLikqPylcXFxcMlwiICtcbiAgICBcIilcXFxcXVwiICtcbiAgICBcInxcIiArXG4gICAgLy8gT3IgbWF0Y2ggXCJcIiBhcyB0aGUgc3BhY2UgYmV0d2VlbiBjb25zZWN1dGl2ZSBkb3RzIG9yIGVtcHR5IGJyYWNrZXRzLlxuICAgIFwiKD89KD86XFxcXC58XFxcXFtcXFxcXSkoPzpcXFxcLnxcXFxcW1xcXFxdfCQpKVwiLFxuICBcImdcIixcbik7XG5jb25zdCByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vO1xuY29uc3QgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvO1xuXG5jb25zdCBnZXRUYWcgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgLy8gaWYgKCF2YWx1ZSkgdmFsdWUgPT09IHVuZGVmaW5lZCA/IFwiW29iamVjdCBVbmRlZmluZWRdXCIgOiBcIltvYmplY3QgTnVsbF1cIjtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59O1xuXG5jb25zdCBpc1N5bWJvbCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKFxuICAgIHR5cGUgPT09IFwic3ltYm9sXCIgfHxcbiAgICAodHlwZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAmJiBnZXRUYWcodmFsdWUpID09PSBcIltvYmplY3QgU3ltYm9sXVwiKVxuICApO1xufTtcblxuY29uc3QgaXNLZXkgPSBmdW5jdGlvbiAodmFsdWUsIG9iamVjdCkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKFxuICAgIHR5cGUgPT09IFwibnVtYmVyXCIgfHxcbiAgICB0eXBlID09PSBcInN5bWJvbFwiIHx8XG4gICAgdHlwZSA9PT0gXCJib29sZWFuXCIgfHxcbiAgICAhdmFsdWUgfHxcbiAgICBpc1N5bWJvbCh2YWx1ZSlcbiAgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIChcbiAgICByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxuICAgIChvYmplY3QgIT0gbnVsbCAmJiB2YWx1ZSBpbiBPYmplY3Qob2JqZWN0KSlcbiAgKTtcbn07XG5cbmNvbnN0IHN0cmluZ1RvUGF0aCA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGlmIChzdHJpbmcuY2hhckNvZGVBdCgwKSA9PT0gY2hhckNvZGVPZkRvdCkge1xuICAgIHJlc3VsdC5wdXNoKFwiXCIpO1xuICB9XG4gIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uIChtYXRjaCwgZXhwcmVzc2lvbiwgcXVvdGUsIHN1YlN0cmluZykge1xuICAgIGxldCBrZXkgPSBtYXRjaDtcbiAgICBpZiAocXVvdGUpIHtcbiAgICAgIGtleSA9IHN1YlN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgXCIkMVwiKTtcbiAgICB9IGVsc2UgaWYgKGV4cHJlc3Npb24pIHtcbiAgICAgIGtleSA9IGV4cHJlc3Npb24udHJpbSgpO1xuICAgIH1cbiAgICByZXN1bHQucHVzaChrZXkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmNvbnN0IGNhc3RQYXRoID0gZnVuY3Rpb24gKHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBpc0tleSh2YWx1ZSwgb2JqZWN0KSA/IFt2YWx1ZV0gOiBzdHJpbmdUb1BhdGgodmFsdWUpO1xuICB9XG59O1xuXG5jb25zdCB0b0tleSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IGlzU3ltYm9sKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICBjb25zdCByZXN1bHQgPSBgJHt2YWx1ZX1gO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgcmV0dXJuIHJlc3VsdCA9PSBcIjBcIiAmJiAxIC8gdmFsdWUgPT0gLUlORklOSVRZID8gXCItMFwiIDogcmVzdWx0O1xufTtcblxuY29uc3QgZ2V0ID0gZnVuY3Rpb24gKG9iamVjdCwgcGF0aCkge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgbGV0IGluZGV4ID0gMDtcbiAgY29uc3QgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG4gIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG4gIH1cbiAgcmV0dXJuIGluZGV4ICYmIGluZGV4ID09PSBsZW5ndGggPyBvYmplY3QgOiB1bmRlZmluZWQ7XG59O1xuXG5jb25zdCBpc19vYmplY3QgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiICYmIG9iaiAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShvYmopO1xufTtcblxuY29uc3Qgbm9ybWFsaXplX2NvbHVtbnMgPSBmdW5jdGlvbiAoY29sdW1ucykge1xuICBpZiAoY29sdW1ucyA9PT0gdW5kZWZpbmVkIHx8IGNvbHVtbnMgPT09IG51bGwpIHtcbiAgICByZXR1cm4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkXTtcbiAgfVxuICBpZiAodHlwZW9mIGNvbHVtbnMgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gW0Vycm9yKCdJbnZhbGlkIG9wdGlvbiBcImNvbHVtbnNcIjogZXhwZWN0IGFuIGFycmF5IG9yIGFuIG9iamVjdCcpXTtcbiAgfVxuICBpZiAoIUFycmF5LmlzQXJyYXkoY29sdW1ucykpIHtcbiAgICBjb25zdCBuZXdjb2x1bW5zID0gW107XG4gICAgZm9yIChjb25zdCBrIGluIGNvbHVtbnMpIHtcbiAgICAgIG5ld2NvbHVtbnMucHVzaCh7XG4gICAgICAgIGtleTogayxcbiAgICAgICAgaGVhZGVyOiBjb2x1bW5zW2tdLFxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbHVtbnMgPSBuZXdjb2x1bW5zO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG5ld2NvbHVtbnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGNvbHVtbiBvZiBjb2x1bW5zKSB7XG4gICAgICBpZiAodHlwZW9mIGNvbHVtbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBuZXdjb2x1bW5zLnB1c2goe1xuICAgICAgICAgIGtleTogY29sdW1uLFxuICAgICAgICAgIGhlYWRlcjogY29sdW1uLFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIHR5cGVvZiBjb2x1bW4gPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgY29sdW1uICE9PSBudWxsICYmXG4gICAgICAgICFBcnJheS5pc0FycmF5KGNvbHVtbilcbiAgICAgICkge1xuICAgICAgICBpZiAoIWNvbHVtbi5rZXkpIHtcbiAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgRXJyb3IoJ0ludmFsaWQgY29sdW1uIGRlZmluaXRpb246IHByb3BlcnR5IFwia2V5XCIgaXMgcmVxdWlyZWQnKSxcbiAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2x1bW4uaGVhZGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb2x1bW4uaGVhZGVyID0gY29sdW1uLmtleTtcbiAgICAgICAgfVxuICAgICAgICBuZXdjb2x1bW5zLnB1c2goY29sdW1uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgRXJyb3IoXCJJbnZhbGlkIGNvbHVtbiBkZWZpbml0aW9uOiBleHBlY3QgYSBzdHJpbmcgb3IgYW4gb2JqZWN0XCIpLFxuICAgICAgICBdO1xuICAgICAgfVxuICAgIH1cbiAgICBjb2x1bW5zID0gbmV3Y29sdW1ucztcbiAgfVxuICByZXR1cm4gW3VuZGVmaW5lZCwgY29sdW1uc107XG59O1xuXG5jbGFzcyBDc3ZFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoY29kZSwgbWVzc2FnZSwgLi4uY29udGV4dHMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShtZXNzYWdlKSkgbWVzc2FnZSA9IG1lc3NhZ2Uuam9pbihcIiBcIik7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIENzdkVycm9yKTtcbiAgICB9XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICBmb3IgKGNvbnN0IGNvbnRleHQgb2YgY29udGV4dHMpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBjb250ZXh0W2tleV07XG4gICAgICAgIHRoaXNba2V5XSA9IEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSlcbiAgICAgICAgICA/IHZhbHVlLnRvU3RyaW5nKClcbiAgICAgICAgICA6IHZhbHVlID09IG51bGxcbiAgICAgICAgICAgID8gdmFsdWVcbiAgICAgICAgICAgIDogSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCB1bmRlcnNjb3JlID0gZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbQS1aXSkvZywgZnVuY3Rpb24gKF8sIG1hdGNoKSB7XG4gICAgcmV0dXJuIFwiX1wiICsgbWF0Y2gudG9Mb3dlckNhc2UoKTtcbiAgfSk7XG59O1xuXG5jb25zdCBub3JtYWxpemVfb3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSB7fTtcbiAgLy8gTWVyZ2Ugd2l0aCB1c2VyIG9wdGlvbnNcbiAgZm9yIChjb25zdCBvcHQgaW4gb3B0cykge1xuICAgIG9wdGlvbnNbdW5kZXJzY29yZShvcHQpXSA9IG9wdHNbb3B0XTtcbiAgfVxuICAvLyBOb3JtYWxpemUgb3B0aW9uIGBib21gXG4gIGlmIChcbiAgICBvcHRpb25zLmJvbSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgb3B0aW9ucy5ib20gPT09IG51bGwgfHxcbiAgICBvcHRpb25zLmJvbSA9PT0gZmFsc2VcbiAgKSB7XG4gICAgb3B0aW9ucy5ib20gPSBmYWxzZTtcbiAgfSBlbHNlIGlmIChvcHRpb25zLmJvbSAhPT0gdHJ1ZSkge1xuICAgIHJldHVybiBbXG4gICAgICBuZXcgQ3N2RXJyb3IoXCJDU1ZfT1BUSU9OX0JPT0xFQU5fSU5WQUxJRF9UWVBFXCIsIFtcbiAgICAgICAgXCJvcHRpb24gYGJvbWAgaXMgb3B0aW9uYWwgYW5kIG11c3QgYmUgYSBib29sZWFuIHZhbHVlLFwiLFxuICAgICAgICBgZ290ICR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucy5ib20pfWAsXG4gICAgICBdKSxcbiAgICBdO1xuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gYGRlbGltaXRlcmBcbiAgaWYgKG9wdGlvbnMuZGVsaW1pdGVyID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5kZWxpbWl0ZXIgPT09IG51bGwpIHtcbiAgICBvcHRpb25zLmRlbGltaXRlciA9IFwiLFwiO1xuICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvcHRpb25zLmRlbGltaXRlcikpIHtcbiAgICBvcHRpb25zLmRlbGltaXRlciA9IG9wdGlvbnMuZGVsaW1pdGVyLnRvU3RyaW5nKCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuZGVsaW1pdGVyICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBDc3ZFcnJvcihcIkNTVl9PUFRJT05fREVMSU1JVEVSX0lOVkFMSURfVFlQRVwiLCBbXG4gICAgICAgIFwib3B0aW9uIGBkZWxpbWl0ZXJgIG11c3QgYmUgYSBidWZmZXIgb3IgYSBzdHJpbmcsXCIsXG4gICAgICAgIGBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLmRlbGltaXRlcil9YCxcbiAgICAgIF0pLFxuICAgIF07XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgcXVvdGVgXG4gIGlmIChvcHRpb25zLnF1b3RlID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5xdW90ZSA9PT0gbnVsbCkge1xuICAgIG9wdGlvbnMucXVvdGUgPSAnXCInO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMucXVvdGUgPT09IHRydWUpIHtcbiAgICBvcHRpb25zLnF1b3RlID0gJ1wiJztcbiAgfSBlbHNlIGlmIChvcHRpb25zLnF1b3RlID09PSBmYWxzZSkge1xuICAgIG9wdGlvbnMucXVvdGUgPSBcIlwiO1xuICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvcHRpb25zLnF1b3RlKSkge1xuICAgIG9wdGlvbnMucXVvdGUgPSBvcHRpb25zLnF1b3RlLnRvU3RyaW5nKCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMucXVvdGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbmV3IENzdkVycm9yKFwiQ1NWX09QVElPTl9RVU9URV9JTlZBTElEX1RZUEVcIiwgW1xuICAgICAgICBcIm9wdGlvbiBgcXVvdGVgIG11c3QgYmUgYSBib29sZWFuLCBhIGJ1ZmZlciBvciBhIHN0cmluZyxcIixcbiAgICAgICAgYGdvdCAke0pTT04uc3RyaW5naWZ5KG9wdGlvbnMucXVvdGUpfWAsXG4gICAgICBdKSxcbiAgICBdO1xuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gYHF1b3RlZGBcbiAgaWYgKG9wdGlvbnMucXVvdGVkID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5xdW90ZWQgPT09IG51bGwpIHtcbiAgICBvcHRpb25zLnF1b3RlZCA9IGZhbHNlO1xuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gYGVzY2FwZV9mb3JtdWxhc2BcbiAgaWYgKFxuICAgIG9wdGlvbnMuZXNjYXBlX2Zvcm11bGFzID09PSB1bmRlZmluZWQgfHxcbiAgICBvcHRpb25zLmVzY2FwZV9mb3JtdWxhcyA9PT0gbnVsbFxuICApIHtcbiAgICBvcHRpb25zLmVzY2FwZV9mb3JtdWxhcyA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmVzY2FwZV9mb3JtdWxhcyAhPT0gXCJib29sZWFuXCIpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbmV3IENzdkVycm9yKFwiQ1NWX09QVElPTl9FU0NBUEVfRk9STVVMQVNfSU5WQUxJRF9UWVBFXCIsIFtcbiAgICAgICAgXCJvcHRpb24gYGVzY2FwZV9mb3JtdWxhc2AgbXVzdCBiZSBhIGJvb2xlYW4sXCIsXG4gICAgICAgIGBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLmVzY2FwZV9mb3JtdWxhcyl9YCxcbiAgICAgIF0pLFxuICAgIF07XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgcXVvdGVkX2VtcHR5YFxuICBpZiAob3B0aW9ucy5xdW90ZWRfZW1wdHkgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnF1b3RlZF9lbXB0eSA9PT0gbnVsbCkge1xuICAgIG9wdGlvbnMucXVvdGVkX2VtcHR5ID0gdW5kZWZpbmVkO1xuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gYHF1b3RlZF9tYXRjaGBcbiAgaWYgKFxuICAgIG9wdGlvbnMucXVvdGVkX21hdGNoID09PSB1bmRlZmluZWQgfHxcbiAgICBvcHRpb25zLnF1b3RlZF9tYXRjaCA9PT0gbnVsbCB8fFxuICAgIG9wdGlvbnMucXVvdGVkX21hdGNoID09PSBmYWxzZVxuICApIHtcbiAgICBvcHRpb25zLnF1b3RlZF9tYXRjaCA9IG51bGw7XG4gIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucy5xdW90ZWRfbWF0Y2gpKSB7XG4gICAgb3B0aW9ucy5xdW90ZWRfbWF0Y2ggPSBbb3B0aW9ucy5xdW90ZWRfbWF0Y2hdO1xuICB9XG4gIGlmIChvcHRpb25zLnF1b3RlZF9tYXRjaCkge1xuICAgIGZvciAoY29uc3QgcXVvdGVkX21hdGNoIG9mIG9wdGlvbnMucXVvdGVkX21hdGNoKSB7XG4gICAgICBjb25zdCBpc1N0cmluZyA9IHR5cGVvZiBxdW90ZWRfbWF0Y2ggPT09IFwic3RyaW5nXCI7XG4gICAgICBjb25zdCBpc1JlZ0V4cCA9IHF1b3RlZF9tYXRjaCBpbnN0YW5jZW9mIFJlZ0V4cDtcbiAgICAgIGlmICghaXNTdHJpbmcgJiYgIWlzUmVnRXhwKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgRXJyb3IoXG4gICAgICAgICAgICBgSW52YWxpZCBPcHRpb246IHF1b3RlZF9tYXRjaCBtdXN0IGJlIGEgc3RyaW5nIG9yIGEgcmVnZXgsIGdvdCAke0pTT04uc3RyaW5naWZ5KHF1b3RlZF9tYXRjaCl9YCxcbiAgICAgICAgICApLFxuICAgICAgICBdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBOb3JtYWxpemUgb3B0aW9uIGBxdW90ZWRfc3RyaW5nYFxuICBpZiAob3B0aW9ucy5xdW90ZWRfc3RyaW5nID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5xdW90ZWRfc3RyaW5nID09PSBudWxsKSB7XG4gICAgb3B0aW9ucy5xdW90ZWRfc3RyaW5nID0gZmFsc2U7XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBgZW9mYFxuICBpZiAob3B0aW9ucy5lb2YgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmVvZiA9PT0gbnVsbCkge1xuICAgIG9wdGlvbnMuZW9mID0gdHJ1ZTtcbiAgfVxuICAvLyBOb3JtYWxpemUgb3B0aW9uIGBlc2NhcGVgXG4gIGlmIChvcHRpb25zLmVzY2FwZSA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuZXNjYXBlID09PSBudWxsKSB7XG4gICAgb3B0aW9ucy5lc2NhcGUgPSAnXCInO1xuICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvcHRpb25zLmVzY2FwZSkpIHtcbiAgICBvcHRpb25zLmVzY2FwZSA9IG9wdGlvbnMuZXNjYXBlLnRvU3RyaW5nKCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuZXNjYXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIEVycm9yKFxuICAgICAgICBgSW52YWxpZCBPcHRpb246IGVzY2FwZSBtdXN0IGJlIGEgYnVmZmVyIG9yIGEgc3RyaW5nLCBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLmVzY2FwZSl9YCxcbiAgICAgICksXG4gICAgXTtcbiAgfVxuICBpZiAob3B0aW9ucy5lc2NhcGUubGVuZ3RoID4gMSkge1xuICAgIHJldHVybiBbXG4gICAgICBFcnJvcihcbiAgICAgICAgYEludmFsaWQgT3B0aW9uOiBlc2NhcGUgbXVzdCBiZSBvbmUgY2hhcmFjdGVyLCBnb3QgJHtvcHRpb25zLmVzY2FwZS5sZW5ndGh9IGNoYXJhY3RlcnNgLFxuICAgICAgKSxcbiAgICBdO1xuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gYGhlYWRlcmBcbiAgaWYgKG9wdGlvbnMuaGVhZGVyID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5oZWFkZXIgPT09IG51bGwpIHtcbiAgICBvcHRpb25zLmhlYWRlciA9IGZhbHNlO1xuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gYGNvbHVtbnNgXG4gIGNvbnN0IFtlcnJDb2x1bW5zLCBjb2x1bW5zXSA9IG5vcm1hbGl6ZV9jb2x1bW5zKG9wdGlvbnMuY29sdW1ucyk7XG4gIGlmIChlcnJDb2x1bW5zICE9PSB1bmRlZmluZWQpIHJldHVybiBbZXJyQ29sdW1uc107XG4gIG9wdGlvbnMuY29sdW1ucyA9IGNvbHVtbnM7XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gYHF1b3RlZGBcbiAgaWYgKG9wdGlvbnMucXVvdGVkID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5xdW90ZWQgPT09IG51bGwpIHtcbiAgICBvcHRpb25zLnF1b3RlZCA9IGZhbHNlO1xuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gYGNhc3RgXG4gIGlmIChvcHRpb25zLmNhc3QgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmNhc3QgPT09IG51bGwpIHtcbiAgICBvcHRpb25zLmNhc3QgPSB7fTtcbiAgfVxuICAvLyBOb3JtYWxpemUgb3B0aW9uIGNhc3QuYmlnaW50XG4gIGlmIChvcHRpb25zLmNhc3QuYmlnaW50ID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5jYXN0LmJpZ2ludCA9PT0gbnVsbCkge1xuICAgIC8vIENhc3QgYm9vbGVhbiB0byBzdHJpbmcgYnkgZGVmYXVsdFxuICAgIG9wdGlvbnMuY2FzdC5iaWdpbnQgPSAodmFsdWUpID0+IFwiXCIgKyB2YWx1ZTtcbiAgfVxuICAvLyBOb3JtYWxpemUgb3B0aW9uIGNhc3QuYm9vbGVhblxuICBpZiAob3B0aW9ucy5jYXN0LmJvb2xlYW4gPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmNhc3QuYm9vbGVhbiA9PT0gbnVsbCkge1xuICAgIC8vIENhc3QgYm9vbGVhbiB0byBzdHJpbmcgYnkgZGVmYXVsdFxuICAgIG9wdGlvbnMuY2FzdC5ib29sZWFuID0gKHZhbHVlKSA9PiAodmFsdWUgPyBcIjFcIiA6IFwiXCIpO1xuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gY2FzdC5kYXRlXG4gIGlmIChvcHRpb25zLmNhc3QuZGF0ZSA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuY2FzdC5kYXRlID09PSBudWxsKSB7XG4gICAgLy8gQ2FzdCBkYXRlIHRvIHRpbWVzdGFtcCBzdHJpbmcgYnkgZGVmYXVsdFxuICAgIG9wdGlvbnMuY2FzdC5kYXRlID0gKHZhbHVlKSA9PiBcIlwiICsgdmFsdWUuZ2V0VGltZSgpO1xuICB9XG4gIC8vIE5vcm1hbGl6ZSBvcHRpb24gY2FzdC5udW1iZXJcbiAgaWYgKG9wdGlvbnMuY2FzdC5udW1iZXIgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmNhc3QubnVtYmVyID09PSBudWxsKSB7XG4gICAgLy8gQ2FzdCBudW1iZXIgdG8gc3RyaW5nIHVzaW5nIG5hdGl2ZSBjYXN0aW5nIGJ5IGRlZmF1bHRcbiAgICBvcHRpb25zLmNhc3QubnVtYmVyID0gKHZhbHVlKSA9PiBcIlwiICsgdmFsdWU7XG4gIH1cbiAgLy8gTm9ybWFsaXplIG9wdGlvbiBjYXN0Lm9iamVjdFxuICBpZiAob3B0aW9ucy5jYXN0Lm9iamVjdCA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuY2FzdC5vYmplY3QgPT09IG51bGwpIHtcbiAgICAvLyBTdHJpbmdpZnkgb2JqZWN0IGFzIEpTT04gYnkgZGVmYXVsdFxuICAgIG9wdGlvbnMuY2FzdC5vYmplY3QgPSAodmFsdWUpID0+IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgfVxuICAvLyBOb3JtYWxpemUgb3B0aW9uIGNhc3Quc3RyaW5nXG4gIGlmIChvcHRpb25zLmNhc3Quc3RyaW5nID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5jYXN0LnN0cmluZyA9PT0gbnVsbCkge1xuICAgIC8vIExlYXZlIHN0cmluZyB1bnRvdWNoZWRcbiAgICBvcHRpb25zLmNhc3Quc3RyaW5nID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgfVxuICAvLyBOb3JtYWxpemUgb3B0aW9uIGBvbl9yZWNvcmRgXG4gIGlmIChcbiAgICBvcHRpb25zLm9uX3JlY29yZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgdHlwZW9mIG9wdGlvbnMub25fcmVjb3JkICE9PSBcImZ1bmN0aW9uXCJcbiAgKSB7XG4gICAgcmV0dXJuIFtFcnJvcihgSW52YWxpZCBPcHRpb246IFwib25fcmVjb3JkXCIgbXVzdCBiZSBhIGZ1bmN0aW9uLmApXTtcbiAgfVxuICAvLyBOb3JtYWxpemUgb3B0aW9uIGByZWNvcmRfZGVsaW1pdGVyYFxuICBpZiAoXG4gICAgb3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyID09PSB1bmRlZmluZWQgfHxcbiAgICBvcHRpb25zLnJlY29yZF9kZWxpbWl0ZXIgPT09IG51bGxcbiAgKSB7XG4gICAgb3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyID0gXCJcXG5cIjtcbiAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIob3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyKSkge1xuICAgIG9wdGlvbnMucmVjb3JkX2RlbGltaXRlciA9IG9wdGlvbnMucmVjb3JkX2RlbGltaXRlci50b1N0cmluZygpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLnJlY29yZF9kZWxpbWl0ZXIgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gW1xuICAgICAgRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIE9wdGlvbjogcmVjb3JkX2RlbGltaXRlciBtdXN0IGJlIGEgYnVmZmVyIG9yIGEgc3RyaW5nLCBnb3QgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLnJlY29yZF9kZWxpbWl0ZXIpfWAsXG4gICAgICApLFxuICAgIF07XG4gIH1cbiAgc3dpdGNoIChvcHRpb25zLnJlY29yZF9kZWxpbWl0ZXIpIHtcbiAgICBjYXNlIFwidW5peFwiOlxuICAgICAgb3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyID0gXCJcXG5cIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJtYWNcIjpcbiAgICAgIG9wdGlvbnMucmVjb3JkX2RlbGltaXRlciA9IFwiXFxyXCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwid2luZG93c1wiOlxuICAgICAgb3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyID0gXCJcXHJcXG5cIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJhc2NpaVwiOlxuICAgICAgb3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyID0gXCJcXHUwMDFlXCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwidW5pY29kZVwiOlxuICAgICAgb3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyID0gXCJcXHUyMDI4XCI7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gW3VuZGVmaW5lZCwgb3B0aW9uc107XG59O1xuXG5jb25zdCBib21fdXRmOCA9IEJ1ZmZlci5mcm9tKFsyMzksIDE4NywgMTkxXSk7XG5cbmNvbnN0IHN0cmluZ2lmaWVyID0gZnVuY3Rpb24gKG9wdGlvbnMsIHN0YXRlLCBpbmZvKSB7XG4gIHJldHVybiB7XG4gICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICBzdGF0ZTogc3RhdGUsXG4gICAgaW5mbzogaW5mbyxcbiAgICBfX3RyYW5zZm9ybTogZnVuY3Rpb24gKGNodW5rLCBwdXNoKSB7XG4gICAgICAvLyBDaHVuayB2YWxpZGF0aW9uXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gRXJyb3IoXG4gICAgICAgICAgYEludmFsaWQgUmVjb3JkOiBleHBlY3QgYW4gYXJyYXkgb3IgYW4gb2JqZWN0LCBnb3QgJHtKU09OLnN0cmluZ2lmeShjaHVuayl9YCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIC8vIERldGVjdCBjb2x1bW5zIGZyb20gdGhlIGZpcnN0IHJlY29yZFxuICAgICAgaWYgKHRoaXMuaW5mby5yZWNvcmRzID09PSAwKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNodW5rKSkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5oZWFkZXIgPT09IHRydWUgJiZcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5jb2x1bW5zID09PSB1bmRlZmluZWRcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBFcnJvcihcbiAgICAgICAgICAgICAgXCJVbmRpc2NvdmVyYWJsZSBDb2x1bW5zOiBoZWFkZXIgb3B0aW9uIHJlcXVpcmVzIGNvbHVtbiBvcHRpb24gb3Igb2JqZWN0IHJlY29yZHNcIixcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5jb2x1bW5zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb25zdCBbZXJyLCBjb2x1bW5zXSA9IG5vcm1hbGl6ZV9jb2x1bW5zKE9iamVjdC5rZXlzKGNodW5rKSk7XG4gICAgICAgICAgaWYgKGVycikgcmV0dXJuO1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5jb2x1bW5zID0gY29sdW1ucztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gRW1pdCB0aGUgaGVhZGVyXG4gICAgICBpZiAodGhpcy5pbmZvLnJlY29yZHMgPT09IDApIHtcbiAgICAgICAgdGhpcy5ib20ocHVzaCk7XG4gICAgICAgIGNvbnN0IGVyciA9IHRoaXMuaGVhZGVycyhwdXNoKTtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGVycjtcbiAgICAgIH1cbiAgICAgIC8vIEVtaXQgYW5kIHN0cmluZ2lmeSB0aGUgcmVjb3JkIGlmIGFuIG9iamVjdCBvciBhbiBhcnJheVxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gdGhpcy5lbWl0KCdyZWNvcmQnLCBjaHVuaywgdGhpcy5pbmZvLnJlY29yZHMpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm9uX3JlY29yZCkge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5vbl9yZWNvcmQoY2h1bmssIHRoaXMuaW5mby5yZWNvcmRzKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgICB9XG4gICAgICAvLyBDb252ZXJ0IHRoZSByZWNvcmQgaW50byBhIHN0cmluZ1xuICAgICAgbGV0IGVyciwgY2h1bmtfc3RyaW5nO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lb2YpIHtcbiAgICAgICAgW2VyciwgY2h1bmtfc3RyaW5nXSA9IHRoaXMuc3RyaW5naWZ5KGNodW5rKTtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGVycjtcbiAgICAgICAgaWYgKGNodW5rX3N0cmluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNodW5rX3N0cmluZyA9IGNodW5rX3N0cmluZyArIHRoaXMub3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBbZXJyLCBjaHVua19zdHJpbmddID0gdGhpcy5zdHJpbmdpZnkoY2h1bmspO1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gZXJyO1xuICAgICAgICBpZiAoY2h1bmtfc3RyaW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oZWFkZXIgfHwgdGhpcy5pbmZvLnJlY29yZHMpIHtcbiAgICAgICAgICAgIGNodW5rX3N0cmluZyA9IHRoaXMub3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyICsgY2h1bmtfc3RyaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gRW1pdCB0aGUgY3N2XG4gICAgICB0aGlzLmluZm8ucmVjb3JkcysrO1xuICAgICAgcHVzaChjaHVua19zdHJpbmcpO1xuICAgIH0sXG4gICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAoY2h1bmssIGNodW5rSXNIZWFkZXIgPSBmYWxzZSkge1xuICAgICAgaWYgKHR5cGVvZiBjaHVuayAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gW3VuZGVmaW5lZCwgY2h1bmtdO1xuICAgICAgfVxuICAgICAgY29uc3QgeyBjb2x1bW5zIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICBjb25zdCByZWNvcmQgPSBbXTtcbiAgICAgIC8vIFJlY29yZCBpcyBhbiBhcnJheVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2h1bmspKSB7XG4gICAgICAgIC8vIFdlIGFyZSBnZXR0aW5nIGFuIGFycmF5IGJ1dCB0aGUgdXNlciBoYXMgc3BlY2lmaWVkIG91dHB1dCBjb2x1bW5zLiBJblxuICAgICAgICAvLyB0aGlzIGNhc2UsIHdlIHJlc3BlY3QgdGhlIGNvbHVtbnMgaW5kZXhlc1xuICAgICAgICBpZiAoY29sdW1ucykge1xuICAgICAgICAgIGNodW5rLnNwbGljZShjb2x1bW5zLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FzdCByZWNvcmQgZWxlbWVudHNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaHVuay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGZpZWxkID0gY2h1bmtbaV07XG4gICAgICAgICAgY29uc3QgW2VyciwgdmFsdWVdID0gdGhpcy5fX2Nhc3QoZmllbGQsIHtcbiAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgY29sdW1uOiBpLFxuICAgICAgICAgICAgcmVjb3JkczogdGhpcy5pbmZvLnJlY29yZHMsXG4gICAgICAgICAgICBoZWFkZXI6IGNodW5rSXNIZWFkZXIsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGVycikgcmV0dXJuIFtlcnJdO1xuICAgICAgICAgIHJlY29yZFtpXSA9IFt2YWx1ZSwgZmllbGRdO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlY29yZCBpcyBhIGxpdGVyYWwgb2JqZWN0XG4gICAgICAgIC8vIGBjb2x1bW5zYCBpcyBhbHdheXMgZGVmaW5lZDogaXQgaXMgZWl0aGVyIHByb3ZpZGVkIG9yIGRpc2NvdmVyZWQuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHVtbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBmaWVsZCA9IGdldChjaHVuaywgY29sdW1uc1tpXS5rZXkpO1xuICAgICAgICAgIGNvbnN0IFtlcnIsIHZhbHVlXSA9IHRoaXMuX19jYXN0KGZpZWxkLCB7XG4gICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgIGNvbHVtbjogY29sdW1uc1tpXS5rZXksXG4gICAgICAgICAgICByZWNvcmRzOiB0aGlzLmluZm8ucmVjb3JkcyxcbiAgICAgICAgICAgIGhlYWRlcjogY2h1bmtJc0hlYWRlcixcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gW2Vycl07XG4gICAgICAgICAgcmVjb3JkW2ldID0gW3ZhbHVlLCBmaWVsZF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBjc3ZyZWNvcmQgPSBcIlwiO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWNvcmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG9wdGlvbnMsIGVycjtcblxuICAgICAgICBsZXQgW3ZhbHVlLCBmaWVsZF0gPSByZWNvcmRbaV07XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB9IGVsc2UgaWYgKGlzX29iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICBvcHRpb25zID0gdmFsdWU7XG4gICAgICAgICAgdmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLnZhbHVlO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgdmFsdWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdmFsdWUgIT09IG51bGxcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBgSW52YWxpZCBDYXN0aW5nIFZhbHVlOiByZXR1cm5lZCB2YWx1ZSBtdXN0IHJldHVybiBhIHN0cmluZywgbnVsbCBvciB1bmRlZmluZWQsIGdvdCAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gLFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIF07XG4gICAgICAgICAgfVxuICAgICAgICAgIG9wdGlvbnMgPSB7IC4uLnRoaXMub3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgIFtlcnIsIG9wdGlvbnNdID0gbm9ybWFsaXplX29wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgICAgaWYgKGVyciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gW2Vycl07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBFcnJvcihcbiAgICAgICAgICAgICAgYEludmFsaWQgQ2FzdGluZyBWYWx1ZTogcmV0dXJuZWQgdmFsdWUgbXVzdCByZXR1cm4gYSBzdHJpbmcsIGFuIG9iamVjdCwgbnVsbCBvciB1bmRlZmluZWQsIGdvdCAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBkZWxpbWl0ZXIsXG4gICAgICAgICAgZXNjYXBlLFxuICAgICAgICAgIHF1b3RlLFxuICAgICAgICAgIHF1b3RlZCxcbiAgICAgICAgICBxdW90ZWRfZW1wdHksXG4gICAgICAgICAgcXVvdGVkX3N0cmluZyxcbiAgICAgICAgICBxdW90ZWRfbWF0Y2gsXG4gICAgICAgICAgcmVjb3JkX2RlbGltaXRlcixcbiAgICAgICAgICBlc2NhcGVfZm9ybXVsYXMsXG4gICAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgICBpZiAoXCJcIiA9PT0gdmFsdWUgJiYgXCJcIiA9PT0gZmllbGQpIHtcbiAgICAgICAgICBsZXQgcXVvdGVkTWF0Y2ggPVxuICAgICAgICAgICAgcXVvdGVkX21hdGNoICYmXG4gICAgICAgICAgICBxdW90ZWRfbWF0Y2guZmlsdGVyKChxdW90ZWRfbWF0Y2gpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBxdW90ZWRfbWF0Y2ggPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuaW5kZXhPZihxdW90ZWRfbWF0Y2gpICE9PSAtMTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcXVvdGVkX21hdGNoLnRlc3QodmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICBxdW90ZWRNYXRjaCA9IHF1b3RlZE1hdGNoICYmIHF1b3RlZE1hdGNoLmxlbmd0aCA+IDA7XG4gICAgICAgICAgY29uc3Qgc2hvdWxkUXVvdGUgPVxuICAgICAgICAgICAgcXVvdGVkTWF0Y2ggfHxcbiAgICAgICAgICAgIHRydWUgPT09IHF1b3RlZF9lbXB0eSB8fFxuICAgICAgICAgICAgKHRydWUgPT09IHF1b3RlZF9zdHJpbmcgJiYgZmFsc2UgIT09IHF1b3RlZF9lbXB0eSk7XG4gICAgICAgICAgaWYgKHNob3VsZFF1b3RlID09PSB0cnVlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHF1b3RlICsgdmFsdWUgKyBxdW90ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3N2cmVjb3JkICs9IHZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgRXJyb3IoXG4gICAgICAgICAgICAgICAgYEZvcm1hdHRlciBtdXN0IHJldHVybiBhIHN0cmluZywgbnVsbCBvciB1bmRlZmluZWQsIGdvdCAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gLFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgY29udGFpbnNkZWxpbWl0ZXIgPVxuICAgICAgICAgICAgZGVsaW1pdGVyLmxlbmd0aCAmJiB2YWx1ZS5pbmRleE9mKGRlbGltaXRlcikgPj0gMDtcbiAgICAgICAgICBjb25zdCBjb250YWluc1F1b3RlID0gcXVvdGUgIT09IFwiXCIgJiYgdmFsdWUuaW5kZXhPZihxdW90ZSkgPj0gMDtcbiAgICAgICAgICBjb25zdCBjb250YWluc0VzY2FwZSA9IHZhbHVlLmluZGV4T2YoZXNjYXBlKSA+PSAwICYmIGVzY2FwZSAhPT0gcXVvdGU7XG4gICAgICAgICAgY29uc3QgY29udGFpbnNSZWNvcmREZWxpbWl0ZXIgPSB2YWx1ZS5pbmRleE9mKHJlY29yZF9kZWxpbWl0ZXIpID49IDA7XG4gICAgICAgICAgY29uc3QgcXVvdGVkU3RyaW5nID0gcXVvdGVkX3N0cmluZyAmJiB0eXBlb2YgZmllbGQgPT09IFwic3RyaW5nXCI7XG4gICAgICAgICAgbGV0IHF1b3RlZE1hdGNoID1cbiAgICAgICAgICAgIHF1b3RlZF9tYXRjaCAmJlxuICAgICAgICAgICAgcXVvdGVkX21hdGNoLmZpbHRlcigocXVvdGVkX21hdGNoKSA9PiB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgcXVvdGVkX21hdGNoID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmluZGV4T2YocXVvdGVkX21hdGNoKSAhPT0gLTE7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHF1b3RlZF9tYXRjaC50ZXN0KHZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgcXVvdGVkTWF0Y2ggPSBxdW90ZWRNYXRjaCAmJiBxdW90ZWRNYXRjaC5sZW5ndGggPiAwO1xuICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYWRhbHRhcy9ub2RlLWNzdi9wdWxsLzM4N1xuICAgICAgICAgIC8vIE1vcmUgYWJvdXQgQ1NWIGluamVjdGlvbiBvciBmb3JtdWxhIGluamVjdGlvbiwgd2hlbiB3ZWJzaXRlcyBlbWJlZFxuICAgICAgICAgIC8vIHVudHJ1c3RlZCBpbnB1dCBpbnNpZGUgQ1NWIGZpbGVzOlxuICAgICAgICAgIC8vIGh0dHBzOi8vb3dhc3Aub3JnL3d3dy1jb21tdW5pdHkvYXR0YWNrcy9DU1ZfSW5qZWN0aW9uXG4gICAgICAgICAgLy8gaHR0cDovL2dlb3JnZW1hdWVyLm5ldC8yMDE3LzEwLzA3L2Nzdi1pbmplY3Rpb24uaHRtbFxuICAgICAgICAgIC8vIEFwcGxlIE51bWJlcnMgdW5pY29kZSBub3JtYWxpemF0aW9uIGlzIGVtcGlyaWNhbCBmcm9tIHRlc3RpbmdcbiAgICAgICAgICBpZiAoZXNjYXBlX2Zvcm11bGFzKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHZhbHVlWzBdKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCI9XCI6XG4gICAgICAgICAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCItXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJAXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJcXHRcIjpcbiAgICAgICAgICAgICAgY2FzZSBcIlxcclwiOlxuICAgICAgICAgICAgICBjYXNlIFwiXFx1RkYxRFwiOiAvLyBVbmljb2RlICc9J1xuICAgICAgICAgICAgICBjYXNlIFwiXFx1RkYwQlwiOiAvLyBVbmljb2RlICcrJ1xuICAgICAgICAgICAgICBjYXNlIFwiXFx1RkYwRFwiOiAvLyBVbmljb2RlICctJ1xuICAgICAgICAgICAgICBjYXNlIFwiXFx1RkYyMFwiOiAvLyBVbmljb2RlICdAJ1xuICAgICAgICAgICAgICAgIHZhbHVlID0gYCcke3ZhbHVlfWA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHNob3VsZFF1b3RlID1cbiAgICAgICAgICAgIGNvbnRhaW5zUXVvdGUgPT09IHRydWUgfHxcbiAgICAgICAgICAgIGNvbnRhaW5zZGVsaW1pdGVyIHx8XG4gICAgICAgICAgICBjb250YWluc1JlY29yZERlbGltaXRlciB8fFxuICAgICAgICAgICAgcXVvdGVkIHx8XG4gICAgICAgICAgICBxdW90ZWRTdHJpbmcgfHxcbiAgICAgICAgICAgIHF1b3RlZE1hdGNoO1xuICAgICAgICAgIGlmIChzaG91bGRRdW90ZSA9PT0gdHJ1ZSAmJiBjb250YWluc0VzY2FwZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgcmVnZXhwID1cbiAgICAgICAgICAgICAgZXNjYXBlID09PSBcIlxcXFxcIlxuICAgICAgICAgICAgICAgID8gbmV3IFJlZ0V4cChlc2NhcGUgKyBlc2NhcGUsIFwiZ1wiKVxuICAgICAgICAgICAgICAgIDogbmV3IFJlZ0V4cChlc2NhcGUsIFwiZ1wiKTtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZWdleHAsIGVzY2FwZSArIGVzY2FwZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb250YWluc1F1b3RlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCByZWdleHAgPSBuZXcgUmVnRXhwKHF1b3RlLCBcImdcIik7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocmVnZXhwLCBlc2NhcGUgKyBxdW90ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzaG91bGRRdW90ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSBxdW90ZSArIHZhbHVlICsgcXVvdGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNzdnJlY29yZCArPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICBxdW90ZWRfZW1wdHkgPT09IHRydWUgfHxcbiAgICAgICAgICAoZmllbGQgPT09IFwiXCIgJiYgcXVvdGVkX3N0cmluZyA9PT0gdHJ1ZSAmJiBxdW90ZWRfZW1wdHkgIT09IGZhbHNlKVxuICAgICAgICApIHtcbiAgICAgICAgICBjc3ZyZWNvcmQgKz0gcXVvdGUgKyBxdW90ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSAhPT0gcmVjb3JkLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBjc3ZyZWNvcmQgKz0gZGVsaW1pdGVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gW3VuZGVmaW5lZCwgY3N2cmVjb3JkXTtcbiAgICB9LFxuICAgIGJvbTogZnVuY3Rpb24gKHB1c2gpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYm9tICE9PSB0cnVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHB1c2goYm9tX3V0ZjgpO1xuICAgIH0sXG4gICAgaGVhZGVyczogZnVuY3Rpb24gKHB1c2gpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGVhZGVyID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmNvbHVtbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgZXJyO1xuICAgICAgbGV0IGhlYWRlcnMgPSB0aGlzLm9wdGlvbnMuY29sdW1ucy5tYXAoKGNvbHVtbikgPT4gY29sdW1uLmhlYWRlcik7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVvZikge1xuICAgICAgICBbZXJyLCBoZWFkZXJzXSA9IHRoaXMuc3RyaW5naWZ5KGhlYWRlcnMsIHRydWUpO1xuICAgICAgICBoZWFkZXJzICs9IHRoaXMub3B0aW9ucy5yZWNvcmRfZGVsaW1pdGVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgW2VyciwgaGVhZGVyc10gPSB0aGlzLnN0cmluZ2lmeShoZWFkZXJzKTtcbiAgICAgIH1cbiAgICAgIGlmIChlcnIpIHJldHVybiBlcnI7XG4gICAgICBwdXNoKGhlYWRlcnMpO1xuICAgIH0sXG4gICAgX19jYXN0OiBmdW5jdGlvbiAodmFsdWUsIGNvbnRleHQpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIC8vIEZpbmUgZm9yIDk5JSBvZiB0aGUgY2FzZXNcbiAgICAgICAgICByZXR1cm4gW3VuZGVmaW5lZCwgdGhpcy5vcHRpb25zLmNhc3Quc3RyaW5nKHZhbHVlLCBjb250ZXh0KV07XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICAgIHJldHVybiBbdW5kZWZpbmVkLCB0aGlzLm9wdGlvbnMuY2FzdC5iaWdpbnQodmFsdWUsIGNvbnRleHQpXTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgcmV0dXJuIFt1bmRlZmluZWQsIHRoaXMub3B0aW9ucy5jYXN0Lm51bWJlcih2YWx1ZSwgY29udGV4dCldO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgcmV0dXJuIFt1bmRlZmluZWQsIHRoaXMub3B0aW9ucy5jYXN0LmJvb2xlYW4odmFsdWUsIGNvbnRleHQpXTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICByZXR1cm4gW3VuZGVmaW5lZCwgdGhpcy5vcHRpb25zLmNhc3QuZGF0ZSh2YWx1ZSwgY29udGV4dCldO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gW3VuZGVmaW5lZCwgdGhpcy5vcHRpb25zLmNhc3Qub2JqZWN0KHZhbHVlLCBjb250ZXh0KV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFt1bmRlZmluZWQsIHZhbHVlLCB2YWx1ZV07XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gW2Vycl07XG4gICAgICB9XG4gICAgfSxcbiAgfTtcbn07XG5cbmNvbnN0IHN0cmluZ2lmeSA9IGZ1bmN0aW9uIChyZWNvcmRzLCBvcHRzID0ge30pIHtcbiAgY29uc3QgZGF0YSA9IFtdO1xuICBjb25zdCBbZXJyLCBvcHRpb25zXSA9IG5vcm1hbGl6ZV9vcHRpb25zKG9wdHMpO1xuICBpZiAoZXJyICE9PSB1bmRlZmluZWQpIHRocm93IGVycjtcbiAgY29uc3Qgc3RhdGUgPSB7XG4gICAgc3RvcDogZmFsc2UsXG4gIH07XG4gIC8vIEluZm9ybWF0aW9uXG4gIGNvbnN0IGluZm8gPSB7XG4gICAgcmVjb3JkczogMCxcbiAgfTtcbiAgY29uc3QgYXBpID0gc3RyaW5naWZpZXIob3B0aW9ucywgc3RhdGUsIGluZm8pO1xuICBmb3IgKGNvbnN0IHJlY29yZCBvZiByZWNvcmRzKSB7XG4gICAgY29uc3QgZXJyID0gYXBpLl9fdHJhbnNmb3JtKHJlY29yZCwgZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgZGF0YS5wdXNoKHJlY29yZCk7XG4gICAgfSk7XG4gICAgaWYgKGVyciAhPT0gdW5kZWZpbmVkKSB0aHJvdyBlcnI7XG4gIH1cbiAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgYXBpLmJvbSgoZCkgPT4ge1xuICAgICAgZGF0YS5wdXNoKGQpO1xuICAgIH0pO1xuICAgIGNvbnN0IGVyciA9IGFwaS5oZWFkZXJzKChoZWFkZXJzKSA9PiB7XG4gICAgICBkYXRhLnB1c2goaGVhZGVycyk7XG4gICAgfSk7XG4gICAgaWYgKGVyciAhPT0gdW5kZWZpbmVkKSB0aHJvdyBlcnI7XG4gIH1cbiAgcmV0dXJuIGRhdGEuam9pbihcIlwiKTtcbn07XG5cbmV4cG9ydHMuc3RyaW5naWZ5ID0gc3RyaW5naWZ5O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/csv-stringify/dist/cjs/sync.cjs\n");

/***/ })

};
;